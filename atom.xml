<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵逸尘个人博客</title>
  
  <subtitle>记录工作生活</subtitle>
  <link href="https://zml3589110.github.io/atom.xml" rel="self"/>
  
  <link href="https://zml3589110.github.io/"/>
  <updated>2025-09-15T13:19:33.944Z</updated>
  <id>https://zml3589110.github.io/</id>
  
  <author>
    <name>ZhaoYichen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>裸机开发环境搭建</title>
    <link href="https://zml3589110.github.io/posts/3907184433.html"/>
    <id>https://zml3589110.github.io/posts/3907184433.html</id>
    <published>2025-09-15T13:18:20.000Z</published>
    <updated>2025-09-15T13:19:33.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C100S的裸机开发环境搭建"><a href="#F1C100S的裸机开发环境搭建" class="headerlink" title="F1C100S的裸机开发环境搭建"></a>F1C100S的裸机开发环境搭建</h1><p> 我第一次听说荔枝派是不知道多久之前，在电子发烧友网的众筹板块上(现在貌似没众筹了)，那块简陋但功能强大的板子给我留下了很深刻的印象。之后出了荔枝派Nano，资源和性能都有限，但依然可以跑Linux这样的操作系统，而且价格非常便宜，零售一片三十几块。就算不能上Linux、压榨尽可能多的性能，拿来当单片机开发板用，综合性能也是很拔尖的。</p><img src="/posts/undefined/37dd32257da34fea3e855303fb63725690f8f857.png@1192w.webp" class="" title="img"><p>但是SoC的生产厂家并没有在官网上给出足够的技术支持，毕竟咱们交不起那么多钱签协议，所以想驾驭荔枝派，要踩的坑非常多，可用的资料资料也少得可怜。虽然有WhyCan的各位大佬完善开发生态，对于我这个喜欢折腾底层的人来说，可用的资料依然不多，只有移植好的u-boot、linux、码云上几个基于keil的模板以及RTT相关底层驱动。</p><p>​    所以，只能见坑填坑，让之后的开发者少踩几个坑。</p><p>​    PS:由于up能力有限，一个多月了才点了个灯，所以相关专栏更新会非常……非常慢……（踩坑过程中的大部分代码会在达到一定完善程度之后开源，小测试之类的代码中有用的部分会整合到主线代码中）</p><img src="/posts/undefined/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    一位嵌入式大佬，用F1C100S，也就是荔枝派Nano的使用的SoC制作了一张名片</p><img src="/posts/undefined/36346b7b84a2c28e0719454d40bed35c6f0eba52.jpg@1192w.webp" class="" title="img"><p>大佬的名片</p><p>​    这张名片的资料已经在github开源，国内的码云也有同步仓库(<a href="https://gitee.com/mirrors/business-card-linux)%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E8%8A%AF%E7%89%87%E6%89%8B%E5%86%8C">https://gitee.com/mirrors/business-card-linux)，在这个仓库中，可以找到芯片手册</a></p><img src="/posts/undefined/59ba8d7a25d5187c78039b5fda0f80806a42eadc.jpg@1192w.webp" class="" title="img"><p>F1C100S的数据手册和用户手册</p><p>​    在这一部分中，大佬提供的用户手册是F1C600的，所以暂且认定二者手册通用。</p><p>​    参考代码可以使用码云上基于keil进行F1C100S裸机开发的Demo和移植好的u-boot(linux太复杂，暂不考虑)，比如<a href="https://gitee.com/LicheePiNano/F1C100S_MDK%E8%BF%99%E4%B8%AA%E4%BE%8B%E7%A8%8B">https://gitee.com/LicheePiNano/F1C100S_MDK这个例程</a></p><img src="/posts/undefined/03fa1838b0a431c9545d45dff1955004c56ed85c.jpg@1192w.webp" class="" title="img"><p>​    要注意的是，这个仓库并没有指定许可证，所以这里默认仓库中的所有代码、文件只能用于学习。不过看TA的用户名，应该也是荔枝派的爱好者，应该不会介意我在这里参考一下TA的代码。</p><p>​    u-boot选择<a href="https://gitee.com/scotthsl/u-boot-licheepi%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%A6%81%E6%9C%89%E7%BA%A2%E5%9C%88%E7%9A%84%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E6%89%8D%E6%98%AF%E7%A7%BB%E6%A4%8D%E5%88%B0F1C100S%E7%9A%84u-boot">https://gitee.com/scotthsl/u-boot-licheepi，注意要有红圈的这个分支，这个分支才是移植到F1C100S的u-boot</a></p><img src="/posts/undefined/15b193dbea6e65cf04b2868c55b2e8b072af2ec2.jpg@1192w.webp" class="" title="img"><p>要有红圈这个分支</p><p>​    此外，F1C100S在全志(生产厂家)的规划中，属于sunxi生态的一部分，因此要使用sunxi-tools，这个工具在码云上也有从github转存的仓库。在克隆的时候，<strong>一定一定要注意</strong>原始仓库必须是<a href="https://github.com/Icenowy/sunxi-tools.git%EF%BC%8C%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E6%89%8D%E6%9C%89**f1c100s-spiflash%E5%88%86%E6%94%AF**%EF%BC%8C%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E7%9A%84sunxi-fel%E5%B7%A5%E5%85%B7%E6%89%8D%E8%83%BD%E5%B0%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5SPI">https://github.com/Icenowy/sunxi-tools.git，只有这个仓库才有**f1c100s-spiflash分支**，只有这个分支编译生成的sunxi-fel工具才能将可执行文件写入SPI</a> Flash中。码云转存的仓库为<a href="https://gitee.com/dbc0301/sunxi-tools">https://gitee.com/dbc0301/sunxi-tools</a></p><img src="/posts/undefined/455ca7aa25d317de416cb02508f6a291d2cae35f.jpg@1192w.webp" class="" title="img"><p>一定一定要有红圈中的这个分支</p><p>​    <strong>一定，一定要有红圈中的这个分支！！！</strong></p><p>​    因为是裸机开发，所以交叉工具链可以用前面文章中说到的arm-none-eabi-gcc工具链</p><p>【折腾是最大的乐趣】【gcc-arm】gcc-arm工具链的使用</p><p> 不过是个渣渣 · 1297阅读</p><img src="/posts/undefined/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    受限于sunxi-tools的f1s100s-spiflash分支只能在Linux下使用，所以开发环境基于Linux搭建，在这里我使用VMWare创建了一个Manjaro虚拟机。</p><img src="/posts/undefined/9c7848e8800680f17118da1d21ed201774cec7a4.jpg@1192w.webp" class="" title="img"><p>Manjaro的虚拟机环境进行裸机开发</p><p>​    用Manjaro的原因是我觉得它的UI做的比较好，而且自带gcc、git、make，实际上用比较大众Ubuntu也是差不多的，都是软件的执行环境而已。</p><p>​    装好虚拟机之后(包括切换国内源、更新系统、安装中文输入法)，去应用商店装个Code-OSS，其实就是Vscode改了个名字。</p><p>​    接下来，安装arm-none-eabi-gcc工具链，命令为：</p><p>​    sudo pacman -S arm-none-eabi-gcc</p><p>​    在终端中键入arm-none-eabi-gcc，如果提示没有输入文件，就表示安装成功了。</p><img src="/posts/undefined/a2478034821369e12ef423c3d5b561f8c1f42587.jpg@928w_352h.webp" class="" title="img"><p>测试交叉工具链</p><p>​    之后，依次克隆前面讲到的四个仓库到桌面(或者其他熟悉的位置)，命令为</p><p>​    sudo git clone <a href="https://gitee.com/mirrors/business-card-linux">https://gitee.com/mirrors/business-card-linux</a></p><p>​    sudo git clone <a href="https://gitee.com/LicheePiNano/F1C100S_MDK">https://gitee.com/LicheePiNano/F1C100S_MDK</a></p><p>​    sudo git clone <a href="https://gitee.com/scotthsl/u-boot-licheepi">https://gitee.com/scotthsl/u-boot-licheepi</a> -b nano-v2018.01</p><p>​    sudo git clone <a href="https://gitee.com/dbc0301/sunxi-tools">https://gitee.com/dbc0301/sunxi-tools</a> -b f1c100s-spiflash</p><p>​     这些仓库除了第二个的许可证为unlicensed之外，其他全部为GPL家族许可证，所有文件都可以随意使用。</p><p>​    在克隆sunxi-tools仓库时，需要用-b指定了克隆之后签出的分支。如果忘了加这个参数，克隆完成之后需要执行sudo git checkout f1c100s-spiflash签出f1c100s-spiflash分支。u-boot仓库也是一样的。</p><p>​    </p><img src="/posts/undefined/8f3d3ff782055a7145fce83b85fa52bb338b2cb5.jpg@1032w_340h.webp" class="" title="img"><p>克隆好的四个仓库</p><p>​    之后，安装sunxi-tools。</p><p>​    在终端中进入sunxi-tools目录，确定当前分支为f1c100s-spiflash，之后运行make编译安装sunxi-tools中的sunxi-fel。</p><p>​    查看分支：sudo git branch -a</p><img src="/posts/undefined/2c5f5a382e1a2e40223f4df29fd2a1eb51ae74ad.jpg@868w.webp" class="" title="img"><p>当前分支是f1c100s-spiflash</p><p>​    第一行星号开头的内容就是当前分支</p><p>​    安装工具：sudo make sunxi-fel &amp;&amp; sudo make install</p><img src="/posts/undefined/4d1eeeac47b42086539f78b5019dd004dd4d8978.jpg@1192w.webp" class="" title="img"><p>​    之后会开始sunxi-fel的编译和安装，过程中可能会有警告，但着不影响工具的安装。</p><p>​    安装完成之后，在终端键入sunxi-fel，如果出现这样的一大片提示信息，说明安装正确。</p><img src="/posts/undefined/dd603052957d127be01daad6cd2494d45d190c4e.jpg@1192w.webp" class="" title="img"><p>​    这里不能加.&#x2F;来运行sunxi-fel，因为.&#x2F;sunxi-fel表示运行当前目录下的sunxi-fel工具，并不能确认sunxi-fel是否已经安装到系统中。</p><img src="/posts/undefined/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    最后，测试荔枝派Nano是否能被Manjaro虚拟机识别。</p><p>​    首先，需要让F1C100S进入FEL模式，方法是让SPIFlash的1号脚接地，然后再连接USB口。</p><img src="/posts/undefined/09b2800931c833d3d90f81d86df6602a79627761.jpg@824w_600h.webp" class="" title="img"><p>就这个引脚，接地</p><p>​    因为Manjaro是虚拟机，所要把荔枝派分配给虚拟机使用。</p><img src="/posts/undefined/1ee0833fe59b6d172d13f96270e323f987b4b90f.jpg@1192w.webp" class="" title="img"><p>把荔枝派分给虚拟机用</p><p>​    之后，随便打开一个终端，运行sudo sunxi-fel ver</p><img src="/posts/undefined/475d20e04a4fab220024b16365e0a5643ddb4f1e.jpg@1192w.webp" class="" title="img"><p>使用sunxi-fel检测F1C100S</p><p>​    如果出现了AWUSBFEX soc&#x3D;00001663(F1C100S)这样的信息，就表示sunxi-fel工具能识别到F1C100S。如果出现了错误，多试几次就行了，一般两次中至少有一次能够正确识别。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.bilibili.com/opus/484633866186215065">【荔枝派Nano】F1C100S的裸机开发环境搭建</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机开发环境搭建</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="环境搭建" scheme="https://zml3589110.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266无线下载器</title>
    <link href="https://zml3589110.github.io/posts/3480903282.html"/>
    <id>https://zml3589110.github.io/posts/3480903282.html</id>
    <published>2025-09-15T13:10:20.000Z</published>
    <updated>2025-09-15T13:10:51.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无线调试器本体"><a href="#无线调试器本体" class="headerlink" title="无线调试器本体"></a>无线调试器本体</h3><img src="/posts/undefined/1928719-20230811204815791-1954538293.png" class="" title="img"><img src="/posts/undefined/1928719-20230819143927241-1099753248.jpg" class="" title="img"><h3 id="SWD有源延长线"><a href="#SWD有源延长线" class="headerlink" title="SWD有源延长线"></a>SWD有源延长线</h3><img src="/posts/undefined/1928719-20230819102248615-1951507612.png" class="" title="image"><img src="/posts/undefined/1928719-20230819102252006-1381904011.png" class="" title="image"><img src="/posts/undefined/1928719-20231003103428942-813334790.jpg" class="" title="image"><img src="/posts/undefined/1928719-20231003103432321-26787789.jpg" class="" title="image"><h3 id="DAPLINK通用协议测试"><a href="#DAPLINK通用协议测试" class="headerlink" title="DAPLINK通用协议测试"></a>DAPLINK通用协议测试</h3><p>测试固件大小: 225340字节，SWD时钟10M，使用KEIL-MDK下载。<br>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时主动延时500us。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>18.72s</td><td>11.755KB&#x2F;s</td></tr><tr><td>2</td><td>19.09s</td><td>11.527KB&#x2F;s</td></tr><tr><td>3</td><td>18.74s</td><td>11.743KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>8.06s</td><td>6.21s</td><td>4.12s</td></tr><tr><td>2</td><td>8.31s</td><td>6.30s</td><td>4.01s</td></tr></tbody></table><p>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时主动延时1ms。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>20.97s</td><td>10.494KB&#x2F;s</td></tr><tr><td>2</td><td>20.95s</td><td>10.504KB&#x2F;s</td></tr><tr><td>3</td><td>20.41s</td><td>10.782KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>9.98s</td><td>6.31s</td><td>4.20s</td></tr><tr><td>2</td><td>9.80s</td><td>6.42s</td><td>4.05s</td></tr></tbody></table><p>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时不延时，直接发起下次轮询。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>16.14s</td><td>13.634KB&#x2F;s</td></tr><tr><td>2</td><td>17.74s</td><td>12.405KB&#x2F;s</td></tr><tr><td>3</td><td>16.06</td><td>13.702KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>6.10s</td><td>6.18 s</td><td>4.03s</td></tr><tr><td>2</td><td>6.0s</td><td>6.08s</td><td>3.98s</td></tr></tbody></table><h3 id="ESPLINK私有协议测试"><a href="#ESPLINK私有协议测试" class="headerlink" title="ESPLINK私有协议测试"></a>ESPLINK私有协议测试</h3><h4 id="程序加载到SRAM"><a href="#程序加载到SRAM" class="headerlink" title="程序加载到SRAM"></a>程序加载到SRAM</h4><p>目标芯片<code>GD32F303RCT6</code><br>当前主频120MHz，Cortex-M4F, RAM&#x3D;48KB, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>。</p><p>测试固件大小: 46984字节，使用ESPLink-GUI客户端下载。<br>GD32F303RC的SRAM为48KB，需要留2KB给栈空间和全局变量，代码段最大能填充46KB。</p><img src="/posts/undefined/1928719-20231112140519096-182471829.png" class="" title="image"><p><code>Program Size: Code=1068 RO-data=45908 RW-data=8 ZI-data=1024</code></p><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>46984Byte</td><td>172ms</td><td>266.760KB&#x2F;s</td><td>187ms</td><td>245.362KB&#x2F;s</td></tr><tr><td>2</td><td>46984Byte</td><td>172ms</td><td>266.760KB&#x2F;s</td><td>172ms</td><td>266.760KB&#x2F;s</td></tr><tr><td>3</td><td>46984Byte</td><td>188ms</td><td>244.057KB&#x2F;s</td><td>172ms</td><td>266.760KB&#x2F;s</td></tr></tbody></table><img src="/posts/undefined/1928719-20240724214751223-1047859686.png" class="" title="image"><p>目标芯片<code>GD32F407VET6</code><br>当前主频240MHz，Cortex-M4F, RAM&#x3D;128KB+64K-TCM, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>，由于64KB的TCM内存只能由M4F内核访问，调试器只能访问挂在AHB总线上的128KB SRAM。</p><p>测试文件大小: 131072字节，使用MineLink-GUI客户端下载。</p><img src="/posts/undefined/1928719-20240525134934149-1700672102.png" class="" title="image"><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>131072Byte</td><td>562ms</td><td>233.2242KB&#x2F;s</td><td>578ms</td><td>226.7682KB&#x2F;s</td></tr><tr><td>2</td><td>131072Byte</td><td>578ms</td><td>226.7682KB&#x2F;s</td><td>641ms</td><td>204.4805KB&#x2F;s</td></tr><tr><td>3</td><td>131072Byte</td><td>546ms</td><td>240.0586KB&#x2F;s</td><td>594ms</td><td>220.6599KB&#x2F;s</td></tr></tbody></table><img src="/posts/undefined/1928719-20240525135148213-1467896714.png" class="" title="image"><p>目标芯片<code>PY32F002AW15U</code><br>当前主频8MHz，Cortex-M0+, RAM&#x3D;3KB, tar_size&#x3D;1024Byte，SWD时钟<code>5M</code>。</p><p>测试固件大小: 2020字节，使用ESPLink-GUI客户端下载。<br>PY32F002A的SRAM为3KB，需要留1KB给栈空间和全局变量，代码段最大能填充2KB。</p><img src="/posts/undefined/1928719-20231112144605399-1411535319.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;984 RO-data&#x3D;1032 RW-data&#x3D;4 ZI-data&#x3D;516</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>2020Byte</td><td>12ms</td><td>164.388KB&#x2F;s</td><td>15ms</td><td>131.510KB&#x2F;s</td></tr><tr><td>2</td><td>2020Byte</td><td>15ms</td><td>131.510KB&#x2F;s</td><td>15ms</td><td>131.510KB&#x2F;s</td></tr><tr><td>3</td><td>2020Byte</td><td>16ms</td><td>123.291KB&#x2F;s</td><td>16ms</td><td>123.291KB&#x2F;s</td></tr></tbody></table><img src="/posts/undefined/1928719-20231210151237487-1899550147.png" class="" title="image"><h4 id="程序烧录到FLASH"><a href="#程序烧录到FLASH" class="headerlink" title="程序烧录到FLASH"></a>程序烧录到FLASH</h4><p>目标芯片<code>GD32F303RCT6</code><br>当前主频120MHz，Cortex-M4F, RAM&#x3D;48KB, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>。</p><p>测试固件大小: 244872字节，使用ESPLink-GUI客户端下载。</p><img src="/posts/undefined/1928719-20231210143706734-1340416645.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;1068 RO-data&#x3D;243796 RW-data&#x3D;8 ZI-data&#x3D;1024</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>扇区擦除(ms)</th><th>编程(ms)</th><th>校验(ms)</th><th>编程速度(KB&#x2F;s)</th><th>整体速度(KB&#x2F;s)</th></tr></thead><tbody><tr><td>1</td><td>3120</td><td>3875</td><td>275</td><td>61.71</td><td>32.89</td></tr><tr><td>2</td><td>3140</td><td>3906</td><td>275</td><td>61.22</td><td>32.66</td></tr><tr><td>3</td><td>3165</td><td>3891</td><td>275</td><td>61.45</td><td>32.61</td></tr></tbody></table><img src="/posts/undefined/1928719-20231210151654571-1719365168.png" class="" title="image"><p>目标芯片<code>PY32F002AW15U</code><br>当前主频8MHz，Cortex-M0+, RAM&#x3D;3KB, tar_size&#x3D;1024Byte，SWD时钟<code>5M</code>。</p><p>测试固件大小: 19372字节，使用ESPLink-GUI客户端下载。</p><img src="/posts/undefined/1928719-20231210150346444-1573192374.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;984 RO-data&#x3D;18384 RW-data&#x3D;4 ZI-data&#x3D;516</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>扇区擦除(ms)</th><th>编程(ms)</th><th>校验(ms)</th><th>编程速度(KB&#x2F;s)</th><th>整体速度(KB&#x2F;s)</th></tr></thead><tbody><tr><td>1</td><td>20</td><td>390</td><td>50</td><td>48.51</td><td>41.12</td></tr><tr><td>2</td><td>20</td><td>407</td><td>50</td><td>46.81</td><td>39.66</td></tr><tr><td>2</td><td>20</td><td>406</td><td>50</td><td>46.59</td><td>39.73</td></tr></tbody></table><img src="/posts/undefined/1928719-20231210151218334-902428463.png" class="" title="image"><p>上位机：进行中…</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/17459214.html">ESP8266无线下载器</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP8266无线下载器</summary>
    
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/categories/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/categories/SWD/"/>
    
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/tags/ESP8266/"/>
    
    <category term="STM32" scheme="https://zml3589110.github.io/tags/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/tags/SWD/"/>
    
    <category term="KEIL" scheme="https://zml3589110.github.io/tags/KEIL/"/>
    
    <category term="下载器" scheme="https://zml3589110.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
    <category term="烧录器" scheme="https://zml3589110.github.io/tags/%E7%83%A7%E5%BD%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>读写SD卡</title>
    <link href="https://zml3589110.github.io/posts/2510049814.html"/>
    <id>https://zml3589110.github.io/posts/2510049814.html</id>
    <published>2025-09-15T13:08:20.000Z</published>
    <updated>2025-09-15T13:13:46.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GD32F303"><a href="#GD32F303" class="headerlink" title="GD32F303"></a>GD32F303</h1><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>原版示例代码位于<code>\GD32F30x_Firmware_Library_V2.2.0\Examples\SDIO</code>，对SD卡读写，卡信息获取，切换高速模式等基本功能已经实现了，但是默认实现的传输方式为CPU轮询读写FIFO，速度偏慢；卡上电初始化部分指令未考虑到一些大容量卡首次上电忙时间过长的问题，这里将在原版代码基础上进一步完善。<br>新增内容如下：</p><ul><li>写单块CMD24，写多块CMD25，读单块CMD17，读多块CMD18支持DMA传输</li><li>使用CMSIS-RTOS2的信号量做DMA同步控制</li><li>60MHz的时钟速度(超出控制器支持的48MHz，连续调用写单块(CMD24)时不太稳定)</li><li>在一些操作指令之间增加延时，适配一些山寨TF卡</li></ul><p>代码下载：<br><a href="https://files.cnblogs.com/files/blogs/575121/gd32f30x_sdio.zip">https://files.cnblogs.com/files/blogs/575121/gd32f30x_sdio.zip</a></p><h3 id="SDIO硬件电路"><a href="#SDIO硬件电路" class="headerlink" title="SDIO硬件电路"></a>SDIO硬件电路</h3><p>GD32F303的SDIO功能只有1组管脚可以使用，具体分配如下：</p><table><thead><tr><th>SDIO定义</th><th>GPIO编号</th><th>PIN位置</th><th>备注</th></tr></thead><tbody><tr><td>SDIO_DAT0</td><td>PC8</td><td>39</td><td>数据0, 上拉10K</td></tr><tr><td>SDIO_DAT1</td><td>PC9</td><td>40</td><td>数据1, 上拉10K</td></tr><tr><td>SDIO_DAT2</td><td>PC10</td><td>51</td><td>数据2, 上拉10K</td></tr><tr><td>SDIO_DAT3</td><td>PC11</td><td>52</td><td>数据3, 上拉10K</td></tr><tr><td>SDIO_CLK</td><td>PC12</td><td>53</td><td>时钟, 上拉10K</td></tr><tr><td>SDIO_CMD</td><td>PD2</td><td>54</td><td>命令&#x2F;响应, 上拉10K</td></tr></tbody></table><p>SDIO的DMA通道为DMA1 Channel3。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li>如果要测试60MHz时钟，在<code>sd_init()</code>中建议开启IO补偿单元。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> timeout = <span class="number">0xffff</span>u;</span><br><span class="line"><span class="comment">// enable the I/O compensation cell for 60Mbps IO speed</span></span><br><span class="line">gpio_compensation_config(GPIO_COMPENSATION_ENABLE);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">reg = AFIO_CPSCTL;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;<span class="keyword">while</span>(!(reg &amp; AFIO_CPSCTL_CPS_RDY) &amp;&amp; timeout);</span><br><span class="line"><span class="keyword">if</span>(timeout == <span class="number">0</span>) &#123;</span><br><span class="line">init_status = SD_ERROR;</span><br><span class="line"><span class="keyword">return</span> SD_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启用DMA传输时，需要在NVIC控制器中打开DMA的中断。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SDIO_PRIORITY             10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SDIO_DMA_PRIORITY         9</span></span><br><span class="line"></span><br><span class="line">nvic_irq_enable(SDIO_IRQn, IRQ_SDIO_PRIORITY, <span class="number">0</span>);</span><br><span class="line">nvic_irq_enable(DMA1_Channel3_Channel4_IRQn, IRQ_SDIO_DMA_PRIORITY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>ACMD指令添加重试<br>在<code>sd_power_on()</code>阶段，发送完CMD0(GO_IDLE_STATE)，CMD8(SEND_IF_COND)后切换到CMD55(APP_CMD)时，部分大容量SD卡还处于忙碌状态，导致CMD55的请求未及时回复，SDIO控制器认为返回响应超时(SD_CMD_RESP_TIMEOUT)。这里需要添加重试机制，经过测试大部分卡在1ms的重试间隔下，只需要重试一次即可继续发送ACMD41(SD_SEND_OP_COND)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2025-04-01: add ACMD retry for SANDISK 32G Card</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/* send CMD55(APP_CMD) to indicate next command is application specific command */</span></span><br><span class="line">sdio_command_response_config(SD_CMD_APP_CMD, (<span class="keyword">uint32_t</span>)<span class="number">0x0</span>, SDIO_RESPONSETYPE_SHORT);</span><br><span class="line">sdio_wait_type_set(SDIO_WAITTYPE_NO);</span><br><span class="line">sdio_csm_enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check if some error occurs */</span></span><br><span class="line">status = r1_error_check(SD_CMD_APP_CMD);</span><br><span class="line"><span class="keyword">if</span>(SD_OK == status) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">osDelay(<span class="number">1</span>); retry++;</span><br><span class="line">&#125;<span class="keyword">while</span>(retry &lt; <span class="number">10</span>); <span class="comment">// 10ms is enough, maybe...</span></span><br></pre></td></tr></table></figure><ul><li>新增<code>sd_switch_mode()</code>切换高速模式<br>按以下序列发送命令参数，先查询是否支持高速模式，不支持则返回<code>SD_FUNCTION_UNSUPPORTED</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_array[] = &#123;<span class="number">0x00FFFFF0</span>u, <span class="number">0x80FFFFF0</span>u&#125;;</span><br></pre></td></tr></table></figure><ul><li>修改<code>sd_bus_mode_config()</code>添加参数配置时钟速度</li><li>修改<code>sd_block_read()</code>函数中，readaddr由调用者控制类型，标准容量 SD 存储卡数据地址以字节为单位，高容量 SD 存储卡数据地址以块（512 字节）为单位。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sd_error_enum <span class="title">sd_block_read</span><span class="params">(<span class="keyword">uint32_t</span> *preadbuffer, <span class="keyword">uint32_t</span> readaddr, <span class="keyword">uint16_t</span> blocksize)</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">/* blocksize is fixed in 512B for SDHC card */</span></span><br><span class="line">    <span class="keyword">if</span>(SDIO_HIGH_CAPACITY_SD_CARD == cardtype)&#123;</span><br><span class="line">        blocksize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// readaddr /= 512;</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写多数据块(CMD25)前添加<code>SD_R1_READY_FOR_DATA</code>的状态位查询</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sd_error_enum <span class="title">sd_multiblocks_write</span><span class="params">(<span class="keyword">uint32_t</span> *pwritebuffer, <span class="keyword">uint32_t</span> writeaddr, <span class="keyword">uint16_t</span> blocksize, <span class="keyword">uint32_t</span> blocksnumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">response = sdio_response_get(SDIO_RESPONSE0);</span><br><span class="line">timeout = SDIO_PULL_TIMEOUT;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">0</span> == (response &amp; SD_R1_READY_FOR_DATA)) &amp;&amp; (timeout &gt; <span class="number">0</span>))&#123;</span><br><span class="line"><span class="comment">/* continue to send CMD13 to polling the state of card until buffer empty or timeout */</span></span><br><span class="line">--timeout;</span><br><span class="line"><span class="comment">/* send CMD13(SEND_STATUS), addressed card sends its status registers */</span></span><br><span class="line">sdio_command_response_config(SD_CMD_SEND_STATUS, (<span class="keyword">uint32_t</span>)sd_rca &lt;&lt; SD_RCA_SHIFT, SDIO_RESPONSETYPE_SHORT);</span><br><span class="line">sdio_wait_type_set(SDIO_WAITTYPE_NO);</span><br><span class="line">sdio_csm_enable();</span><br><span class="line"><span class="comment">/* check if some error occurs */</span></span><br><span class="line">status = r1_error_check(SD_CMD_SEND_STATUS);</span><br><span class="line"><span class="keyword">if</span>(SD_OK != status)&#123;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">response = sdio_response_get(SDIO_RESPONSE0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == timeout)&#123;</span><br><span class="line"><span class="keyword">return</span> SD_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新增DMA中断处理<br>在调用sd_block_read，sd_multiblocks_read，sd_block_write，sd_multiblocks_write时，调用者线程会因为等待信号量而进入阻塞状态，在DMA完成中断中释放信号量，使调用者线程获得继续向下执行的机会。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA1_Channel3_4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flag = DMA_INTF(DMA1);</span><br><span class="line">    <span class="keyword">if</span>(flag &amp; DMA_FLAG_ADD(DMA_INT_FLAG_FTF, DMA_CH3)) &#123;</span><br><span class="line">        dma_interrupt_flag_clear(DMA1, DMA_CH3, DMA_INT_FLAG_FTF);</span><br><span class="line">        <span class="keyword">if</span>(transerror == SD_OK) &#123;</span><br><span class="line">            osSemaphoreRelease(sem_sdio);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在SDIO中断中，当传输出错时也需要释放信号量。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDIO_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update the &#x27;transerror&#x27; variable</span></span><br><span class="line">    sd_interrupts_process();</span><br><span class="line">    <span class="keyword">if</span>(transerror != SD_OK) &#123;</span><br><span class="line">        osSemaphoreRelease(sem_sdio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>挂载SD卡：实例中使用了FileX文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> FX_MEDIA sdio_media;</span><br><span class="line">static rt_align(4) uint8_t filex_cache[FX_MAX_SECTOR_CACHE * 512];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> sd_card_info_struct sd_cardinfo;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> cardstate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> buswidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> busspeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return -1: card not exist</span></span><br><span class="line"><span class="comment"> *         -2: select card or get status fail</span></span><br><span class="line"><span class="comment"> *         -3: card locked</span></span><br><span class="line"><span class="comment"> *         -4: formated fail</span></span><br><span class="line"><span class="comment"> *         -5: open fail</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mount_filesystem</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    sd_error_enum status = SD_OK;</span><br><span class="line">    <span class="keyword">uint32_t</span> fxstatus;</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count;</span><br><span class="line"></span><br><span class="line">    status = sd_init();</span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status)&#123;</span><br><span class="line">        sd_card_information_get(&amp;sd_cardinfo);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        sd_deinit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = sd_card_select_deselect(sd_cardinfo.card_rca);</span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status)&#123;</span><br><span class="line">        status = sd_cardstatus_get(&amp;cardstate);</span><br><span class="line">        <span class="keyword">if</span>(cardstate &amp; SD_CARDSTATE_LOCKED)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status) &#123;</span><br><span class="line">        buswidth = <span class="number">1</span>;</span><br><span class="line">        busspeed = <span class="number">24</span>;</span><br><span class="line">        status = sd_switch_mode(SD_SPEED_MODE_HS);</span><br><span class="line">        <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">            status = sd_bus_mode_config(SD_BUSWIDTH_4BIT, SD_CLK_DIV_40MHZ);</span><br><span class="line">            <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">                buswidth = <span class="number">4</span>;</span><br><span class="line">                busspeed = <span class="number">40</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            status = sd_bus_mode_config(SD_BUSWIDTH_4BIT, SD_CLK_DIV_24MHZ);</span><br><span class="line">            <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">                buswidth = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fx_system_initialize();</span><br><span class="line">        block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>) * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        fxstatus = fx_media_open(&amp;sdio_media, <span class="literal">NULL</span>, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache));</span><br><span class="line">        <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;error1:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">            fxstatus = fx_media_format(&amp;sdio_media, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache),</span><br><span class="line">                    <span class="string">&quot;FILEX&quot;</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">0</span>, block_count, <span class="number">512</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 16KB/cluster</span></span><br><span class="line">            <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;error2:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-4</span>; <span class="comment">// formated fail</span></span><br><span class="line">            &#125;</span><br><span class="line">            fxstatus = fx_media_open(&amp;sdio_media, <span class="literal">NULL</span>, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache));</span><br><span class="line">            <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;error3:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-5</span>; <span class="comment">// open fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化卡：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cardformat</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sd_isinit() != SD_OK) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Card NOT INIT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;waiting...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>) * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> fxstatus = fx_media_format(&amp;sdio_media, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache),</span><br><span class="line">                    <span class="string">&quot;FILEX&quot;</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">0</span>, block_count, <span class="number">512</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 16KB/cluster</span></span><br><span class="line">    rt_kprintf(<span class="string">&quot;format result:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">&#125;</span><br><span class="line">MSH_CMD_EXPORT(cardformat, format tfcard);</span><br></pre></td></tr></table></figure><p>输出SD卡信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cardinfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> sd_spec, sd_spec3, sd_spec4, sd_security;</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count, block_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> temp_ccc;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">8</span>];</span><br><span class="line">    sd_cid_struct *cid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sd_isinit() != SD_OK) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Card NOT INIT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Card Information\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cid = &amp;(sd_cardinfo.card_cid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Manufacturer ID: 0x%02x\n&quot;</span>, cid-&gt;mid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;OEM/Application ID: 0x%02x\n&quot;</span>, cid-&gt;oid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">    rt_memcpy(name, (<span class="keyword">void</span> *)&amp;(cid-&gt;pnm0), <span class="number">4</span>);</span><br><span class="line">    rt_memcpy(name + <span class="number">4</span>, (<span class="keyword">void</span> *)&amp;(cid-&gt;pnm1), <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((name[i]&gt;=<span class="number">0x20</span>) &amp;&amp; (name[i]&lt;<span class="number">0x7F</span>)) &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;%c&quot;</span>, name[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Revision: 0x%02x\n&quot;</span>, cid-&gt;prv);</span><br><span class="line">    rt_memcpy(name, (<span class="keyword">void</span> *)&amp;(cid-&gt;psn), <span class="number">4</span>);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Serial number: %02x%02x%02x%02x\n&quot;</span>, name[<span class="number">3</span>], name[<span class="number">2</span>],name[<span class="number">1</span>],name[<span class="number">0</span>]);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Manufacturing date: 0x%x\n&quot;</span>, cid-&gt;mdt);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Version: &quot;</span>);</span><br><span class="line">    sd_spec = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x0F000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    sd_spec3 = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00008000</span>) &gt;&gt; <span class="number">15</span>;</span><br><span class="line">    sd_spec4 = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00000400</span>) &gt;&gt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == sd_spec) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == sd_spec3) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == sd_spec4) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;4.xx\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;3.0x\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;2.00\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == sd_spec) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;1.10\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == sd_spec) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;1.0x\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Type: &quot;</span>);</span><br><span class="line">    sd_security = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00700000</span>) &gt;&gt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDSC card\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">3</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDHC card\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">4</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDXC card\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>)*<span class="number">1024</span>;</span><br><span class="line">    block_size = <span class="number">512</span>;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Device Size: %dKB\n&quot;</span>, sd_card_capacity_get());</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Block Size: %dB\n&quot;</span>, block_size);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Block Count: %d\n&quot;</span>, block_count);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Bus Width: %dBit\n&quot;</span>, buswidth);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Bus Clock: %dMHz\n&quot;</span>, busspeed);</span><br><span class="line"></span><br><span class="line">    temp_ccc = sd_cardinfo.card_csd.ccc;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Card Command Classes: %x\n&quot;</span>, temp_ccc);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Features:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd_cardinfo.card_csd.read_bl_partial)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Partial blocks for read allowed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sd_cardinfo.card_csd.write_bl_partial)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Partial blocks for write allowed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((SD_CCC_BLOCK_READ &amp; temp_ccc) &amp;&amp; (SD_CCC_BLOCK_WRITE &amp; temp_ccc))&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Block operation supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_ERASE &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Erase supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_WRITE_PROTECTION &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Write protection supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_LOCK_CARD &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Lock unlock supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_APPLICATION_SPECIFIC &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Application specific supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_IO_MODE &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;I/O mode supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_SWITCH &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Switch function supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MSH_CMD_EXPORT(cardinfo, show tfcard info);</span><br></pre></td></tr></table></figure><h3 id="卡片信息"><a href="#卡片信息" class="headerlink" title="卡片信息"></a>卡片信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Card Information</span><br><span class="line">Manufacturer ID: <span class="number">0x03</span></span><br><span class="line">OEM/Application ID: <span class="number">0x5344</span></span><br><span class="line">Name: <span class="number">23</span>DSG</span><br><span class="line">Revision: <span class="number">0x85</span></span><br><span class="line">Serial number: <span class="number">54b</span>b003e</span><br><span class="line">Manufacturing date: <span class="number">0x161</span></span><br><span class="line">Version: <span class="number">3.0</span>x</span><br><span class="line">Type: SDHC card</span><br><span class="line">Device Size: <span class="number">31166976</span>KB</span><br><span class="line">Block Size: <span class="number">512B</span></span><br><span class="line">Block Count: <span class="number">62333952</span></span><br><span class="line">Bus Width: <span class="number">4B</span>it</span><br><span class="line">Bus Clock: <span class="number">40</span>MHz</span><br><span class="line">Card Command Classes: <span class="number">5b</span>5</span><br><span class="line">Features:</span><br><span class="line">Block operation supported</span><br><span class="line">Erase supported</span><br><span class="line">Lock unlock supported</span><br><span class="line">Application specific supported</span><br><span class="line">Switch function supported</span><br></pre></td></tr></table></figure><h3 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h3><p>CMD25连续写20KB</p><table><thead><tr><th>时钟</th><th>Ticks</th><th>速度</th><th>卡类型</th><th>备注</th></tr></thead><tbody><tr><td>40M</td><td>525543</td><td>4.4596MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>416303</td><td>5.6299MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>411787</td><td>5.7145MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>408590</td><td>5.7592MB&#x2F;s</td><td>SANDISK-32G</td><td>no print log</td></tr><tr><td>60M</td><td>409943</td><td>5.7172MB&#x2F;s</td><td>SANDISK-32G</td><td>no print log</td></tr></tbody></table><p>CMD18连续读20KB</p><table><thead><tr><th>时钟</th><th>Ticks</th><th>速度</th><th>卡类型</th></tr></thead><tbody><tr><td>40M</td><td>188076</td><td>12.4617MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>127804</td><td>18.3387MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60M</td><td>147390</td><td>15.9017MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>146691</td><td>15.9775MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>133362</td><td>17.5744MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr></tbody></table><p>不同时钟的CMD18连续读取</p><table><thead><tr><th>时钟</th><th>大小</th><th>Ticks</th><th>速度</th><th>卡类型</th></tr></thead><tbody><tr><td>24MHZ</td><td>4K</td><td>95183</td><td>4.9247MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>40MHZ</td><td>4K</td><td>76923</td><td>6.0939MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60MHZ</td><td>4K</td><td>69888</td><td>6.7071MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60MHZ</td><td>8K</td><td>86264</td><td>10.8678MB&#x2F;s</td><td>SANDISK-32G</td></tr></tbody></table><p>卡时钟40MHz</p><img src="/posts/undefined/1928719-20250411132800986-554948786.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/18809197">GD32F303 SDIO-DMA读写SD卡</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">GD32F303 SDIO-DMA读写SD卡</summary>
    
    
    
    <category term="SD卡" scheme="https://zml3589110.github.io/categories/SD%E5%8D%A1/"/>
    
    <category term="SDIO" scheme="https://zml3589110.github.io/categories/SDIO/"/>
    
    
    <category term="GD32" scheme="https://zml3589110.github.io/tags/GD32/"/>
    
    <category term="SD卡" scheme="https://zml3589110.github.io/tags/SD%E5%8D%A1/"/>
    
    <category term="DMA" scheme="https://zml3589110.github.io/tags/DMA/"/>
    
    <category term="SDIO" scheme="https://zml3589110.github.io/tags/SDIO/"/>
    
  </entry>
  
  <entry>
    <title>SWD接口和通信实现</title>
    <link href="https://zml3589110.github.io/posts/1214364109.html"/>
    <id>https://zml3589110.github.io/posts/1214364109.html</id>
    <published>2025-09-15T13:08:20.000Z</published>
    <updated>2025-09-15T13:09:10.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空闲态电平"><a href="#空闲态电平" class="headerlink" title="空闲态电平"></a>空闲态电平</h3><ol><li>SWD接口由SWCLK和SWDIO两根信号线组成，<code>SWCLK</code>调试器给目标芯片的时钟信号，在芯片端需要下拉；<code>SWDIO</code>双向数据信号，在芯片端需要上拉，上&#x2F;下拉电阻的取值在<code>100K</code>附近即可。<img src="/posts/undefined/1928719-20230805195424710-1520620034.png" class="" title="image">上&#x2F;下拉电阻取值来自<code>PY32</code>单片机数据手册：<img src="/posts/undefined/1928719-20230807212951926-1687425708.png" class="" title="image"></li><li>在调试器端，空闲态下：<code>SWDIO</code>可以输出高，<code>SWCLK</code>可以输出高也可以输出低（DAPLINK初始化端口默认输出高，JLINK的SWCLK和SWDIO输出都是低，JLINK和DAPLINK时序不同）。</li></ol><p>DAPLINK的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Setup SWD I/O pins: SWCLK, SWDIO, and nRESET.</span></span><br><span class="line"><span class="comment">Configures the DAP Hardware I/O pins for Serial Wire Debug (SWD) mode:</span></span><br><span class="line"><span class="comment"> - SWCLK, SWDIO, nRESET to output mode and set to default high level.</span></span><br><span class="line"><span class="comment"> - TDI, TMS, nTRST to HighZ mode (pins are unused in SWD mode).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">__STATIC_INLINE <span class="keyword">void</span> <span class="title">PORT_SWD_SETUP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Set SWCLK HIGH</span></span><br><span class="line">    pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);</span><br><span class="line">    SWCLK_TCK_PIN_PORT-&gt;BSRR = SWCLK_TCK_PIN;</span><br><span class="line">    <span class="comment">// Set SWDIO HIGH</span></span><br><span class="line">    pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);</span><br><span class="line">    SWDIO_OUT_PIN_PORT-&gt;BSRR = SWDIO_OUT_PIN;</span><br><span class="line"></span><br><span class="line">    pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Set RESET HIGH</span></span><br><span class="line">    pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);<span class="comment">//TODO - fix reset logic</span></span><br><span class="line">    nRESET_PIN_PORT-&gt;BSRR = nRESET_PIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WCH-LinkE工作在DAP模式下的电平实测：空闲态SWDIO为高电，SWCLK为低电平。</p><img src="/posts/undefined/1928719-20230807212621679-697386745.png" class="" title="image"><img src="/posts/undefined/1928719-20230807212625437-1585078791.png" class="" title="image"><p>JLINK电平实测：空闲态SWDIO和SWCLK都为低电平。</p><img src="/posts/undefined/1928719-20230807213312276-862329399.png" class="" title="image"><img src="/posts/undefined/1928719-20230807213314953-303506179.png" class="" title="image"><h3 id="接口模拟"><a href="#接口模拟" class="headerlink" title="接口模拟"></a>接口模拟</h3><ol><li>纯GPIO模拟，这也是DAPLINK的默认实现方式，只用两个IO，对于SWCLK时钟线，只需要单向输出；但是SWDIO是双向IO，那么调试器就需要对这个GPIO做输入输出切换。该方法优点是简单易实现，缺点是IO翻转频率无法做的很高，输入输出切换时有较大时间消耗。<img src="/posts/undefined/1928719-20230805201548128-805195177.png" class="" title="image"><img src="/posts/undefined/1928719-20230805201952501-1563029995.png" class="" title="image"></li><li>纯GPIO模拟，使用三个IO，对于SWCLK时钟线，只需要单向输出；对于SWDIO，使用两个IO，一个输出一个输入，中间串两个或一个电阻防止调试器的输入&#x2F;输出口灌入大电流。时钟速度仍受GPIO翻转速率限制，优点是省去了IO输入&#x2F;输出切换的时间。<br><strong>JLINK接法：</strong><br>当调试器驱动SWDIO时，信号经过MCU_OUT–&gt;R87–&gt;SWDIO传入目标芯片，同时信号也会经过R88返回到调试器，此时调试器忽略输入。<br>当目标芯片驱动SWDIO时，信号经过SWDIO–&gt;R88–&gt;MCU_IN被调试器接收，同时信号也会经过R87到达MCU_OUT，由于R87的存在，无论调试器端MCU_OUT之前状态是输出高还是低，都不会造成短路。<img src="/posts/undefined/1928719-20230805202052915-684475811.png" class="" title="image"><strong>DAPLINK接法：</strong><br>简化的版本，SWDIO直连调试器输入端，原理和上文类似。<img src="/posts/undefined/1928719-20230805202514124-762302590.png" class="" title="image">关于电阻的取值：电阻值限制了SWDIO信号线的上升&#x2F;下降速率，需要高速传输取100R左右的小电阻，代价是动态电流较大，在DAPLINK接法的100R电阻下，调试线长15CM左右，满足10M的IO翻转速率是没有问题的。<br><strong>推荐的接法：</strong><br>满足日常10~20CM的调试线使用，其中0R的电阻预留；当走线较长时，需要实测通信线上升和下降的振铃波形幅度，同时修改R87和R116。<img src="/posts/undefined/1928719-20230811202939969-717443760.png" class="" title="image"></li><li>利用SPI实现部分硬件加速，适用于常见的只支持<code>8bi</code>t或者<code>16bit</code>固定位宽的SPI外设。这种方案有一定的加速效果，但是使用起来比较麻烦。<img src="/posts/undefined/1928719-20230811202947168-161295864.png" class="" title="image"></li></ol><p>下图是调试器写目标芯片的时序为例：<br>1：调试器发送的包请求（8bits）由SPI硬件完成<br>2：转向位(1bit) + 芯片发送的应答响应（3bits）+ 转向位(1bit) 切换到GPIO模拟<br>3：调试器的数据发送阶段（32bits）由SPI硬件完成<br>4：校验位（1bit）切换到GPIO模拟</p><img src="/posts/undefined/1928719-20230805211142155-686503954.png" class="" title="image"><ol><li>完全的SPI硬件加速，硬件连线同上图。例如<code>STM32F072, STM32F303,STM32F051</code>这种最低支持<code>4bit</code>的SPI外设就可以完全模拟SWD协议各个部分的时序了。<br>调试器向目标芯片的写操作：8bit写 + 5bit读(丢掉最低位和最高位) + （16bit写 + 8bit写 + 9bit写）。<img src="/posts/undefined/1928719-20230805211703375-1225858851.png" class="" title="image">调试器向目标芯片的读操作：8bit写 + 4bit读(丢掉最低位) + （16bit读 + 8bit读 + 10bit读）。<img src="/posts/undefined/1928719-20230805211850125-880518240.png" class="" title="image"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stm32f0xx_spi.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_4b                 ((uint16_t)0x0300)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_5b                 ((uint16_t)0x0400)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_6b                 ((uint16_t)0x0500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_7b                 ((uint16_t)0x0600)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_8b                 ((uint16_t)0x0700)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_9b                 ((uint16_t)0x0800)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_10b                ((uint16_t)0x0900)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_11b                ((uint16_t)0x0A00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_12b                ((uint16_t)0x0B00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_13b                ((uint16_t)0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_14b                ((uint16_t)0x0D00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_15b                ((uint16_t)0x0E00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_16b                ((uint16_t)0x0F00)</span></span><br></pre></td></tr></table></figure><p>另一款芯片<code>ESP8266</code>的SPI使用FIFO模式操作，支持<code>1bit~512bit</code>任意读写，那么在SWD协议的WDATA段直接发起31bit的传输即可。</p><h3 id="信号时序"><a href="#信号时序" class="headerlink" title="信号时序"></a>信号时序</h3><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/17608599.html">SWD接口和通信实现</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">SWD接口和通信实现</summary>
    
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/categories/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/categories/SWD/"/>
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/tags/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/tags/SWD/"/>
    
    <category term="KEIL" scheme="https://zml3589110.github.io/tags/KEIL/"/>
    
    <category term="下载器" scheme="https://zml3589110.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
    <category term="烧录器" scheme="https://zml3589110.github.io/tags/%E7%83%A7%E5%BD%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>F1C100S-BOOTROM与SPL阶段</title>
    <link href="https://zml3589110.github.io/posts/1056682153.html"/>
    <id>https://zml3589110.github.io/posts/1056682153.html</id>
    <published>2025-09-15T13:02:20.000Z</published>
    <updated>2025-09-15T13:03:48.726Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BootROM支持的引导介质"><a href="#BootROM支持的引导介质" class="headerlink" title="BootROM支持的引导介质"></a>BootROM支持的引导介质</h3><img src="/posts/undefined/1928719-20220604124014691-1561797689.png" class="" title="img"><h4 id="默认的启动优先级"><a href="#默认的启动优先级" class="headerlink" title="默认的启动优先级"></a>默认的启动优先级</h4><p>目前没有找到修改启动顺序的方式</p><table><thead><tr><th>序号</th><th>启动介质</th><th>注意事项</th></tr></thead><tbody><tr><td>1st</td><td>MicroSD Card&#x2F;eMMC</td><td>只支持PF0 ~ PF5这六个脚复用为SDC0启动, 控制器支持到SD2.0和eMMC4.41，设备端可以使用主流的eMMC5.1(eMMC存储器可以向前兼容)</td></tr><tr><td>2nd</td><td>SPI Nor&#x2F;Nand Flash</td><td>只支持PC0 ~ PC3这四个脚复用为SPI0启动, 支持标准SPI和DOUT模式, BROM启动时SPI Nand固定为1024字节&#x2F;页，SPI Nor无特殊限制</td></tr><tr><td>3rd</td><td>BROM FEL Mode</td><td>以上介质都无启动代码时，自动运行芯片内部USB程序(FEL Mode)(USB Full-Speed@12Mbps)，USB脚是固定的无其它复用功能</td></tr></tbody></table><p>F1C100S手册未提及芯片启动顺序，但可以参考全志V3S的手册，F1C100S没有强制进入烧写模式的专用引脚，可以将<code>SDC0_CMD</code>或<code>SPI0_CS/SPI0_DOUT</code>强制接地干扰已经固化在eMMC&#x2F;Nor-Flash中的SPL启动，让芯片进入USB-FEL下载模式。</p><img src="/posts/undefined/1928719-20220724134750238-317317628.png" class="" title="img"><p>下图的SDC1_CMD实际上作为SPI0_DOUT功能</p><img src="/posts/undefined/1928719-20220724150444768-1249396344.png" class="" title="img"><h4 id="SDC0启动"><a href="#SDC0启动" class="headerlink" title="SDC0启动"></a>SDC0启动</h4><p>硬件连线使用以下引脚，BootROM读取eMMC或SDCard中的SPL程序时，只使用了1bit-sdio，且最大速度限制在25MHz，因此正常启动最少需要接CMD、CLK、D0这三根线；<br>但eMMC或SDCard在启动完成后还可作为应用程序的存储器，为了提升传输速度建议<code>CMD、CLK D0~D3</code>这6根线都接上，F1C100S的SDIO控制器最大支持SDR-4bit@50MHz。</p><img src="/posts/undefined/1928719-20220604124248950-877387359.png" class="" title="img"><p>通过逻辑分析仪抓取BootROM读取eMMC中的SPL程序的过程，可以看到只使用了1bit模式。</p><img src="/posts/undefined/1928719-20220604131404899-2040727626.png" class="" title="img"><p>SPL程序需要从eMMC UDA物理分区的第16个扇区(512字节&#x2F;扇区)开始烧录，下图是eMMC UDA物理分区内的布局图：<br><code>前8KB(扇区0 ~ 扇区15)</code>存放MBR分区表或者非标准的GPT分区表，<code>扇区16</code>开始存放SPL程序，BROM将从这里读取程序到SRAM并执行，<code>扇区80</code>开始可以存放用户的程序，如果是启动linux，这里可以存放uboot，如果是嵌入式系统或者裸机，这里直接存放应用程序。</p><img src="/posts/undefined/1928719-20220724152140819-205036069.png" class="" title="img"><p>对于使用GPT分区表的情况，前8KB的空闲空间只能存放56条分区信息，GPT规范要求至少留128条分区信息的空间，某些工具可能不会认可这样非标准的分区表，因此GPT分区表可以放在SPL程序后面。对于一般应用来说，MBR分区表最大支持4个分区已经可以满足需求。</p><img src="/posts/undefined/1928719-20220724152657321-1244433231.png" class="" title="img"><p>在抓取BootROM与eMMC通信中，观察到了F1C100S的BootROM会写eMMC的1号扇区<code>(待重复验证)</code>，建议前0~15扇区都空着，有分区表的话还是放在SPL程序后面。</p><img src="/posts/undefined/1928719-20220604133848505-755113197.png" class="" title="img"><h4 id="SPI0启动"><a href="#SPI0启动" class="headerlink" title="SPI0启动"></a>SPI0启动</h4><p>标准的4线SPI接口，最大速度是AHB总线时钟的2分频，AHB通常设置为200MHz，因此SPI的时钟最大为100MHz。<br>BootROM加载SPL程序时默认使用标准SPI，具体时钟速度忘记了，大概10MHz以内，这段启动时间是无法优化的。<br>SPL启动后，加载用户程序时，推荐使用DOUT模式，用带宽换时钟，降低SPI布线要求，100MHz的SPI读写Flash实测不是很稳定。</p><img src="/posts/undefined/1928719-20220604140519975-852271578.png" class="" title="img"><p>nor-flash和nand-flash需要从物理0地址<code>(0号扇区0地址)</code>开始烧录SPL程序。</p><img src="/posts/undefined/1928719-20220724154906422-1940832619.png" class="" title="img"><p>spi nor-flash直接使用sunxi-fel工具烧录。</p><img src="/posts/undefined/1928719-20220724155111676-1896318578.png" class="" title="img"><p>spi nand-flash有一个改版的sunxi-fel工具可用，目前大部分的spi nand-flash都是4K&#x2F;扇区的，烧录的时候每扇区只使用前1K，剩下的空着(spi nand启动还未测试过)。</p><h4 id="USB启动"><a href="#USB启动" class="headerlink" title="USB启动"></a>USB启动</h4><p>当SDC0，SPI0都没有读取到SPL程序时，自动运行芯片固化的USB程序(FEL)，此时可以通过该程序提供的API，通过USB对芯片下载程序或执行ARM汇编代码。</p><img src="/posts/undefined/1928719-20220606195458253-1956918537.png" class="" title="img"><p>在usb-fel模式下，usb接口默认是全速的(12Mbps)，F1C100S的usb也支持高速模式(480Mbps)，因此在USB端口的ESD二极管等效电容尽可能小，推荐使用5pF左右的。<br>windows下需要使用<code>zadig</code>安装winusb(libusb)驱动，然后才能使用<code>sunxi-fel</code>工具进行nor-flash烧录，发送程序到DRAM执行等。</p><img src="/posts/undefined/1928719-20220618120305897-113075659.png" class="" title="img"><h3 id="BOOTROM到SPL"><a href="#BOOTROM到SPL" class="headerlink" title="BOOTROM到SPL"></a>BOOTROM到SPL</h3><p>以下是全志F1C100S参考手册的内存映射表：</p><img src="/posts/undefined/1928719-20220730210223879-2026439209.png" class="" title="img"><p>以下是全志V3S参考手册的内存映射表：</p><img src="/posts/undefined/1928719-20220730210340665-420809545.png" class="" title="img"><p>先说结论：<br>关于BROM地址和SRAM地址，全志F1C100S手册描述有误，全志V3S手册描述部分适用于F1C100S，下面进行验证。</p><p>在没有片外启动介质的情况下，给F1C100S通电，按照F1C100S手册上描述，BROM在<code>0x0 ~ 0x7FFF</code>，这里直接从0地址开始，先读出64K内容查看：</p><img src="/posts/undefined/1928719-20220731110957701-2088918446.png" class="" title="img"><p>从提取出的内容来看，并不是正常的可执行文件内容，因此可以断定，BROM并不在0x0地址起始处。</p><img src="/posts/undefined/1928719-20220731111044371-1515494593.png" class="" title="img"><p>使用<code>r</code>命令复位CPU，并使用<code>halt</code>命令暂停CPU，可以看到CPU处于SVC模式，且不响应外部中断，PC是<code>0</code>，表示将从0地址取指。<br><code>PC: (R15) = 00000000, CPSR = 000000D3 (SVC mode, ARM FIQ dis. IRQ dis.)</code></p><img src="/posts/undefined/1928719-20220730210714072-2093952861.png" class="" title="img"><p>那再次查看下<code>0x00000000</code>地址上的内容吧：<br>可以看到和上文一样是<code>FF FF FF FF</code>，由于ARM内核无法区分读到的内容是指令还是数据，读到的东西全部当成指令进行解析，那么全FF肯定不是正常的ARM指令，处理器执行到这里将会进入<code>未定义指令异常</code>。</p><img src="/posts/undefined/1928719-20220730211156444-547181485.png" class="" title="img"><p>试着单步运行一下，果然出现了未定义指令异常，且PC指向了<code>FFFF0004</code>处，顺着PC值就找到了默认异常向量表的位置。<br><code>PC: (R15) = FFFF0004, CPSR = 000000DB (UNDEF mode, ARM FIQ dis. IRQ dis.)</code></p><img src="/posts/undefined/1928719-20220730211415427-1305513944.png" class="" title="img"><p>因为未定义指令异常排在异常表的第二位，所以当前PC值是<code>FFFF0004</code>，那么异常向量表起始位置就是<code>0xFFFF0000</code></p><img src="/posts/undefined/1928719-20220730214105941-395350637.jpg" class="" title="img"><p>通常ARM9异常向量表默认地址可以设置成两种：<code>0x0</code>和<code>0xFFFF0000</code>，可以通过访问CP15协处理器的C1寄存器来设置或者读取</p><img src="/posts/undefined/1928719-20220730212411136-140083481.png" class="" title="img"><p>继续进行单步操作，发现进入死循环：</p><img src="/posts/undefined/1928719-20220730225617190-485450976.png" class="" title="img"><p>将<code>0xFFFF0000</code>处的异常向量表读出，发现其他7个异常都指向了<code>while(1)</code></p><img src="/posts/undefined/1928719-20220730230717230-1415300732.png" class="" title="img"><p>那么可以判断出，F1C100S上电后并不是通过0地址的指令异常向量跳转到BROM处的，BROM应该在其他地方。</p><p>对芯片拉低复位信号，复位CPU，但调试器不做任何操作，这样CPU可正常运行；经过硬复位，芯片的BROM正常运行，sunxi-fel工具也正确识别。</p><img src="/posts/undefined/1928719-20220730231357023-934849619.png" class="" title="img"><p>此时挂上调试器，可以看到正常运行时<code>PC=0xffff012c</code>，当前运行位置在默认异常表的后面。</p><img src="/posts/undefined/1928719-20220730231434325-610336373.png" class="" title="img"><p>使用<code>r</code>命令，<code>halt</code>命令复位并暂停CPU，手动将PC设置到<code>0xFFFF0000</code>处，使用<code>s</code>单步执行几次，经过2个跳转指令，最终跳转到了<code>0xFFFF4000</code>地址处。<br>那么基本可以断定，BROM处于<code>0xFFFF4000</code>地址。</p><img src="/posts/undefined/1928719-20220801000733287-219870545.png" class="" title="img"><p>使用<code>g</code>命令全速运行：</p><img src="/posts/undefined/1928719-20220731001118831-297741523.png" class="" title="img"><p>sunxi-fel工具也正确识别出了设备，此时暂停CPU查看PC寄存器，也与正常上电运行后再暂停CPU的PC寄存器值一致:</p><img src="/posts/undefined/1928719-20220731001405882-786755736.png" class="" title="img"><img src="/posts/undefined/1928719-20220731001441359-1164060828.png" class="" title="img"><p>那么可以推断出F1C100S上电后，应该是从<code>0xFFFF4000</code>地址处启动，BROM异常向量在’0xFFFF0000’处。</p><h3 id="F1C100S实际的BROM和SRAM地址表"><a href="#F1C100S实际的BROM和SRAM地址表" class="headerlink" title="F1C100S实际的BROM和SRAM地址表"></a>F1C100S实际的BROM和SRAM地址表</h3><table><thead><tr><th>Module</th><th>Address</th><th>Size</th><th>权限</th></tr></thead><tbody><tr><td>SRAM</td><td>0x0000 - 0x9000</td><td>36KB</td><td>rwx</td></tr><tr><td>SRAM1</td><td>0xB000 - 0xB600</td><td>1.5KB</td><td>rwx</td></tr><tr><td>异常向量表</td><td>0xFFFF0000 - 0xFFFF001F</td><td>32 Bytes</td><td>rx</td></tr><tr><td>FEL模式相关程序</td><td>0xFFFF0020 - 0xFFFF25AB</td><td>9612 Bytes</td><td>rx</td></tr><tr><td>BROM</td><td>0xFFFF4000 - 0xFFFF62B7</td><td>8888 Bytes</td><td>rx</td></tr></tbody></table><p>同时也在在<code>0xFFFF4000</code>地址处发现了<code>eGON.BRM</code>文件头的固件，通过<code>BRM</code>大致可以猜出这是F1C100S的BOOTROM了，和全志二级引导的文件头<code>eGON.BT0</code>有点类似。</p><img src="/posts/undefined/1928719-20220731002818456-1888672137.png" class="" title="img"><p>&#x2F;&#x2F; 待完成…</p><p>参考文档：<br>挖坑网关于F1C100S SPI-NAND启动的讨论：<br><a href="https://whycan.com/t_1658.html">https://whycan.com/t_1658.html</a><br><a href="https://whycan.com/t_649.html">https://whycan.com/t_649.html</a><br>github开源的spi-nand调试记录：<br><a href="https://github.com/hcly/f1c100s">https://github.com/hcly/f1c100s</a><br>CSDN关于F1C100S制作SPI-NAND镜像：<br><a href="https://blog.csdn.net/hclydao/article/details/103709642">https://blog.csdn.net/hclydao/article/details/103709642</a><br>linux-sunxi关于SD卡启动，实际上也适用于eMMC：<br><a href="https://linux-sunxi.org/Bootable_SD_card">https://linux-sunxi.org/Bootable_SD_card</a><br>全志V3S手册：<br><a href="https://linux-sunxi.org/images/2/23/Allwinner_V3s_Datasheet_V1.0.pdf">https://linux-sunxi.org/images/2/23/Allwinner_V3s_Datasheet_V1.0.pdf</a><br>全志其他芯片的SPL：<br><a href="https://github.com/allwinner-zh/bootloader/tree/master/basic_loader">https://github.com/allwinner-zh/bootloader/tree/master/basic_loader</a><br>linux-sunxi community：<br><a href="https://linux-sunxi.org/Main_Page">https://linux-sunxi.org/Main_Page</a><br>F1C100S SRAM地址推测：<br><a href="https://blog.csdn.net/qq446252221/article/details/122453469">https://blog.csdn.net/qq446252221/article/details/122453469</a></p><p>其他：<br>全志F1C100S的芯片的开发代号为suniv。<br><a href="https://openwrt.org/docs/techref/hardware/soc/soc.allwinner.sunxi">https://openwrt.org/docs/techref/hardware/soc/soc.allwinner.sunxi</a><br><a href="https://linux-sunxi.org/Allwinner_SoC_Family">https://linux-sunxi.org/Allwinner_SoC_Family</a><br>f1c100s_brom_ffff0000.bin提取的<code>0xFFFF0000</code>地址处的BROM：<br>f1c100s_brom_0提取的<code>0</code>地址处的内容：<br><a href="https://files.cnblogs.com/files/yanye0xff/f1c100s_brom.zip?t=1659198022">https://files.cnblogs.com/files/yanye0xff/f1c100s_brom.zip?t=1659198022</a></p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/16341719.html">F1C100S-BOOTROM与SPL阶段</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C100S-BOOTROM与SPL阶段</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="BOOTROM" scheme="https://zml3589110.github.io/tags/BOOTROM/"/>
    
    <category term="SPL" scheme="https://zml3589110.github.io/tags/SPL/"/>
    
    <category term="启动流程" scheme="https://zml3589110.github.io/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>全志F1C200S F1C100S 介绍</title>
    <link href="https://zml3589110.github.io/posts/3233973243.html"/>
    <id>https://zml3589110.github.io/posts/3233973243.html</id>
    <published>2025-09-15T09:52:20.000Z</published>
    <updated>2025-09-15T13:16:43.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C100S基本信息"><a href="#F1C100S基本信息" class="headerlink" title="F1C100S基本信息"></a>F1C100S基本信息</h1><h3 id="芯片的启动"><a href="#芯片的启动" class="headerlink" title="芯片的启动"></a>芯片的启动</h3><p>F1C100S支持的启动方式:</p><img src="/posts/3233973243/1928719-20210822203216503-2015530485.png" class="" title="img"><p>F1C100S启动的顺序：（硬件上必须按照注意固定的引脚接线，否则芯片无法启动）</p><table><thead><tr><th>序号</th><th>启动介质</th><th>注意事项</th></tr></thead><tbody><tr><td>1st</td><td>MicroSD Card&#x2F;eMMC</td><td>只支持PF0 ~ PF5这六个脚复用为SDC0启动, 控制器支持到SD2.0和eMMC4.41，设备端可以使用eMMC5.1(向下兼容)</td></tr><tr><td>2nd</td><td>SPI Nor&#x2F;Nand Flash</td><td>只支持PC0 ~ PC3这四个脚复用为SPI0启动, 支持DOUT模式, BROM启动时SPI Nand固定为1024字节&#x2F;页，SPI Nor无特殊限制</td></tr><tr><td>3rd</td><td>BROM FEL Mode</td><td>以上介质都无法启动时，自动运行芯片内部USB程序，此时可以USB下载(USB Full-Speed@12Mbps)，USB脚是固定的无其它复用功能</td></tr></tbody></table><h4 id="SDCard0作为启动介质的引脚"><a href="#SDCard0作为启动介质的引脚" class="headerlink" title="SDCard0作为启动介质的引脚:"></a>SDCard0作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20210822203348581-576019354.png" class="" title="img"><h4 id="SPI0作为启动介质的引脚"><a href="#SPI0作为启动介质的引脚" class="headerlink" title="SPI0作为启动介质的引脚:"></a>SPI0作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20210822203250274-627738019.png" class="" title="img"><h4 id="USB作为启动介质的引脚"><a href="#USB作为启动介质的引脚" class="headerlink" title="USB作为启动介质的引脚:"></a>USB作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20211220214844546-1865095828.png" class="" title="img"><h3 id="LCD接口"><a href="#LCD接口" class="headerlink" title="LCD接口"></a>LCD接口</h3><p>GPIO D组就是全部的LCD接口了，RGB666 + HS + VS + DE + PCLK共计22Pin(不支持TE信号)，低配的RGB接口，每个通道的低2bit都没了，最大只支持26w色。（除了标准并口RGB，F1C100S也支持Serial-RGB：HS + VS + DE + PCLK + 8Data）</p><img src="/posts/3233973243/1928719-20210822204149353-2080865958.png" class="" title="img"><img src="/posts/3233973243/1928719-20210822205206562-54488490.png" class="" title="img"><p>需要注意的是GPIO E组有几个脚的复用功能是RGB缺失的几个通道，但这里的直接无视即可，接了也不会有用。</p><img src="/posts/3233973243/1928719-20220606193827172-809061396.png" class="" title="img"><p>具体原因请看LCD寄存器定义(全志的LCD控制器叫TCON)，各个颜色通道最高支持6bit(顺带一提稍微高端点的全志H6也是一样，还是只有6bitRGB接口)</p><img src="/posts/3233973243/1928719-20210822204633889-1819471126.png" class="" title="img"><h3 id="USB-OTG"><a href="#USB-OTG" class="headerlink" title="USB-OTG"></a>USB-OTG</h3><p>F1C100S内置的USB PHY(usb ip核使用的是musb，和ti-am3352, ti-am1810寄存器结构类似)使用GPIO-E2作为USB-ID线，因此使用USB主机时需要保留这个引脚。这里也可以由软件控制切换，软件方式插入U盘无法自动识别，需要用户主动切换到USB-HOST再插入U盘。<br>需要上拉到3.3V，默认做从机，做主机时由OTG线下拉到地。</p><h3 id="GPIO外部中断"><a href="#GPIO外部中断" class="headerlink" title="GPIO外部中断"></a>GPIO外部中断</h3><p>只支持GPIO-D&#x2F;E&#x2F;F组的外部中断，支持边沿和电平触发。由于GPIOD组被RGB占用，GPIOF组被SDC0占用，PE2被USB-OTG占用，因此只有GPIOE组的少部分IO可用。<br>推荐PE3&#x2F;4&#x2F;5&#x2F;9&#x2F;10，这几个引脚复用功能较少。</p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p>支持2路独立的PWM，PWM0：PE12，PWM1：PE6。使用简单的16位计数器模式控制输出，输入时钟为OSC24M，最高输出频率&#x3D;24MHz，不支持脉宽调制、采集、正交编码等特殊功能。<br>用处不大，推荐用于控制屏背光，，，</p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>很久以前发现了一颗性价比极高而且比较好玩的SOC，加群请仔细阅读本博客（见DKTool界面，请备注“来自博客”）</p><p>那就是全志F1C100S F1C200S，其中F1C100S内置32MB DDR1内存，F1C200S内置64MB DDR1内存。</p><p>这个片子能从淘宝轻松的买到，如果找靠谱的店家或者找代理商的话，F1C100S 是10块钱一片，F1C200S是13块钱一片。</p><p>从淘宝买一定要注意分辨是拆机还是库存还是正规代理货源，千万别图便宜，拆机良率可能20%；</p><p> 根据用量，找代理商价格100s是9元多，200s是13块左右。我有靠谱的代理联系方式，并可提供BSP。</p><p>这么10来块钱，32MB 和 64MB 的外扩内存都买不到啊，用来驱动RGB屏幕啥的，STM32赶紧靠边站。</p><p>其实F1C100S F1C200S F1C500S F1C600 R6都是一个芯片，他们都是QFN88封装。</p><p>资源方面，</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右，也有720M出货的。</p><p>有人说可以跑到900MHz，但我没有成功，uboot还没起来就挂了。</p><p>带有100M的SPI接口，2个SDIO接口，1个USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口。</p><p>I2C I2S UART PWM等等。</p><p>因为引脚比较少，所以复用严重，但也是有考虑的，如果IO不够用，就使用I2C扩展IO。</p><p><img src="/%E5%85%A8%E5%BF%97f1c200s%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AE%BE%E8%AE%A1/f26481d46f8a51926a9cab2683435852.png" alt="f26481d46f8a51926a9cab2683435852"></p><p>我们玩的以F1C100S和F1C200S为主。</p><p>目前能从网上找到的只有F1C200S和F1C600的寄存器手册。其实他们里面的内容都是一模一样的。</p><p>目前能找到F1C200s和F1C600的完整数据手册和寄存器手册，当然完整是相对的，基础外设的寄存器都是开放的，高级解码部分是不开放的。</p><p>关于F1C100S&#x2F;F1C200S的资料，可以从挖坑网获得，whycan.cn（资料非常零散，找出自己需要的不易）</p><p>里面真是花式玩F1C100S，下面按照系统区分来列举一下：</p><p>1.流出的全志官方C600的BSP ，linux-3.10。支持硬解码编码，但不支持TVIN。可以从github搜到源码，因为C600面向的是智能音箱，所以bsp部分并没有默认支持显示屏，需要自己趟坑修改。其他问题不知。</p><p>2.全志官方的RTOS，名叫melis 2.0。这是全志自己的小系统，支持所有外设，硬件解码编码，TVIN,TVOUT各种外设，学习难度也是很大的，开发环境也是很难，如果能玩转，出些产品还是可以的。不过一般没人去研究他哈。（坑网可以获得）</p><p>3.全志官方的linux，名叫tina。有针对F1C200S的tina版本，3.0或者3.5，内核版本是linux3.10，这个软件支持部分比较丰富，还有比较完善的指导文档。不过这个资料是需要和代理商签NDA的，也就是保密协议，个人或小公司应该是不会被理会的吧。</p><p>4.社区支持的有linux-4.15，linux5.2，linux-5.6不支持硬解解码编码。其中荔枝派用的就是这个，有很多东西也是他们维护的。另外前一阵火的运行linux的名片用的就是这个片子。</p><p>5.XBOOT，九鼎xboot大佬支持的XBOOT，xboot是可以理解为裸机程序也可以理解为一个小系统，可以用来引导linux，也可以用来直接lua开发（很多人玩裸机或rtt从这里提炼驱动），直接用xboot开发也是比较方便的，在xboot群里有人做公司产品的。</p><p>6.RT-thread，这个最开始是RTT支持荔枝派做的，后来RTT有了融资，考虑盈利，把这一部分闭源了做了柿饼pie(串口屏)，在网上还能找到之前的资料。原来RTT官方支持的现在不能找到了，不过想玩RTT的饼子们，可以从github找第三方移植的RTT，现在支持了lcd和音频，资料还是不错的。有一个领头人@staunchheart ，他想玩RTT，大家可以找他一起完善 ，他已经可以用RTT的IDE studio进行开发了呢）</p><p>7.UCOS，这是xboot群的大佬，自己移植的ucos，把TVOUT都支持了，移植了NES模拟器，并做了掌机开发板，现在淘宝有售，名字叫小淘气科技，价格也很贵哟，人家可是付出了多少个夜晚研究出来的，有需求的希望支持一下，让做技术的人生活的更开心。</p><p>8.裸机keil开发，这是坑网达克罗德大神自己写的，在坑网上有资料，还可以用jlink调试开发。</p><p>9.VFS，这是simon大佬公司维护的项目，使用IAR，在单片机上跑裸机，并可以运行linux子系统。 </p><p>10.Aodzip大佬做了uboot kernel rootfs的buildroot的支持，并且uboot支持dfu下载程序，支持spi nor启动，spi nand启动，sdio0 4bit 的TF卡，SD NAND，emmc启动；sdio1 1bit 的tf卡或emmc或sd nand的启动。并且支持dfu烧写。好像还支持硬件解码编码，有大佬可以试试。</p><p>玩F1C200S的人大部分是想用来带屏的，所以GUI是大家关心的。 列举一些大家使用的GUI。</p><p>1、周立功的AWTK（首推，打算PDA就用这个了）</p><p>2、开源的littlevgl GUI</p><p>3、Qt</p><p>4、minigui</p><p>5、RTX</p><p>总之，这款片子被大家玩起来了。我也做了个核心板。</p><p>粗略算过，不算flash，核心的BOM成本在15块钱。如果全部自己手焊的话，一块板子不到20。</p><p>这是我画的板子，做了几十个挂淘宝已经卖完了。欢迎大家一起来玩，一起交流。</p><p>现在下图中的板子已经淘汰了，我又设计了新板子呢，而且在做手持机。现在没有可卖的了。如果有想要核心板PCB的话，我可以出售立创EDA工程文件，可以在本文中找到联系群号。我自己都没有可以用的了。</p><img src="/posts/3233973243/3f290d98648cea18077fce729f0b23fb.jpeg" class="" title="img"><p>上图中最底部的两个板子就是最新的核心板，增加了LCD接口，也能接通用40PIN的显示屏了。但我没有 继续做下去，毕竟核心板并不好玩，做来卖也是赚不了几十块钱，而且很麻烦。有一款我在立创库里开源过，后来 无人问津就关闭了呢。</p><p>所以玩就玩的好， 想必各位买板子回去也是想接各种东西进行测试的，所以为什么不做一个集成的板子呢！</p><p>于是PDA开始设计。</p><img src="/posts/3233973243/808e89637f87cbd53859891e93e16e6b.png" class="" title="img"><h1 id="DKTool"><a href="#DKTool" class="headerlink" title="DKTool"></a>DKTool</h1><p>同时呢， 为了方便烧写 固件什么的方便一些，我做个了windows下的图形烧录工具（其实就是封装了一下sunxi-fel）</p><p>1、支持监测插入电脑的芯片型号，判断是F1C100S还是F1C200S，</p><p>2、支持监测spi flash的容量</p><p>3、支持烧录文件到spi flash</p><p>4、支持读取spi flash数据以文件的方式存储</p><p>5、支持烧写文件到DDR</p><p>6、支持读取DDR中数据以文件方式存储</p><p>7、支持读写指定内存地址的32bit数据（可以读写ddr，也可以用来设置寄存器啥的）</p><p>8、我觉得最好的功能还就集成了USB驱动部分，DKTool驱动就是本工具使用的驱动，</p><p>另一个则是烧录全志官方BSP固件用的工具。</p><p>（全志BSP生成的固件内包含了很多东西，比较复杂，搞不懂）</p><img src="/posts/3233973243/2802096db368dfe56fbcb5edf2e89bf4.png" class="" title="img"><img src="/posts/3233973243/69cd843646efe61a9ae0e619e1bcab63.png" class="" title="img"><p>烧写工具还有很多BUG需要完善，所以不在这发布了。可以到群里去找，最新版本0229，不再更新。以后PDA出来再做配套软件，会加上可以烧写emmc等功能。</p><p>4层板的PDA正在进行中，还制作了钢网，OK了后续再更新。</p><p>PDA的硬件第一版有些不合理，又做了第二版，就是 下面的工程版PDA。</p><p>工程PDA算是OK了，知道了一些BUG，下一版不出问题就是正式版了，</p><p>另外，RGB屏已经驱动成功，音频带喇叭也已经驱动成功，N76E003的 烧录我要改版到可以使用一个Type-C口烧录。</p><p>N76E003模拟N多个额PCF8574。</p><p>不出现什么意外，今年看看能不能做出来。</p><p>2020今年家有喜事，暂时放下了一段时间，慢慢来吧。</p><p>下面绿色的框子不太好看，正式版用的是黑色亚克力。</p><p>2020年10月：</p><p>3寸屏太小了，板子上塞不了多少东西，于是我又换了一个屏幕3.5寸的（大显家的）。</p><p>在此说一下PDA的配置</p><p>CPU:F1C100S&#x2F;F1C200S</p><p>RAM:内置32MB&#x2F;64MB</p><p>Flash:TF卡槽焊盘+SD Nand焊盘+EMMC焊盘（看情况进行焊接）</p><p>音频：麦克风+iphone6以上高音质喇叭</p><p>接口：Type-C USB2.0 slave；充电、单片机&#x2F;SOC下载程序、串口调试单片机&#x2F;SOC、调试蓝牙模块</p><pre><code>       USB2.0 母口  可以插U盘</code></pre><p>按键：美上美优质滚轮编码器（手感贼棒！！！）</p><p>屏幕：3.5寸电容触摸 480*800分辨率 IPS屏 非全贴合</p><p>摄像头：OV5640 500万像素</p><p>WiFi：ESP8266EX  工作在sdio网卡模式，实测速度1MB&#x2F;S</p><p>蓝牙：杰里方案，支持连接手机，通过该蓝牙，可以手机放歌，当蓝牙音箱用；可以借助蓝牙功能，PDA实现打电话功能。可以BLE数据传输，通过微信小程序配置WIFI网络。</p><p>电源管理：暂时保密，同时锂电池充电管理</p><p>电池：诺基亚BL-5C  1000mAh</p><p>包边：不锈钢装饰条</p><p>正反面：亚克力广告贴（最终效果逼格高！）</p><p>2021年7月：</p><p>换屏了，3.8寸的带弧度的屏，这样做出来才像PDA</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">全志F1C200S F1C100S 介绍</a></li><li><a href="https://www.cnblogs.com/yanye0xcc/p/15173414.html">F1C100S基本信息</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C200S F1C100S 介绍</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="DKTool" scheme="https://zml3589110.github.io/tags/DKTool/"/>
    
  </entry>
  
  <entry>
    <title>F1C200S使用keil5开发问题</title>
    <link href="https://zml3589110.github.io/posts/3416408887.html"/>
    <id>https://zml3589110.github.io/posts/3416408887.html</id>
    <published>2025-09-15T07:04:20.000Z</published>
    <updated>2025-09-15T10:01:53.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h2 id="Folders-x2F-Extensions报错"><a href="#Folders-x2F-Extensions报错" class="headerlink" title="Folders&#x2F;Extensions报错"></a>Folders&#x2F;Extensions报错</h2><img src="/posts/3416408887/5aa9d2c17b19c786354a4e476f1acac8.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_44346906/article/details/136306006">keil5编译失败。‘Manage Project Items - Folders&#x2F;Extensions‘ to manage ARM Compiler Versions. ‘Options for</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序在Keil环境中开发问题收集</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/categories/Keil/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/tags/Keil/"/>
    
  </entry>
  
  <entry>
    <title>Web Serial网页串口</title>
    <link href="https://zml3589110.github.io/posts/3511617639.html"/>
    <id>https://zml3589110.github.io/posts/3511617639.html</id>
    <published>2025-09-10T13:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）"><a href="#使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）" class="headerlink" title="使用 Web Serial API 在浏览器中实现串口通讯（纯前端）"></a>使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>串口是非常常用的一种电脑与设备交互的接口。目前在浏览器上直接使用电脑上的串口设备了，这篇文章将介绍相关内容。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><strong>Web Serial API 相关内容参考如下：</strong></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Serial">https://developer.mozilla.org/en-US/docs/Web/API/Serial</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/SerialPort">https://developer.mozilla.org/en-US/docs/Web/API/SerialPort</a><br><a href="https://wicg.github.io/serial/">https://wicg.github.io/serial/</a></p><p><strong>这个API目前还处于实验性质，只有电脑上的Chrome、Edge、Opera等浏览器支持：</strong></p><img src="/posts/3511617639/dc7c13d0e94905685d30ef0d7b849e95.png" class="" title="在这里插入图片描述"><p><strong>另外还需要注意的是从网页操作设备是比较容易产生安全风险的，所以这个API只支持本地调用或者是HTTPS方式调用。</strong></p><p><strong>对于这个API谷歌有提供示例工程：</strong></p><p>在线使用：<a href="https://googlechromelabs.github.io/serial-terminal/">https://googlechromelabs.github.io/serial-terminal/</a><br>项目地址：<a href="https://github.com/GoogleChromeLabs/serial-terminal">https://github.com/GoogleChromeLabs/serial-terminal</a></p><p><strong>下面这个项目做的挺不错的，直接拿来用也很好：</strong></p><p>在线使用：<a href="https://itldg.github.io/web-serial-debug/">https://itldg.github.io/web-serial-debug/</a><br>项目地址：<a href="https://gitee.com/itldg/web-serial-debug">https://gitee.com/itldg/web-serial-debug</a> or <a href="https://github.com/itldg/web-serial-debug">https://github.com/itldg/web-serial-debug</a></p><img src="/posts/3511617639/5dfa19735e8d90d6a670175264b30bae.png" class="" title="在这里插入图片描述"><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><strong>使用下面方法可以侦测电脑上串口设备插入与拔出：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局串口设备插入事件</span></span><br><span class="line">navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial connected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局串口设备拔出事件</span></span><br><span class="line">navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial disconnected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以对单个的串口设备设置插入与拔出事件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用下面方法可以显示电脑上的串口设备选择授权，或者显示已授权的串口设备列表：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestPort方法将显示一个包含已连接设备列表的对话框，用户选择可以并授予其中一个设备访问权限</span></span><br><span class="line"><span class="comment">// 对于USB虚拟串口而言该方法还可以传入一个过滤器，指定PID&amp;VID的串口</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="keyword">await</span> navigator.serial.requestPort();</span><br><span class="line"><span class="comment">// port.forget(); // 取消授权</span></span><br><span class="line"><span class="comment">// port.getInfo() // 获取PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getDevices方法可以返回已连接的授权过的设备列表</span></span><br><span class="line"><span class="keyword">const</span> ports = <span class="keyword">await</span> navigator.serial.getPorts();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 open 方法打开选中的串口设备后就可以进行数据交互了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open时可以传入串口参数</span></span><br><span class="line"><span class="keyword">await</span> port.open(&#123;</span><br><span class="line">    baudRate: <span class="number">115200</span>,</span><br><span class="line">    <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span><br><span class="line">    <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span><br><span class="line">    <span class="comment">// flowControl: none, // 流控制，默认无</span></span><br><span class="line">    <span class="comment">// parity: none,      // 校验，默认无</span></span><br><span class="line">    <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>打开后就可以发送数据了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="comment">// const data= new Uint8Array(length);</span></span><br><span class="line"><span class="keyword">const</span> writer = port.writable.getWriter();</span><br><span class="line"><span class="keyword">await</span> writer.write(encoder.encode(<span class="string">&quot;PING&quot;</span>));</span><br><span class="line"><span class="comment">// await writer.write(data);</span></span><br><span class="line">writer.releaseLock();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>同样可以设置数据接收：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (port.readable) &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = port.readable.getReader();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Do something with |value|…</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// Handle |error|…</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.releaseLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据接收本身很简单，但需要注意的是在关闭串口前需要释放 reader 对象。</p><p><strong>下面是关闭串口操作：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 await port.close(); 即可关闭串口，如果正在读写数据，需要先释放相关资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keepReading = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readUntilClosed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (port.readable &amp;&amp; keepReading) &#123;</span><br><span class="line">    reader = port.readable.getReader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do something with |value|...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// Handle |error|...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      reader.releaseLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> port.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closed = readUntilClosed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sometime later...</span></span><br><span class="line">keepReading = <span class="literal">false</span>;</span><br><span class="line">reader.cancel();</span><br><span class="line"><span class="keyword">await</span> closed;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除了上面内容外还可以使用 setSignals 和 getSignals 来设置和获取流控制情况。</strong></p><h2 id="代码与演示"><a href="#代码与演示" class="headerlink" title="代码与演示"></a>代码与演示</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Serial API Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">button</span>,<span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">20rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">resize</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-x</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">5rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="string">&quot;serial&quot;</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert(&quot;Your browser support Web Serial API.&quot;); // 浏览器不支持 Web Serial API</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Your browser is not support Web Serial API.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备插入事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port connected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备拔出事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port disconnected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSelect&quot;</span>&gt;</span>select<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnOpen&quot;</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnClose&quot;</span>&gt;</span>close<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSend&quot;</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptOutput&quot;</span>&gt;</span>D0 D1 D2 D3 D4 D5 D6 D7<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptInput&quot;</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSelect = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSelect&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnOpen = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnOpen&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnClose = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnClose&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSend = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSend&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptOutput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptOutput&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptInput&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reader = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reading = <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 选择串口</span></span></span><br><span class="line"><span class="javascript">        btnSelect.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                port = <span class="keyword">await</span> navigator.serial.requestPort(); <span class="comment">// 弹出系统串口列表对话框，选择一个串口进行连接</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ports = <span class="keyword">await</span> navigator.serial.getPorts(); <span class="comment">// 获取已连接的授权过的设备列表</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ports);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// await port.forget(); // 取消授权</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(port.getInfo()); // 打印PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e); <span class="comment">// The prompt has been dismissed without selecting a device.</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateInputData</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data); <span class="comment">// event.data.buffer就是接收到的inputreport包数据了</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> hexstr = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> array) &#123;</span></span><br><span class="line"><span class="javascript">                hexstr += (<span class="built_in">Array</span>(<span class="number">2</span>).join(<span class="number">0</span>) + data.toString(<span class="number">16</span>).toUpperCase()).slice(-<span class="number">2</span>) + <span class="string">&quot; &quot;</span>; <span class="comment">// 将字节数据转换成（XX ）形式字符串</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            iptInput.value += hexstr;</span><br><span class="line"><span class="javascript">            iptInput.scrollTop = iptInput.scrollHeight; <span class="comment">// 滚动到底部</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 读取数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">listenReceived</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;On reading.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            reading = <span class="literal">true</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span> (port.readable &amp;&amp; reading) &#123;</span></span><br><span class="line">                reader = port.readable.getReader();</span><br><span class="line"><span class="javascript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span></span><br><span class="line">                        if (done) &#123;</span><br><span class="line"><span class="javascript">                            <span class="comment">// |reader| has been canceled.</span></span></span><br><span class="line"><span class="javascript">                            <span class="keyword">break</span>;</span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 需要特别注意的是：实际使用中即使对端是按一个个包发送的串口数据，接收时收到的也可能是分多段收到的</span></span></span><br><span class="line">                        updateInputData(value);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line">                    reader.releaseLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.close(); <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">            port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port closed.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 打开串口</span></span></span><br><span class="line"><span class="javascript">        btnOpen.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (port === <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not selected.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.open(&#123;</span></span><br><span class="line">                baudRate: 115200,</span><br><span class="line"><span class="javascript">                <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// flowControl: none, // 流控制，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// parity: none,      // 校验，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">            listenReceived();</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port opened.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">        btnClose.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                reading = <span class="literal">false</span>;</span></span><br><span class="line">                reader?.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取发送窗口十六进制字符串转换为字节数组</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getOutputData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> outputDatastr = iptOutput.value.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 去除所有空白字符</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (outputDatastr.length % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; <span class="regexp">/^[0-9a-fA-F]+$/</span>.test(outputDatastr)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取字节数组长度</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> byteLength = outputDatastr.length / <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 创建字节数组</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> outputData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteLength);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 将字符串转成字节数组数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteLength; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    outputData[i] = <span class="built_in">parseInt</span>(outputDatastr.substr(i * <span class="number">2</span>, <span class="number">2</span>), <span class="number">16</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 返回数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> outputData;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">throw</span> <span class="string">&quot;Data is not even or 0-9、a-f、A-F&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送数据</span></span></span><br><span class="line"><span class="javascript">        btnSend.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> writer = port.writable.getWriter();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> writer.write(getOutputData()); <span class="comment">// 发送数据</span></span></span><br><span class="line">            writer.releaseLock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面测试时我将串口的TX&#x2F;RT短接在一起，发送什么数据就会收到什么数据：</p><img src="/posts/3511617639/0256cd59c4a24e64aa50d9562bd40a80.gif" class="" title="在这里插入图片描述"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Web Serial API 访问串口非常方便，目前来说唯一的问题是这还是实验性质的功能，可能之后接口还会变动，需要根据实际情况进行调整。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/132522118">使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Web Serial网页串口</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/categories/Web/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>全志F1C100s使用记录</title>
    <link href="https://zml3589110.github.io/posts/968082855.html"/>
    <id>https://zml3589110.github.io/posts/968082855.html</id>
    <published>2025-09-10T11:59:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料索引与基础说明"><a href="#资料索引与基础说明" class="headerlink" title="资料索引与基础说明"></a>资料索引与基础说明</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最早接触到F1C100s是前两年的一个文章，里面使用F1C100s制作了一张可以运行Linux的名片，就是下图这个。下图上实际电路部分就占用角落一点点面积，当时觉得蛮有意思的的，可以跑Linux的开发板可以做这么小，成本和常见单片机最小系统板差不多，用来玩挺有意思的。</p><img src="/posts/968082855/b51b5b133d25d5997d2a341c993397b5.png" class="" title="在这里插入图片描述"><p>在这里文章里了解到 Sipeed Lichee Nano （荔枝派Nano），这个差不多可以当作F1C100s的最小系统板板用了，某宝一搜一大片，当时价格还不错，这两年因为疫情等各种原因价格上涨不少。</p><img src="/posts/968082855/3d4704387a6e3e446f72b4c9251458a6.png" class="" title="在这里插入图片描述"><p>这篇文章将介绍下上手玩F1C100s需要的一些基础信息，方便回头查询使用。</p><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><ul><li><strong>linux-sunxi community</strong><br><a href="https://linux-sunxi.org/Main_Page%E5%85%A8%E5%BF%97SoCs%E7%A4%BE%E5%8C%BAlinux">https://linux-sunxi.org/Main_Page全志SoCs社区linux</a> wiki，全志除了新出的基于RISC-V的D1，其它的芯片资料都是不开放的，mainlinux相关的开发都是由社区维护的，主要资料就是在这里；<br><strong>全志的芯片都以 <code>sunxi</code> 来指代，后面凡是看到 <code>sunxi</code> 或是 <code>sun\*</code> 的内容可能就是全志相关的内容；</strong>比如F1C100s就关联 <em>suniv</em> ；<br><a href="https://linux-sunxi.org/F1C100s">https://linux-sunxi.org/F1C100s</a><br>上面可以下载到F1C100s芯片的一些文档；</li><li><strong>WhyCan Forum(哇酷开发者社区)</strong><br><a href="https://whycan.com/index.html">https://whycan.com/index.html</a><br>这个论坛虽然嵌入式相关的内容都有涉及，但目前主要还是全志相关的内容多些；<br><a href="https://whycan.com/t_717.html">https://whycan.com/t_717.html</a><br>上面这篇文章中有很多F1C100s相关的例子资料等；<br><a href="https://whycan.com/t_3177.html">https://whycan.com/t_3177.html</a><br>F1C100s开发时的一个坑，编译工具链引起的问题；</li><li><strong>荔枝派Nano 全流程指南 与 资料下载</strong><br><a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a><br><a href="https://dl.sipeed.com/shareURL/LICHEE/Nano">https://dl.sipeed.com/shareURL/LICHEE/Nano</a></li><li><strong>My Business Card Runs Linux</strong><br><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/">https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a><br>这个就是开头说的那个可以运行Linux的名片的文章；</li></ul><h2 id="u-boot-amp-linux"><a href="#u-boot-amp-linux" class="headerlink" title="u-boot &amp; linux"></a>u-boot &amp; linux</h2><p>F1C100s玩的最多的就是拿来搞Linux玩，重要的是针对该芯片的uboot和linux的修改，这里收集了一些主要的项目：</p><p><strong>u-boot</strong></p><ul><li><a href="https://github.com/Icenowy/u-boot">https://github.com/Icenowy/u-boot</a><br>这个项目有 <em>f1c100s</em> 和 <em>f1c100s-spiflash</em> 两个分支，后者更加新点；<br>分支中有 <em>licheepi_nano_defconfig</em> 和 <em>licheepi_nano_spiflash_defconfig</em> 两个配置文件；</li><li><a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a><br>这个项目包含荔枝派所有的u-boot，对于F1C100s而言则是在前面项目的 f1c100s-spiflash 分支基础上新增了 <em>nano-lcd800480</em> 分支，增加了对lcd的支持；</li></ul><p><strong>linux</strong></p><ul><li><p><a href="https://github.com/Icenowy/linux">https://github.com/Icenowy/linux</a><br>这个项目主要查看 <em>f1c100s</em> 分支；</p></li><li><p><a href="https://github.com/Lichee-Pi/linux">https://github.com/Lichee-Pi/linux</a><br>这个项目目前主要查看 <em>nano-4.14-exp</em> 、 <em>nano-5.2-tf</em> 、 <em>nano-5.2-flash</em> 三个分支；<br><em>nano-4.14-exp</em> 分支是在前面项目的基础上修复了一个bug，这个分支可以下载<br><a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 这个配置文件进行测试；</p></li></ul><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>F1C100s是全志的一颗比较便宜的芯片，其功能框图如下：</p><img src="/posts/968082855/7bf76defe2cb6abf7faeb95d27d9338c.png" class="" title="在这里插入图片描述"><p>典型应用如下：</p><img src="/posts/968082855/42ce2ee954569f4714c54cc5d205035e.png" class="" title="在这里插入图片描述"><ul><li><strong><code>F1C100s的内核是 ARM926EJ-S ，ARMv5架构，有MMU，没有硬件FPU，主频默认为408MHz；</code></strong></li><li><strong><code>F1C100s内置32MB DDR1内存；</code></strong></li><li><strong><code>F1C200s是F1C100s的兄弟型号，其它特性都相同，内存容量翻倍为64MB；</code></strong></li></ul><p>F1C100s和F1C200s价格便宜的时候可以在1~2刀左右，带有LCD、摄像头、音频、视频等接口，还内置几十兆内存，用来简单的点屏使用比单片机之类的好多了。所以经常可以看到用F1C100s来做行车记录仪或是复古游戏机等产品。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>F1C100s的启动过程在它流出的手册中并没有找到相关描述，在 <em>全志V3s</em> 的 <em>DataSheet</em> 的 <em>4.2. Boot System</em> 章节中倒是有相似描述，可以作为参考：</p><img src="/posts/968082855/c0effa5c4bcc99fcb1419b633e545da2.png" class="" title="在这里插入图片描述"><p>芯片上电启动后，芯片会先执行内部固化的程序（BROM），该程序会依次检查外部存储器是否可用，如果可用再从中加载第二阶段程序（SPL）并执行。如果前面过程失败了则会进入全志系列处理器内置的FEL模式。</p><p><strong>对于F1C100s而言启动时寻找用户程序的位置顺序如下：</strong></p><ul><li>SDC0接口（<em>PF0~PF5</em>）上的SD（TF）卡；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nor Flash；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nand Flash；</li></ul><p><strong>对于SD（TF）卡而言在它上面的数据存储布局通常如下****：</strong></p><table><thead><tr><th>start</th><th>sector</th><th>size</th><th>usage</th></tr></thead><tbody><tr><td>0KB</td><td>0</td><td>8KB</td><td>Unused, available for an MBR or (limited) GPT partition table</td></tr><tr><td>8KB</td><td>16</td><td>32KB</td><td>Initial SPL loader</td></tr><tr><td>—-</td><td>—-</td><td>———</td><td>——————</td></tr><tr><td>40KB</td><td>80</td><td>Max 984KB</td><td>U-Boot</td></tr><tr><td>1MB</td><td>2048</td><td>-</td><td>bootfs and rootfs</td></tr></tbody></table><p>上面参数中SPL从8K位置开始不能动（这是由BROM决定的）；文件系统可以根据需要来分区，boot分区在前，通常为FAT格式。</p><p>如果使用上文列出的那些 u-boot 项目，编译后会得到 <strong>u-boot-sunxi-with-spl.bin</strong> 这个文件会拼合 spl 和 u-boot ，直接把这个文件写入到 8KB 开始的位置就行了。</p><p>更多内容可以参考：<a href="https://linux-sunxi.org/Bootable_SD_card">https://linux-sunxi.org/Bootable_SD_card</a></p><p><strong>对于SPI Flash</strong>而言其实和SD（TF）卡而言差不多，最关键的就是将 <em>u-boot-sunxi-with-spl.bin</em> 文件放在头部，即从0位置开始写入；其它内容根据需求而设置，只要对应的调整 u-boot 读取启动内核时相关位置参数就行。</p><p>需要注意的是默认情况下SPI Flash最大支持16M，更大就需要在程序中设置bank了。</p><h2 id="FEL模式"><a href="#FEL模式" class="headerlink" title="FEL模式"></a>FEL模式</h2><p>上文中可以了解到F1C100s要是启动外部程序均失败的话就会进入FEL模式，用户可以通过USB和芯片进行交互 。在FEL模式你可以直接运行 u-boot 和 linux 等，也可以将数据写入spiflash中（可以用作烧录固件到设备中）。</p><p>FEL模式其实也就是BROM上的一段程序，可以在 <code>u-boot</code> 命令行中使用 <code>go 0xffff0020</code> 跳转进入。另外也可以通过在SD（TF）卡写入下面数据来通过SD（TF）卡启动跳转：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sdX 为SD（TF）卡，使用 sudo fdisk -l 查看</span></span><br><span class="line"><span class="comment"># 如果有自动挂载的分区则逐条使用 sudo umount /dev/sdXn 进行卸载</span></span><br><span class="line">wget https://github.com/linux-sunxi/sunxi-tools/raw/master/bin/fel-sdboot.sunxi</span><br><span class="line">sudo dd <span class="keyword">if</span>=fel-sdboot.sunxi of=/dev/sdX bs=1024 seek=8</span><br></pre></td></tr></table></figure><p>如果外接了SPI Flash，并且SPI Flash中有可运行的程序的话可以将F1C100s的 <em>Pin60 - PC1 - SPI0_CS</em> 即 SPI Flash 的 1 脚接地后进入FEL模式。</p><p>为了和FEL模式下的芯片交互我们还需要用到 <em>sunxi-tools</em> 工具包，针对运行程序或烧录等操作需要用到其中的 <em>sunxi-fel</em> 工具，工具包项目地址如下：<br><a href="https://github.com/Icenowy/sunxi-tools">https://github.com/Icenowy/sunxi-tools</a></p><p>针对F1C100s的 <em>sunxi-fel</em> 工具可以使用下面方式下载、编译、安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-1.0-0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译完成后可以使用下面方式安装到系统目录</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br><span class="line"><span class="comment"># 不过其实不推荐安装到系统目录，因为全志不同的芯片需要用不同分支的sunxi-tools</span></span><br><span class="line"><span class="comment"># 更加推荐使用时临时添加环境目录，比如下面这样</span></span><br><span class="line"><span class="comment"># export PATH=$PATH:sunxi-tools目录路径</span></span><br><span class="line"><span class="comment"># 这种方式使用时需要用下面方式</span></span><br><span class="line"><span class="comment"># sudo `which sunxi-fel` [-选项] 命令 参数</span></span><br></pre></td></tr></table></figure><p>安装完成后可以使用 <code>sudo sunxi-fel -l</code> 列出所有处于FEL模式的设备、使用 <code>sudo sunxi-fel ver</code> 设备 BROM 信息：</p><img src="/posts/968082855/4914896309688605f6efd130124b559b.png" class="" title="在这里插入图片描述"><p>可以使用 <code>sudo sunxi-fel uboot /path/u-boot-sunxi-with-spl.bin</code> 来直接运行u-boot程序；</p><p>可以使用 <code>sudo sunxi-fel -p spiflash-write addr file</code> （addr常用0）将数据写入spiflash（注意最大16M，再大可能需要改程序）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./sunxi-fel [options] <span class="built_in">command</span> arguments... [<span class="built_in">command</span>...]</span><br><span class="line">        -v, --verbose                   Verbose logging</span><br><span class="line">        -p, --progress                  <span class="string">&quot;write&quot;</span> transfers show a progress bar</span><br><span class="line">        -l, --list                      Enumerate all (USB) FEL devices and <span class="built_in">exit</span></span><br><span class="line">        -d, --dev bus:devnum            Use specific USB bus and device number</span><br><span class="line">            --sid SID                   Select device by SID key (exact match)</span><br><span class="line"></span><br><span class="line">        spl file                        Load and execute U-Boot SPL</span><br><span class="line">                If file additionally contains a main U-Boot binary</span><br><span class="line">                (u-boot-sunxi-with-spl.bin), this <span class="built_in">command</span> also transfers that</span><br><span class="line">                to memory (default address from image), but won<span class="string">&#x27;t execute it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        uboot file-with-spl             like &quot;spl&quot;, but actually starts U-Boot</span></span><br><span class="line"><span class="string">                U-Boot execution will take place when the fel utility exits.</span></span><br><span class="line"><span class="string">                This allows combining &quot;uboot&quot; with further &quot;write&quot; commands</span></span><br><span class="line"><span class="string">                (to transfer other files needed for the boot).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        hex[dump] address length        Dumps memory region in hex</span></span><br><span class="line"><span class="string">        dump address length             Binary memory dump</span></span><br><span class="line"><span class="string">        exe[cute] address               Call function address</span></span><br><span class="line"><span class="string">        reset64 address                 RMR request for AArch64 warm boot</span></span><br><span class="line"><span class="string">        readl address                   Read 32-bit value from device memory</span></span><br><span class="line"><span class="string">        writel address value            Write 32-bit value to device memory</span></span><br><span class="line"><span class="string">        read address length file        Write memory contents into file</span></span><br><span class="line"><span class="string">        write address file              Store file contents into memory</span></span><br><span class="line"><span class="string">        write-with-progress addr file   &quot;write&quot; with progress bar</span></span><br><span class="line"><span class="string">        write-with-gauge addr file      Output progress for &quot;dialog --gauge&quot;</span></span><br><span class="line"><span class="string">        write-with-xgauge addr file     Extended gauge output (updates prompt)</span></span><br><span class="line"><span class="string">        multi[write] # addr file ...    &quot;write-with-progress&quot; multiple files,</span></span><br><span class="line"><span class="string">                                        sharing a common progress status</span></span><br><span class="line"><span class="string">        multi[write]-with-gauge ...     like their &quot;write-with-*&quot; counterpart,</span></span><br><span class="line"><span class="string">        multi[write]-with-xgauge ...      but following the &#x27;</span>multi<span class="string">&#x27; syntax:</span></span><br><span class="line"><span class="string">                                          &lt;#&gt; addr file [addr file [...]]</span></span><br><span class="line"><span class="string">        echo-gauge &quot;some text&quot;          Update prompt/caption for gauge output</span></span><br><span class="line"><span class="string">        ver[sion]                       Show BROM version</span></span><br><span class="line"><span class="string">        sid                             Retrieve and output 128-bit SID key</span></span><br><span class="line"><span class="string">        clear address length            Clear memory</span></span><br><span class="line"><span class="string">        fill address length value       Fill memory</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>对于Windows上装虚拟机来操作的话这之间还有一个坑：默认情况下FEL模式的USB设备Windows是无法识别的，这样就更没法传递给虚拟机使用了。这个问题可以使用 <a href="https://zadig.akeo.ie/">https://zadig.akeo.ie/</a> 这个工具来安装驱动解决（主要关注VID和PID就行）：</p><img src="/posts/968082855/d87e33cc9a73f2a6abb879e47a64a048.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/ac578738576c24cc2425ccc38f0d0748.png" class="" title="在这里插入图片描述"><p>除了 <em>sunxi-fel</em> ，也可以使用第三方的 <em>XFEL</em> 工具来进行FEL模式下的交互操作， <em>XFEL</em> 还有提供windows版本的可执行文件。项目地址如下：<br><a href="https://github.com/xboot/xfel">https://github.com/xboot/xfel</a></p><p>关于FEL模式的更多内容可以参考下面链接：<br><a href="https://linux-sunxi.org/FEL">https://linux-sunxi.org/FEL</a><br><a href="https://linux-sunxi.org/FEL/USBBoot">https://linux-sunxi.org/FEL/USBBoot</a></p><h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><p>电路设计上主要有下面一些注意点：</p><ul><li><strong>SD（TF）卡连接在SDC0</strong><br><code>Pin53 - PF5 - SDC0_D2</code><br><code>Pin54 - PF4 - SDC0_D3</code><br><code>Pin55 - PF3 - SDC0_CMD</code><br><code>Pin56 - PF2 - SDC0_CLK</code><br><code>Pin57 - PF1 - SDC0_D0</code><br><code>Pin58 - PF0 - SDC0_D1</code></li><li><strong>SPI Flash连接在SPI0</strong><br><code>Pin59 - PC0 - SPI0_CLK</code><br><code>Pin60 - PC1 - SPI0_CS</code><br><code>Pin61 - PC2 - SPI0_MISO</code><br><code>Pin62 - PC3 - SPI0_MOSI</code></li><li><strong>FEL模式通过USB通讯</strong><br><code>Pin68 - USB-DM</code><br><code>Pin69 - USB-DP</code></li><li><strong>控制台交互通过UART0</strong><br><code>Pin48 - PE1 - UART0_TX</code><br><code>Pin49 - PE0 - UART0_RX</code></li><li><strong>供电</strong><br><code>VCC-CORE - 1.0~1.2V</code><br><code>VCC-DRAM - 2.3~2.7V</code> <code>SVREF - 通过电阻将VCC-DRAM分压成一半</code><br><code>AVCC - 2.5~3.1V</code><br><code>VCC-IO / UVCC / HPVCC / TV_VCC - 2.5~3.1V</code></li></ul><p>电路设计上可以参考 荔枝派Nano 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/7bc367ee1b31ab3fc06a93c7b97acccf.png" class="" title="在这里插入图片描述"><p>如果对电路功能上没啥需求，只需要跑个Linux玩的话可以参考 Business Card 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/231b714136edcf31d159cd2ecfbd7d67.png" class="" title="在这里插入图片描述"><h1 id="u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）"><a href="#u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）" class="headerlink" title="u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）"></a>u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>测试用开发板可以参考上面文章中电路绘制，或者也可以直接购买荔枝派Nano进行测试。</p><img src="/posts/968082855/fff757aeb13d7b8676e87b0322bc8c83.png" class="" title="在这里插入图片描述"><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>下载安装Ubuntu Desktop（使用版本为20.04）：<br><a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p><p>安装完成后进行基础环境安装与设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install -y build-essential</span><br><span class="line">sudo apt install -y libusb-1.0-0-dev zlib1g-dev</span><br><span class="line">sudo apt install -y pkg-config</span><br><span class="line">sudo apt install -y python python3 python-dev python3-dev</span><br><span class="line">sudo apt install -y swig</span><br><span class="line">sudo apt install -y libncurses-dev libncurses5-dev</span><br><span class="line">sudo apt install -y libssl-dev</span><br><span class="line">sudo apt install -y kpartx</span><br><span class="line">sudo apt install -y mtd-utils</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为需要从GitHub下载项目所以还要安装git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y git</span><br><span class="line"><span class="comment"># git使用时可能需要设置用户名和邮箱</span></span><br><span class="line"><span class="comment"># git config --global user.name &quot;naisu&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email naisu@example.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立工作目录并进入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本文将工作目录设置在用户目录（$HOME）下的f1c100s-sdk文件夹中</span></span><br><span class="line"><span class="comment"># cd ~</span></span><br><span class="line">mkdir f1c100s-sdk</span><br><span class="line"><span class="built_in">cd</span> f1c100s-sdk/ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="制作toolchain和rootfs"><a href="#制作toolchain和rootfs" class="headerlink" title="制作toolchain和rootfs"></a>制作toolchain和rootfs</h2><p>为了方便这里使用buildroot来制作rootfs，这里有个坑。这里如果使用linaro等组织提供的现成的交叉编译工具链来编译buildroot项目生成rootfs，在使用时系统启动过程中可能会出现 Kernel panic - not syncing: Attempted to kill init! exitcode&#x3D;0x0000000b ，而使用buildroot自己生成的编译工具链就不会出现这个问题了。所以我们这里统一使用buildroot生成的编译工具链。</p><p>下载、解压与配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">wget https://buildroot.org/downloads/buildroot-2022.02.tar.xz</span><br><span class="line">tar -xJf buildroot-2022.02.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入buildroot-2022.02目录</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2022.02/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行配置</span></span><br><span class="line"><span class="comment"># 这里做测试使用，只要配置下目标和工具链即可，详见后面截图</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/posts/968082855/8497be47fe917fc84b72e565f9bec9e2.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/8935dd6dc710379acf7c9b4a3ef3da4e.png" class="" title="在这里插入图片描述"><p>编译完成后 <em>output</em> 目录下的 <em>host</em> 目录中就是交叉编译工具链（toolchain）； <em>output</em> 目录下的 <em>images</em> 目录中的 <em>rootfs.tar</em> 就是生成的根文件系统。</p><h3 id="设置编译工具链"><a href="#设置编译工具链" class="headerlink" title="设置编译工具链"></a>设置编译工具链</h3><p><strong>注意PATH使用自己的路径，每次打开终端都需要重新设置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabi-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/nx/f1c100s-sdk/buildroot-2022.02/output/host/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="u-boot-amp-linux编译"><a href="#u-boot-amp-linux编译" class="headerlink" title="u-boot &amp; linux编译"></a>u-boot &amp; linux编译</h2><h3 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h3><p>下载、配置、编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-lcd800480 --depth=1 https://github.com/Lichee-Pi/u-boot.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入u-boot目录</span></span><br><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置文件</span></span><br><span class="line">make licheepi_nano_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认bootcmd</span></span><br><span class="line">gedit include/configs/suniv.h</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND <span class="meta-string">&quot;run distro_bootcmd&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后就可以编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后当前目录下的 <em>u-boot-sunxi-with-spl.bin</em> 文件就是我们需要的。</p><h3 id="boot-scr"><a href="#boot-scr" class="headerlink" title="boot.scr"></a>boot.scr</h3><p>根据上面对bootcmd的修改，u-boot启动时会从第一分区读取 <em>boot.scr</em> 文件，并执行其中的脚本。我们可以通过这个来设置要传递给linux内核的参数、来加载内核和设备树、来启动内核。</p><p>在uboot目录下新建boot.cmd文件，向其中写入u-boot要执行的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">touch boot.cmd</span><br><span class="line">gedit boot.cmd</span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置传递给内核的bootargs参数</span></span><br><span class="line"><span class="comment"># 读取内核镜像和设备树到内存中指定位置</span></span><br><span class="line"><span class="comment"># 启动内核程序</span></span><br><span class="line">setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">load mmc 0:1 0x80008000 zImage</span><br><span class="line">load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">bootz 0x80008000 - 0x80C00000</span><br></pre></td></tr></table></figure><p>使用u-boot编译后tools目录下的 <em>mkimage</em> 工具可以将boot.cmd文件生成为 <em>boot.scr</em> 文件，通过下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm架构；不压缩；script文件；输入boot.cmd文件；输出boot.scr文件</span></span><br><span class="line">tools/mkimage -A arm -C none -T script -d boot.cmd boot.scr</span><br></pre></td></tr></table></figure><p>生成的 <em>boot.scr</em> 文件就在当前目录下。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-4.14-exp --depth=1 https://github.com/Lichee-Pi/linux.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入linux目录</span></span><br><span class="line"><span class="built_in">cd</span> linux/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载使用荔枝派Nano的linux配置文件</span></span><br><span class="line">wget https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</span><br><span class="line">cp config .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据需要配置，没有需要的话直接按两下Esc保存退出</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line"><span class="comment"># 过程中如果出现需要设置的选项全部选n</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后在 <em>arch&#x2F;arm&#x2F;boot&#x2F;</em> 目录下的 <em>zImage</em> 文件就是压缩后的内核程序；在 <em>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;</em> 目录下的 <em>suniv-f1c100s-licheepi-nano.dtb</em> 或 <em>suniv-f1c100s-licheepi-nano-with-lcd.dtb</em> 文件就是编译后的设备树文件。</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>嵌入式linux开发最终是需要在系统上运行应用程序来实现特定的功能需求，这里编写个基础的应用程序用于测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 建立程序文件夹并进入</span></span><br><span class="line">mkdir helloworld</span><br><span class="line"><span class="built_in">cd</span> helloworld/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立程序文件并编写程序</span></span><br><span class="line">touch helloworld.c</span><br><span class="line">gedit helloworld.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabi-gcc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure><p>生成的 <em>helloworld</em> 就是我们需要的可执行文件了。</p><h2 id="文件烧录"><a href="#文件烧录" class="headerlink" title="文件烧录"></a>文件烧录</h2><p>前面编译生成的内容可以分块分别烧录进SD卡进行测试，也可以将 u-boot &amp; linux &amp; rootfs 整块打包烧录进SD卡进行测试，其实本质上是一样的，这里先进行分块测试的介绍，打包烧录介绍将在后面的章节说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将SD卡插入Ubuntu中</span></span><br><span class="line"><span class="comment"># 使用 lsblk 查看SD卡设备号sdX</span></span><br><span class="line"><span class="comment"># 我这里显示为sdb，下面均以此进行说明</span></span><br></pre></td></tr></table></figure><h3 id="分区设置"><a href="#分区设置" class="headerlink" title="分区设置"></a>分区设置</h3><p>准备SD卡并按要求分区，空间划分参考本文开头的给出的文章，下面是在Ubuntu终端中进行分区划分示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果已经分过区了那么Ubuntu可能会自动挂载</span></span><br><span class="line"><span class="comment"># 逐条使用 sudo umount /dev/sdbn 进行卸载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对SD（TF）卡进行分区</span></span><br><span class="line">sudo fdisk /dev/sdb</span><br><span class="line"><span class="comment"># 如果有分区的话可以输入 d 回车依次删除</span></span><br><span class="line"><span class="comment"># 输入 n 新建分区，分区大小根据需要设置即可</span></span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，输入使用 lsblk 查看分区情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/sdb1</span><br><span class="line">sudo mkfs.ext4 /dev/sdb2</span><br></pre></td></tr></table></figure><h3 id="分块烧录"><a href="#分块烧录" class="headerlink" title="分块烧录"></a>分块烧录</h3><p><strong>u-boot</strong><br><em>u-boot-sunxi-with-spl.bin</em> 文件需要放置在SD卡8k开始的位置上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin  of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><p><strong>linux &amp; dtb &amp; boot.scr</strong><br>这三个放在刚才新建的第一个分区里（sdb1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝linux和dtb</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/linux/</span></span><br><span class="line">sudo cp arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝boot.scr</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo cp boot.scr /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br></pre></td></tr></table></figure><p><strong>rootfs</strong><br>这个放在刚才新建的第二个分区里（sdb2）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并拷贝rootfs</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/buildroot-2022.02/</span></span><br><span class="line">sudo tar -xf output/images/rootfs.tar -C /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br></pre></td></tr></table></figure><p><strong>测试程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝helloworld</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/helloworld/</span></span><br><span class="line">sudo cp helloworld /mnt/root/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="上电测试"><a href="#上电测试" class="headerlink" title="上电测试"></a>上电测试</h2><p>上电打印信息与应用程序测试结果与关键日志如下：</p><p><em>默认通过UART0 PE0-RX PE1-TX 波特率115200</em><br><em>我这里使用的是F1C200s，所以内存显示为 64 MiB</em><br><em>前面生成的rootfs登陆用户名为root，无密码</em></p><img src="/posts/968082855/93e44242d33e3d5eee3579a3f39b0796.gif" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Lichee Pi Nano</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">mmc0 is current device</span><br><span class="line">Scanning mmc 0:1...</span><br><span class="line">Found U-Boot script /boot.scr</span><br><span class="line">reading /boot.scr</span><br><span class="line">279 bytes <span class="built_in">read</span> <span class="keyword">in</span> 14 ms (18.6 KiB/s)</span><br><span class="line"><span class="comment">## Executing script at 80c50000</span></span><br><span class="line">reading zImage</span><br><span class="line">3841152 bytes <span class="built_in">read</span> <span class="keyword">in</span> 200 ms (18.3 MiB/s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7464 bytes <span class="built_in">read</span> <span class="keyword">in</span> 25 ms (291 KiB/s)</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd27 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.14.0-licheepi-nano+ (nx@nx-ubuntu) (gcc version 10.3.0 (Buildroot 2022.02)) <span class="comment">#1 Tue Mar 15 16:07:52 CST 2022</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">[    1.331930] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.375977] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.390277] mmc0: new high speed SDHC card at address aaaa</span><br><span class="line">[    1.396880] mmcblk0: mmc0:aaaa SC16G 14.8 GiB </span><br><span class="line">[    1.407742]  mmcblk0: p1 p2</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Starting syslogd: OK</span><br><span class="line">Starting klogd: OK</span><br><span class="line">Running sysctl: OK</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Welcome to Buildroot</span><br><span class="line">buildroot login: root</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">helloworld</span><br><span class="line"><span class="comment"># ./helloworld </span></span><br><span class="line">Hello, world!</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h2><p>前面分块烧录在测试的时候用用还行，但是如果是要批量生产或是交给他人使用就不方便了，这个时候可以制作系统成单个系统镜像文件来处理。</p><p>前面讲了对SD卡分区等操作，其实不管是分区还是数据拷贝等，最终在SD卡上无非就是一片按照一定顺序存储的数据。把这段数据原模原样的拷贝成一个文件，这就是系统镜像文件，使用的时候只要把这个文件内容拷贝到SD卡上就可以了。</p><h3 id="制作镜像文件"><a href="#制作镜像文件" class="headerlink" title="制作镜像文件"></a>制作镜像文件</h3><p><strong>从已有SD卡制作镜像文件</strong><br>如果有已经烧录完成所有内容的SD卡的话直接使用 dd 命令将SD卡内容复制到一个文件即可得到系统镜像文件。比如针对前面流程下的SD卡可以使用下面方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 将SD卡中有用的数据保存镜像文件中</span></span><br><span class="line"><span class="comment"># 大小为 1M(uboot) + 32M(bootfs) + 200M(rootfs) + 2M(多拷贝点，防止不明意外)</span></span><br><span class="line"><span class="comment"># 数据比较大会花点时间</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sdb of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>从编译生成的文件制作</strong><br>如果还没有烧录好的SD卡也可以直接从编译生成的文件制作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 向镜像文件写入空数据固定大小</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的设备挂载点</span></span><br><span class="line">sudo losetup -f</span><br><span class="line"><span class="comment"># 我这里显示 /dev/loop13，接下来都以此进行说明</span></span><br><span class="line"><span class="comment"># 将镜像文件挂载到 /dev/loop13</span></span><br><span class="line">sudo losetup /dev/loop13 f1c100s-system-image.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对挂载的设备进行分区</span></span><br><span class="line">sudo fdisk /dev/loop13</span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 接着 a回车 1回车 (将分区1设置为可启动)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，会有点问题提示不用管</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分区表</span></span><br><span class="line">sudo kpartx -av /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/mapper/loop13p1</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第一个分区向里拷贝linux、dtb、boot.scr</span></span><br><span class="line">sudo mount /dev/mapper/loop13p1 /mnt</span><br><span class="line">sudo cp linux/arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp linux/arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line">sudo cp u-boot/boot.scr /mnt/</span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第二个分区向里解压并拷贝rootfs</span></span><br><span class="line">sudo mount /dev/mapper/loop13p2 /mnt</span><br><span class="line">sudo tar -xf buildroot-2022.02/output/images/rootfs.tar -C /mnt/</span><br><span class="line"><span class="comment"># 根据需求也可以拷贝应用程序进去</span></span><br><span class="line"><span class="comment"># sudo cp helloworld/helloworld /mnt/root/</span></span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载设备</span></span><br><span class="line">sudo kpartx -d /dev/loop13</span><br><span class="line">sudo losetup -d /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向头部写入uboot，注意conv=notrunc选项参数一定不能漏</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot/u-boot-sunxi-with-spl.bin  of=f1c100s-system-image.bin bs=1024 seek=8 conv=notrunc</span><br></pre></td></tr></table></figure><p><strong>压缩系统镜像</strong><br>前面生成的系统镜像比较大，不适合存储，可以对镜像镜像压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 将系统镜像以zip方式镜像压缩</span></span><br><span class="line">zip f1c100s-system-image.zip f1c100s-system-image.bin</span><br></pre></td></tr></table></figure><h3 id="使用镜像文件"><a href="#使用镜像文件" class="headerlink" title="使用镜像文件"></a>使用镜像文件</h3><p><strong>在Linux上可以直接使用 *dd* 命令将镜像文件写入SD卡中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压镜像文件压缩包</span></span><br><span class="line">unzip f1c100s-system-image.zip</span><br><span class="line"><span class="comment"># 将镜像文件写入SD卡，写入可能较慢</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=f1c100s-system-image.bin of=/dev/sdb bs=1M</span><br></pre></td></tr></table></figure><p>当然我更加推荐使用工具来烧录，<strong>这里推荐使用 BalenaEtcher 工具</strong> ，这个工具支持windos、macos、linux，其官方页面和项目地址分别如下：<br><a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a><br><a href="https://github.com/balena-io/etcher">https://github.com/balena-io/etcher</a><br>下面是用这个工具进行烧录的演示：</p><img src="/posts/968082855/3b2b282db96c566137f8554efdbcc6b5.gif" class="" title="在这里插入图片描述"><p>上面演示了使用BalenaEtcher工具进行烧录和启动测试，其中有两点值得注意的：</p><ul><li>原始的.bin后缀名的系统进行经过压缩后变得非常小（235MB &gt; 5.98MB），可见压缩非常有用；</li><li>BalenaEtcher可以直接使用压缩包进行烧录（比如我上面演示中）；</li></ul><h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><ul><li><strong>buildroot编译过程中下载文件慢</strong><br>buildroot编译过程中会下载很多文件，有可能会下着下着就不动了，或是下载缓慢。首先可以尝试使用 <code>ctrl + c</code> 终止当前工作后再 <code>make</code> ，会从终止的步骤重新开始；<br>如果上面的方式不行，那自行查看编译输出信息，其中有文件下载地址的，手动用下载工具进行下载，把下载的内容压缩包或解压后内容放到buildroot的 <code>dl</code> 目录下，然后重复前面步骤；</li><li><strong>编译过程中因为缺少文件报错</strong><br>百度、必应等查找Ubuntu下安装这些文件的方法；</li><li><strong>编译或使用中其它不明的问题</strong><br>使用 <code>make clean</code> 或者 <code>make distclean</code> 后重复配置编译过程；</li></ul><h2 id="SDK数据包"><a href="#SDK数据包" class="headerlink" title="SDK数据包"></a>SDK数据包</h2><p>鉴于整个过程中有很多东西需要下载，部分内容可能下载缓慢，所以将本文中出现的主要的几个项目内容进行了打包，方便将来使用。下载链接如下：</p><p>链接：<a href="https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g">https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g</a><br>提取码：<code>ezrw</code></p><p>下载下来是个zip格式压缩包，解压后得到下面内容（Ubuntu上可以使用 unzip 进行解压）：</p><img src="/posts/968082855/f3eaf553ab39f4d46e3bed21d55995f2.png" class="" title="在这里插入图片描述"><p>各个文件说明如下：</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>helloworld</td><td>内部含有helloworld.c文件</td></tr><tr><td>buildroot-2022.02.tar.xz</td><td>使用 wget <a href="https://buildroot.org/downloads/buildroot-2022.02.tar.xz">https://buildroot.org/downloads/buildroot-2022.02.tar.xz</a> 下载得到的压缩包</td></tr><tr><td>buildroot-2022.02-with-dl.tar.xz</td><td>根据上面项目 make menuconfig &gt; make &gt; make clean 后的文件夹进行重新打包压缩 其dl文件夹中包含了所有make时需要下载的东西</td></tr><tr><td>linux.tar.xz</td><td>使用 git clone -b nano-4.14-exp –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/linux.git">https://github.com/Lichee-Pi/linux.git</a> 下载 得到的linux文件夹中放入使用 wget <a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 下载的config文件<br/>然后对linux文件夹重新打包</td></tr><tr><td>sunxi-tools.tar.xz</td><td>使用 git clone -b f1c100s-spiflash –depth&#x3D;1 <a href="https://github.com/Icenowy/sunxi-tools.git">https://github.com/Icenowy/sunxi-tools.git</a> 下载 得到的sunxi-tools文件夹重新打包</td></tr><tr><td>u-boot.tar.xz</td><td>使用 git clone -b nano-lcd800480 –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> 下载 到的u-boot文件夹重新打包</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于现有的一些项目，详细记录 <em>u-boot &amp; linux &amp; rootfs 编译与烧录测试（ 基于SD卡）</em> 整个流程内容，可以作为进一步的移植、开发与使用的基础。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/122704052">资料索引与基础说明</a></li><li><a href="https://blog.csdn.net/Naisu_kun/article/details/123142958">u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C100s使用记录</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="F1C100S" scheme="https://zml3589110.github.io/tags/F1C100S/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266内置网页配置</title>
    <link href="https://zml3589110.github.io/posts/2546212267.html"/>
    <id>https://zml3589110.github.io/posts/2546212267.html</id>
    <published>2025-09-10T08:09:20.000Z</published>
    <updated>2025-09-10T13:10:14.324Z</updated>
    
    <content type="html"><![CDATA[<p>1、写入一个网页到FLASH指定位置：</p><p>（1）找到可以放置网页的位置；扇区：4KBytes-0x001000</p><p>ESP8266-01:FLASH:25Q80&#x3D;8Mbits&#x3D;1MBytes&#x3D;0x100000: 256扇区</p><p>eagle.flash.bin——————————————–0x000000: 0扇区—–64KBytes</p><p>eagle.irom0text.bin————————————–0x010000: 16扇区—-944KBytes</p><p>esp_init_data_default_v05.bin———————–0x0FC000: 252扇区</p><p>blank.bin—————————————————0x0FE000: 254扇区</p><p>FLASH中前64K为系统程序1，紧接着是系统程序2，倒数4个扇区（16KBytes）中为系统参数区。<br>用户可用区域在系统程序2与系统参数区中间部分，<br>至于从何扇区开始，到何处结束，则由前后扇区内容决定。在ld-&gt;eagle.app.v6.ld中可以查看各区域设置的长度，<br>其中最后一项是irom0_0_seg-&gt;len即为eagle.irom0text.bin的允许长度。由此可以计算出用户可用区域的起始结束地址</p><img src="/posts/2546212267/34f8765cbe2ed465be5ed6dd8770a434.png" class="" title="img"><p>eagle.irom0text.bin—0x010000—0x06C000: 0x05C000</p><p>因此用户可用区域为: 0x06C000—0x0FC000: 576KBytes: 144扇区</p><p>（2）放入写好的网页，读取出来看看数据是否写入正确；</p><p>使用ESP8266烧写工具在指定位置放入一个WEB页面，利用OS_printf输出到串口助手查看。</p><p>新建一个login.html ；注意格式一定要是UTF-8，否则在页面开头有乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>LOGIN<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;<span class="attribute">width</span>:<span class="number">500px</span>;<span class="attribute">height</span>:<span class="number">80px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.log</span>&#123;<span class="attribute">font-size</span>:<span class="number">80px</span>;<span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.dx</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;dx&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span> <span class="attr">action</span>=<span class="string">&#x27;Login.cgi&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录WIFI设置界面</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">UserName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;NAME&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> PassWord:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;PWD&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;log&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;登录&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;NAME&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;PWD&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ESP8266测试代码中，读取出FLASH里的数据，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char ch[1000];</span><br><span class="line">os_printf(<span class="string">&quot;login.page!\n&quot;</span>);</span><br><span class="line">spi_flash_read(0x6C000, (uint32 *)&amp;ch, 654);</span><br><span class="line">ch[655] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">os_printf(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">os_printf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>在串口助手中可以看到输出结果，如果文件格式不是UTF-8，则串口助手输出的中文就会是乱码。如果页面代码中有错误码，也能查出来。同时修改上面的数字大小也能测出页面包含的字节数。这个字节数会用于页面的发送。测试结果</p><p>可以看出数据没有问题，保证了在FLASH中的页面数据没有问题。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/105232494">ESP8266学习-内置网页配置（一）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP8266内置网页配置</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/tags/ESP8266/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
  </entry>
  
  <entry>
    <title>自制F1C200S demo板</title>
    <link href="https://zml3589110.github.io/posts/2989473239.html"/>
    <id>https://zml3589110.github.io/posts/2989473239.html</id>
    <published>2025-09-10T07:51:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、电路"><a href="#一、电路" class="headerlink" title="一、电路"></a>一、电路</h1><ul><li>具备FLASH下载，TF卡座，摄像头，LCD，MIC，UART等</li></ul><h2 id="一、原理图：如需PDF源文件可到资源下载。"><a href="#一、原理图：如需PDF源文件可到资源下载。" class="headerlink" title="一、原理图：如需PDF源文件可到资源下载。"></a>一、原理图：如需PDF源文件可到资源下载。</h2><p><a href="https://oshwhub.com/AI_QY/f1c100s_1">原理图资料</a></p><img src="/posts/2989473239/a5e8331f42cc6551eac8403725716d39.png" class="" title="img"><img src="/posts/2989473239/4b63a90eafd334ce1bf724bddb06b89b.png" class="" title="img"><h2 id="二、电路：如需PDF源文件可到资源下载。"><a href="#二、电路：如需PDF源文件可到资源下载。" class="headerlink" title="二、电路：如需PDF源文件可到资源下载。"></a>二、电路：如需PDF源文件可到资源下载。</h2><img src="/posts/2989473239/1cf8dfb59ba44ccc0a63ab7bb516d98a.png" class="" title="img"><img src="/posts/2989473239/f4dd572283b5db780ac8b8f2ed37cda7.png" class="" title="img"><h2 id="三、实物"><a href="#三、实物" class="headerlink" title="三、实物"></a>三、实物</h2><img src="/posts/2989473239/387da10619629c5bdc3f5e86ba60fb18.png" class="" title="img"><img src="/posts/2989473239/5868d90b3567d2b1c7df1b6916d638ae.png" class="" title="img"><h1 id="二、Win上测试"><a href="#二、Win上测试" class="headerlink" title="二、Win上测试"></a>二、Win上测试</h1><p>此次测试的目的是尝试使用USB给NorFlash烧录镜像。</p><h2 id="1、安装USB驱动。使用的操作系统是win8。"><a href="#1、安装USB驱动。使用的操作系统是win8。" class="headerlink" title="1、安装USB驱动。使用的操作系统是win8。"></a>1、安装USB驱动。使用的操作系统是win8。</h2><p>在网上下载zadig-2.3.exe。接入设备后，会产生未知设备。然后进行如图操作即可。</p><img src="/posts/2989473239/ceb654f5e3cc3026636ea6cc177cee5c.png" class="" title="img"><h2 id="2、使硬件进入fel模式。"><a href="#2、使硬件进入fel模式。" class="headerlink" title="2、使硬件进入fel模式。"></a>2、使硬件进入fel模式。</h2><p>在FLASH和TF卡都没有系统或为空时，插电即可进入fel模式。如果没有进入，则</p><p>若FLASH中有系统，需通过：短接FLASH芯片的1、4两脚，即按住开发板上boot按键，重新拔插USB或电源开关重新开关一次，即可进入fel模式。</p><h2 id="3、刷机"><a href="#3、刷机" class="headerlink" title="3、刷机"></a>3、刷机</h2><ul><li>(1)、在网上下载或我的资源包中下载，用与在windows下刷机的工具。解压到某个文件下。</li></ul><img src="/posts/2989473239/78da5325456f9e0a5952c4c5e4af00b4.png" class="" title="img"><ul><li>(2)、使用win+R或其他方式打开windows命令行窗口</li></ul><p> 首先进入到刷机工具目录：cd C:\Users\Administrator\Downloads\刷机\sunxi-tools-win32_f1_flash</p><p>  查看信息：sunxi-fel.exe ver。我是用的是F1C100S的镜像，也可以驱动F1C200S。</p><p>  查看SPIFLASH信息：sunxi-fel.exe spiflash-info。我的demo板上使用的是32MFLASH，尽管镜像使用的是16MFLASH，也可以进行驱动，理论上只会无法访问后半段FLASH。</p><p>  烧录镜像：sunxi-fel.exe -p spiflash-write 0 sysimage-nor.img 100%。这里我将sysimge-nor.img文件拷贝到sunxi-tools-win32_f1_flash文件夹内。</p><img src="/posts/2989473239/56b6f108417cbc7c297081a304e74b5d.png" class="" title="img"><h2 id="4、运行结果"><a href="#4、运行结果" class="headerlink" title="4、运行结果"></a>4、运行结果</h2><img src="/posts/2989473239/6e49e6c1f8b30c484152108a60c231b1.png" class="" title="img"><h1 id="三、Linux上测试"><a href="#三、Linux上测试" class="headerlink" title="三、Linux上测试"></a>三、Linux上测试</h1><p>原思路即是在Linux系统下，对SPIFLASH进行烧录测试，但遇到了一些问题，导致Linux虚拟机无法识别到该设备。进而产生了上一文档的windows下烧录测试。通过在Windows下烧录测试，也验证了设备烧录、测试、各个文件均没有问题。</p><p>主要导致在Linux下无法测试的问题是：Vbox无法筛选USB设备，导致Linux虚拟机加载不到开发板。</p><p>正确过程：</p><h2 id="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"><a href="#1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN" class="headerlink" title="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"></a>1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN</h2><h2 id="2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html"><a href="#2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html" class="headerlink" title="2、在Vbox里添加增强功能。按照某度经验进行https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html"></a>2、在Vbox里添加增强功能。按照某度经验进行<a href="https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html">https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html</a></h2><h2 id="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"><a href="#3、增强功能安装后，添加筛选器。我这里使用的手动添加。" class="headerlink" title="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"></a>3、增强功能安装后，添加筛选器。我这里使用的手动添加。</h2><img src="/posts/2989473239/90387ee3726d69a3b29bbe5199f51246.png" class="" title="img"><p>筛选参数按照window系统中驱动信息进行填写。</p><img src="/posts/2989473239/c9aa769a65e154ab6c169874bb7b1a87.png" class="" title="img"><img src="/posts/2989473239/3b9ea6465b78d60106599a3b835fd03d.png" class="" title="img"><h2 id="4、打开Linux虚拟机后，进入到命令行模式。"><a href="#4、打开Linux虚拟机后，进入到命令行模式。" class="headerlink" title="4、打开Linux虚拟机后，进入到命令行模式。"></a>4、打开Linux虚拟机后，进入到命令行模式。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line">sudo apt install libz libusb-1.0-0-dev</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">sudo sunxi-fel ver</span><br><span class="line">输出信息：</span><br><span class="line"><span class="string">&quot;AWUSBFEX soc=00001663(F1C100s) 00000001 ver=0001 44 08 scratchpad=00007e00 00000000 00000000&quot;</span></span><br><span class="line">sudo sunxi-fel -l</span><br><span class="line">sudo sunxi-fel -p spiflash-write 0 u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>  查看支持的芯片：sudo sunxi-fel -l。</p><p>  查看开发板信息：sudo sunxi-fel ver。</p><p>  查看SPIFLASH信息：sudo sunxi-fel spiflash-info。</p><p>  烧录镜像到SPIFLASH：sudo sunxi-fel -p spiflash-write 0 Nano_flash_800480.bin 100%。这里使用的是荔枝派的Nano的FLASH。</p><img src="/posts/2989473239/f5874d781e692131970602d2112159f9.png" class="" title="img"><img src="/posts/2989473239/703b2a3d086d8ecdbbaf9ccd795f5760.png" class="" title="img"><h2 id="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"><a href="#5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。" class="headerlink" title="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"></a>5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。</h2><img src="/posts/2989473239/3748a8399b66fad40291531b2f1c688b.png" class="" title="img"><h1 id="四、TF卡启动"><a href="#四、TF卡启动" class="headerlink" title="四、TF卡启动"></a>四、TF卡启动</h1><p>思来想去，发现使用SIPFLASH也不是百分百完美，也终于明白为何最小demo板要首推TF卡启动了。</p><p>主要是现在想学Linux驱动，但使用SPIFLASH就需要用uboot和kernel两个同时打包为一个镜像，这样编译和打包都会影响速度。使用TF卡，就可以把三个板块分开，单独操作而互不干扰。</p><p>这里操作步骤需要摸清楚：1、uboot获取，编译，烧录。2、kernel获取，编译，烧录。3、文件系统搭建。</p><p>获取uboot：git clone <a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a> -b nano-v2018.01&amp;&amp;cd u-boot</p><p>获取时出现的问题：从网上别人博客里是：git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01&amp;&amp;cd u-boot，发现获取不到。</p><p>解决方法：去掉.git后获取正常。</p><p>编译uboot：make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_defconfig</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><p>编译时出现的问题：make: arm-linux-gnueabi-gcc: Command not found。</p><p>解决方法：sudo apt install gcc-arm-linux-gnueabi。</p><p>编译时出现的问题：unable to execute ‘swig’: No such file or directory。</p><p>解决方法：sudo apt install swig。</p><p>编译时出现的问题：scripts&#x2F;dtc&#x2F;pylibfdt&#x2F;libfdt_wrap.c:149:11: fatal error: Python.h: 没有那个文件或目录。</p><p>解决方法：1、查看版本：python -V，2、获取对应文件：sudo apt install python2.7-dev。（这里的2.7要修改为和查看的版本相匹配）</p><p>烧录uboot：sudo dd if&#x3D;u-boot-tf.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</p><p>sudo cp suniv-f1c100s-licheepi-nano.dtb &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝镜像文件：sudo cp tf-zImage &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝文件系统：sudo tar -xvf rootfs-tf.tar.gz -C &#x2F;media&#x2F;one&#x2F;rootfs&#x2F;</p><p>需要将TF卡分成两个区：uboot fat16 64M 和 rootfs ext4 (TF卡剩余所有空间）。</p><p>查看磁盘：sudo fdisk -l  和 查看挂载：df|grep sd</p><p>以上烧录使用的是Lichee-pi-nano的标准文件，并未使用我编译的文件，可以正常运行，输出启动参数。</p><p>经过测试，当SPIFLASH和TF卡里都有系统时，优先运行TF卡中系统。</p><p>在2021年9月16日，终于指导了uboot和Linux等的关联和基本操作了。虽然前面都在串口调试助手上显示了启动信息，但仔细查看，始终没看到运行kernel。今天终于搞明白了，这三大板块放到TF卡中应该正确操作的流程了。</p><p>开机后，串口调试助手上会输出信息，但仅仅是输出uboot的信息，会停留在uboot的命令行。需要在这里使用命令行，配置kernel引导参数，从而执行Linux。</p><p>也可以按照<a href="http://nano.lichee.pro/build_sys/bootargs.html">uboot传递参数 — 荔枝派Nano 全流程指南 documentation</a> 生成一个boot.scr文件，复制到TF卡的第一分区，就能自动运行LINUX，无需再再串口调试助手中输入这些指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">以下是串口调试助手完整输出信息，红色部分则是要人为发送的启动信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.143] RX：</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.311] RX：</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.842] RX：MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.918] RX：*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[2021-09-16 12:03:08.942] RX： 1 </span><br><span class="line">[2021-09-16 12:03:09.943] RX： 0 </span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.006] RX：switch to partitions <span class="comment">#0, OK</span></span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.556] RX：Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.705] RX：reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.773] RX：starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue <span class="string">&#x27;usb start&#x27;</span> first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:12.310] TX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:12.313] RX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:13.539] TX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:13.544] RX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:15.421] TX：load mmc 0:1 0x80008000 zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.424] RX：load mmc 0:1 0x80008000 zImage</span><br><span class="line">reading zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.635] RX：3838016 bytes <span class="built_in">read</span> <span class="keyword">in</span> 194 ms (18.9 MiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:17.540] TX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:17.543] RX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd9e ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:18.737] RX：[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-rc8-licheepi-nano+ (one@one-VirtualBox) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) <span class="comment">#1 Tue Sep 14 17:09:09 CST 2021</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: Lichee Pi Nano</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] random: fast init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 16256</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 8192 (order: 3, 32768 bytes)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 4096 (order: 2, 16384 bytes)</span><br><span class="line">[    0.000000] Memory: 55172K/65536K available (6144K kernel code, 236K rwdata, 1388K rodata, 1024K init, 244K bss, 10364K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] Virtual kernel memory layout:</span><br><span class="line">[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class="line">[    0.000000]     fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class="line">[    0.000000]     vmalloc : 0xc4800000 - 0xff800000   ( 944 MB)</span><br><span class="line">[    0.000000]     lowmem  : 0xc0000000 - 0xc4000000   (  64 MB)</span><br><span class="line">[    0.000000]     pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)</span><br><span class="line">[    0.000000]     modules : 0xbf000000 - 0xbfe00000   (  14 MB)</span><br><span class="line">[    0.000000]       .text : 0x(ptrval) - 0x(ptrval)   (7136 kB)</span><br><span class="line">[    0.000000]       .init : 0x(ptrval) - 0x(ptrval)   (1024 kB)</span><br><span class="line">[    0.000000]       .data : 0x(ptrval) - 0x(ptrval)   ( 237 kB)</span><br><span class="line">[    0.000000]        .bss : 0x(ptrval) - 0x(ptrval)   ( 245 kB)</span><br><span class="line">[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span><br><span class="line">[    0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16</span><br><span class="line">[    0.000044] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns</span><br><span class="line">[    0.000107] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns</span><br><span class="line">[    0.000634] Console: colour dummy device 80x30</span><br><span class="line">[    0.001547] console [tty0] enabled</span><br><span class="line">[    0.001649] Calibrating delay loop... 203.16 BogoMIPS (lpj=1015808)</span><br><span class="line">[    0.070270] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.070605] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.070691] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.072128] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.073790] Setting up static identity map <span class="keyword">for</span> 0x80100000 - 0x80100058</span><br><span class="line">[    0.076353] devtmpfs: initialized</span><br><span class="line">[    0.082594] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns</span><br><span class="line">[    0.082753] futex <span class="built_in">hash</span> table entries: 256 (order: -1, 3072 bytes)</span><br><span class="line">[    0.083054] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.085012] NET: Registered protocol family 16</span><br><span class="line">[    0.086414] DMA: preallocated 256 KiB pool <span class="keyword">for</span> atomic coherent allocations</span><br><span class="line">[    0.088228] cpuidle: using governor menu</span><br><span class="line">[    0.112653] SCSI subsystem initialized</span><br><span class="line">[    0.113054] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.113256] usbcore: registered new interface driver hub</span><br><span class="line">[    0.113505] usbcore: registered new device driver usb</span><br><span class="line">[    0.113994] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.114073] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.114196] PTP clock support registered</span><br><span class="line">[    0.114675] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.116219] clocksource: Switched to clocksource timer</span><br><span class="line">[    0.141314] NET: Registered protocol family 2</span><br><span class="line">[    0.142762] TCP established <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.142912] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143002] TCP: Hash tables configured (established 1024 <span class="built_in">bind</span> 1024)</span><br><span class="line">[    0.143302] UDP <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143408] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143903] NET: Registered protocol family 1</span><br><span class="line">[    0.145154] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.145261] RPC: Registered udp transport module.</span><br><span class="line">[    0.145309] RPC: Registered tcp transport module.</span><br><span class="line">[    0.145352] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.147636] NetWinder Floating Point Emulator V0.97 (double precision)</span><br><span class="line">[    0.149450] Initialise system trusted keyrings</span><br><span class="line">[    0.150062] workingset: timestamp_bits=30 max_order=14 bucket_order=0</span><br><span class="line">[    0.167180] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.167334] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.167393] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.180354] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.180460] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.180692] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)</span><br><span class="line">[    0.180785] io scheduler noop registered</span><br><span class="line">[    0.180833] io scheduler deadline registered</span><br><span class="line">[    0.181596] io scheduler cfq registered (default)</span><br><span class="line">[    0.181690] io scheduler mq-deadline registered</span><br><span class="line">[    0.181743] io scheduler kyber registered</span><br><span class="line">[    0.182841] sun4i-usb-phy 1c13400.phy: Couldn<span class="string">&#x27;t request ID GPIO</span></span><br><span class="line"><span class="string">[    0.192424] suniv-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver</span></span><br><span class="line"><span class="string">[    0.354497] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled</span></span><br><span class="line"><span class="string">[    0.361118] console [ttyS0] disabled</span></span><br><span class="line"><span class="string">[    0.381429] 1c25000.serial: ttyS0 at MMIO 0x1c25000 (irq = 23, base_baud = 6250000) is a 16550A</span></span><br><span class="line"><span class="string">[    0.852908] console [ttyS0] enabled</span></span><br><span class="line"><span class="string">[    0.863244] panel-simple panel: panel supply power not found, using dummy regulator</span></span><br><span class="line"><span class="string">[    0.872677] SCSI Media Changer driver v0.25 </span></span><br><span class="line"><span class="string">[    0.880398] m25p80 spi0.0: found w25q256, expected w25q128</span></span><br><span class="line"><span class="string">[    0.886477] m25p80 spi0.0: w25q256 (32768 Kbytes)</span></span><br><span class="line"><span class="string">[    0.893635] ehci_hcd: USB 2.0 &#x27;</span>Enhanced<span class="string">&#x27; Host Controller (EHCI) Driver</span></span><br><span class="line"><span class="string">[    0.900355] ehci-platform: EHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.905917] ohci_hcd: USB 1.1 &#x27;</span>Open<span class="string">&#x27; Host Controller (OHCI) Driver</span></span><br><span class="line"><span class="string">[    0.912272] ohci-platform: OHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.918003] usbcore: registered new interface driver usb-storage</span></span><br><span class="line"><span class="string">[    0.924980] udc-core: couldn&#x27;</span>t find an available UDC - added [g_cdc] to list of pending drivers</span><br><span class="line">[    0.934113] i2c /dev entries driver</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.352] RX：[    0.996353] sunxi-mmc 1c0f000.mmc: base:0x0db647ea irq:19</span><br><span class="line">[    1.003836] usbcore: registered new interface driver usbhid</span><br><span class="line">[    1.009596] usbhid: USB HID core driver</span><br><span class="line">[    1.031128] NET: Registered protocol family 17</span><br><span class="line">[    1.035884] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    1.042602] Loading compiled-in X.509 certificates</span><br><span class="line">[    1.058564] sun4i-drm display-engine: bound 1e60000.display-backend (ops 0xc0739498)</span><br><span class="line">[    1.067512] sun4i-drm display-engine: bound 1c0c000.lcd-controller (ops 0xc073877c)</span><br><span class="line">[    1.075259] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013).</span><br><span class="line">[    1.082015] [drm] No driver support <span class="keyword">for</span> vblank timestamp query.</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.511] RX：[    1.138455] Console: switching to colour frame buffer device 60x34</span><br><span class="line">[    1.140705] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.142989] mmc0: new high speed SDHC card at address 59b4</span><br><span class="line">[    1.144075] mmcblk0: mmc0:59b4 SD    15.0 GiB </span><br><span class="line">[    1.146386]  mmcblk0: p1 p2</span><br><span class="line">[    1.208313] sun4i-drm display-engine: fb0:  frame buffer device</span><br><span class="line">[    1.227575] [drm] Initialized sun4i-drm 1.0.0 20150629 <span class="keyword">for</span> display-engine on minor 0</span><br><span class="line">[    1.249110] usb_phy_generic usb_phy_generic.0.auto: usb_phy_generic.0.auto supply vcc not found, using dummy regulator</span><br><span class="line">[    1.279822] musb-hdrc musb-hdrc.1.auto: MUSB HDRC host driver</span><br><span class="line">[    1.298514] musb-hdrc musb-hdrc.1.auto: new USB bus registered, assigned bus number 1</span><br><span class="line">[    1.321574] hub 1-0:1.0: USB hub found</span><br><span class="line">[    1.332130] hub 1-0:1.0: 1 port detected</span><br><span class="line">[    1.344233] using random self ethernet address</span><br><span class="line">[    1.355304] using random host ethernet address</span><br><span class="line">[    1.367912] usb0: HOST MAC 96:a7:62:ad:40:54</span><br><span class="line">[    1.378730] usb0: MAC 32:68:5e:ee:7c:4e</span><br><span class="line">[    1.389004] g_cdc gadget: CDC Composite Gadget, version: King Kamehameha Day 2008</span><br><span class="line">[    1.408933] g_cdc gadget: g_cdc ready</span><br><span class="line">[    1.419690] cfg80211: Loading compiled-in X.509 certificates <span class="keyword">for</span> regulatory database</span><br><span class="line">[    1.449709] cfg80211: Loaded X.509 cert <span class="string">&#x27;sforshee: 00b28ddf47aef9cea7&#x27;</span></span><br><span class="line">[    1.468828] ALSA device list:</span><br><span class="line">[    1.478044]   <span class="comment">#0: Loopback 1</span></span><br><span class="line">[    1.487901] platform regulatory.0: Direct firmware load <span class="keyword">for</span> regulatory.db failed with error -2</span><br><span class="line">[    1.508671] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.521906] EXT4-fs (mmcblk0p2): couldn<span class="string">&#x27;t mount as ext3 due to feature incompatibilities</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.009] RX：[    1.653047] EXT4-fs (mmcblk0p2): recovery complete</span></span><br><span class="line"><span class="string">[    1.669691] EXT4-fs (mmcblk0p2): mounted filesystem with ordered data mode. Opts: (null)</span></span><br><span class="line"><span class="string">[    1.690011] VFS: Mounted root (ext4 filesystem) on device 179:2.</span></span><br><span class="line"><span class="string">[    1.710548] devtmpfs: mounted</span></span><br><span class="line"><span class="string">[    1.724192] Freeing unused kernel memory: 1024K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.248] RX：[    1.892543] EXT4-fs (mmcblk0p2): re-mounted. Opts: data=ordered</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.361] RX：Starting logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.403] RX：OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.483] RX：Initializing random number generator... </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.591] RX：done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.710] RX：</span></span><br><span class="line"><span class="string">Welcome to Lichee Pi</span></span><br><span class="line"><span class="string">Lichee login: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.235] TX：root</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.239] RX：root</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.220] TX：licheepi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.224] RX：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.283] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.020] TX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.025] RX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.148] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.212] RX：Saving random seed... done.</span></span><br><span class="line"><span class="string">Stopping logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.275] RX：OK</span></span><br><span class="line"><span class="string">umount: devtmpfs busy - remounted read-only</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.403] RX：[   11.047017] EXT4-fs (mmcblk0p2): re-mounted. Opts: (null)</span></span><br><span class="line"><span class="string">The system is going down NOW!</span></span><br><span class="line"><span class="string">Sent SIGTERM to all processes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:30.425] RX： Sent SIGKILL to all processes</span></span><br><span class="line"><span class="string">Requesting system poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:31.428] RX：[   13.072847] reboot: System halted</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="五、Linux初学1"><a href="#五、Linux初学1" class="headerlink" title="五、Linux初学1"></a>五、Linux初学1</h1><p>1、获取源码；2、编译源码；3、烧录可执行文件；4、显示效果</p><p>一直在了解源码，但怎么都学不会，直到现在也没能在屏幕上输出个hello world。现在想要在自己的板上，一步一步学习使用。第一件事就是把别人做好的源码进行编译输出个东西，然后再去修改。</p><h2 id="一、u-boot"><a href="#一、u-boot" class="headerlink" title="一、u-boot"></a>一、u-boot</h2><p>1、获取源码<br>git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01</p><p>2、生成配置文件</p><ul><li><p>如果需要生成在sdram里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_defconfig</p></li><li><p>如果需要生成在spiflash里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_spiflash_defconfig</p></li></ul><p>3、编译</p><ul><li>make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12</li></ul><h2 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h2><p>1、获取源码：</p><p>git clone –depth&#x3D;1 -b f1c100s-480272lcd-test <a href="https://github.com/Icenowy/linux.git">https://github.com/Icenowy/linux.git</a></p><p>不知道为何我克隆时，上面.git后缀必须要去掉。</p><p>wget <a href="http://dl.sipeed.com/LICHEE/Nano/SDK/config">http://dl.sipeed.com/LICHEE/Nano/SDK/config</a></p><p>mv config .config</p><p>2、编译源码：</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><h2 id="三、烧录可执行文件："><a href="#三、烧录可执行文件：" class="headerlink" title="三、烧录可执行文件："></a>三、烧录可执行文件：</h2><p>编译完成后将linux&#x2F;arch&#x2F;arm&#x2F;boot下的“zImage”文件和linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts下的“suniv-f1c100s-licheepi-nano.dtb”文件拷贝到TF卡第一分区。</p><p>在第一分区中放入boot.scr文件。其他按照前面文章进行即可运行。</p><h2 id="四、显示效果："><a href="#四、显示效果：" class="headerlink" title="四、显示效果："></a>四、显示效果：</h2><p>串口调试助手会输出运行信息，界面也会显示信息。在串口调试助手上可以使用Linux命令进行基本操作。</p><p>使用的是800x480的屏，但Linux配置的是480x272的显示，因此显示不是全屏。这也变成了后期学习的一点。</p><img src="/posts/2989473239/30e2c79f8392e1c8392cade7396bee20.png" class="" title="img"><h1 id="六、裸机寄存器点灯"><a href="#六、裸机寄存器点灯" class="headerlink" title="六、裸机寄存器点灯"></a>六、裸机寄存器点灯</h1><p>按照《嵌入式Linux应用开发 完全手册》，了解寄存器的操作，编译流程，硬件执行流程。</p><h2 id="1、修改LED源码"><a href="#1、修改LED源码" class="headerlink" title="1、修改LED源码"></a>1、修改LED源码</h2><p>按照书上编辑修改LED源代码：其中寄存器地址与IO偏移按照芯片手册和电路实际IO进行修改。我的电路使用PA0、PA1作为按键输入，PA2、PA3作为LED输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File led_on_c.c</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_CFG0(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x00)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_DAT(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x10)))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT33</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT0));<span class="comment">//PA0 in</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT1));<span class="comment">//PA1 in</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT2));<span class="comment">//PA2 clear</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT3));<span class="comment">//PA3 clear</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT2);<span class="comment">//PA2 out</span></span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT3);<span class="comment">//PA3 out</span></span><br><span class="line"> </span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT2);<span class="comment">//PA2 reset</span></span><br><span class="line">delay();</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">delay();</span><br><span class="line"><span class="keyword">if</span>((PA_DAT &amp; (<span class="number">0x1</span> &lt;&lt; BIT0)) != <span class="number">0x0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT3);<span class="comment">//PA3 reset</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// about 408ms when CPU_CLK_SRC uses OSC24M</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">__asm <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; ldr r0, =76480\n&quot;</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; loop:cmp r0,#0\n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; beq exit \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; sub r0,r0,#1 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; b loop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot;exit:nop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、编写start-s文件，makefile文件"><a href="#2、编写start-s文件，makefile文件" class="headerlink" title="2、编写start.s文件，makefile文件"></a>2、编写start.s文件，makefile文件</h2><p>原本按照书上编写了start.s文件，makefile文件，但经过多次尝试后发现书上的不能照抄。在网上查资料，发现全志的芯片需要一个tools工具，能够将代码端放到指定位置，以及各种初始化。从网上下载源码后，发现其中有F1C100.s对应了书上的start.s。但并不能按照书上简单组合，还需要各种辅助文件。文件已上传在我的资源中。</p><img src="/posts/2989473239/4cbeacf8920f070734f393a22043e28f.png" class="" title="img"><h2 id="3、编译后，烧写到SD卡，运行效果"><a href="#3、编译后，烧写到SD卡，运行效果" class="headerlink" title="3、编译后，烧写到SD卡，运行效果"></a>3、编译后，烧写到SD卡，运行效果</h2><img src="/posts/2989473239/5c768d84974c935a5e386ffc5c94ea0f.png" class="" title="img"><p>这个灯在500ms闪烁。按住PA0，会使PA3点亮。</p><p>参考：<a href="https://www.bilibili.com/read/cv9477324">【荔枝派Nano】F1C100S的boothead和BROM - 哔哩哔哩</a></p><h1 id="七、Linux初学2"><a href="#七、Linux初学2" class="headerlink" title="七、Linux初学2"></a>七、Linux初学2</h1><p>1、uboot移植、修改LED灯；2、学习uboot代码；3、阅读代码的取巧方法</p><h2 id="1、uboot移植"><a href="#1、uboot移植" class="headerlink" title="1、uboot移植"></a>1、uboot移植</h2><p>认知：使用uboot指令控制LED灯，在uboot&#x2F;cmd文件中找到led指令文件，在uboot&#x2F;cmd&#x2F;makefile文件中查看是否链接led指令文件，如果未链接则需要添加。原有添加方式中需要判断UBOOT_CMD_LED的值，需要在uboot&#x2F;.config中设置UBOOT_CMD_LED&#x3D;y，将led指令文件编译连接到指令中。</p><p>编译后，下载到demo板，打开串口调试工具，输入help指令，可以看到有led指令，在输入了的指令，可以看到介绍，对比介绍与led指令文件中一致，表示指令过程正确。</p><p>但现在的指令不能执行硬件动作，猜测需要修改驱动和设备树，以支持led设备。</p><h2 id="2、学习uboot代码"><a href="#2、学习uboot代码" class="headerlink" title="2、学习uboot代码"></a>2、学习uboot代码</h2><p>利用正确的Uboot代码，输出信息到串口调试助手：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[20:57:46.566]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[20:57:46.926]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)preloader_console_init\spl.c</span><br><span class="line">DRAM: 64 MiBsunxi_board_init\board.c</span><br><span class="line">Trying to boot from MMC1boot_from_devices\spl.c</span><br><span class="line"></span><br><span class="line">[20:57:47.096]收←◆</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner TechnologyU_BOOT_VERSION_STRING\version.h  display_options_get_banner_priv\display_options.c</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)print_cpuinfo\cpu_info.c</span><br><span class="line">Model: Lichee Pi Nanoshow_board_info\board_info.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DRAM:  64 MiBannounce_dram_init+show_dram_config\board_f.c+display_options.c</span><br><span class="line"></span><br><span class="line">[20:57:47.628]收←◆MMC:   SUNXI SD/MMC: 0initr_mmc+mmc_initialize+print_mmc_devices\board_r.c+mmc.c+mmc_legasy.c</span><br><span class="line"></span><br><span class="line">[20:57:47.706]收←◆*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">__led_init: failed requesting GPIO0!</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[20:57:48.734]收←◆ 1 </span><br><span class="line">[20:57:49.735]收←◆ 0 </span><br><span class="line"></span><br><span class="line">[20:57:49.798]收←◆switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[20:57:50.345]收←◆Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[20:57:50.489]收←◆reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"><span class="symbol">4393 </span>bytes <span class="keyword">read</span> in <span class="number">25</span> ms (<span class="number">170.9</span> KiB/s)</span><br><span class="line"></span><br><span class="line">[20:57:50.561]收←◆starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue &#x27;usb start&#x27; first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure><p>然后按照这个输出信息，一条一条找到执行位置，上面标红为函数接口，蓝色为接口所在源文件。</p><img src="/posts/2989473239/10cdaf8614a42f1d79e87f6a0000ba29.png" class="" title="img"><p>屏蔽以上代码后，下面的输出信息依旧存在，表示下面的输出信息位于执行borad_init_f()之前。</p><img src="/posts/2989473239/0f737d68dc200a9f2776188a7cd996d1.png" class="" title="img"><p>在指定位置添加调试信息，发现以下部分信息属于borad_init_f()内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">++++++++</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br></pre></td></tr></table></figure><p>这之后的信息属于board_init_r()内。</p><p><strong>前几天不是纠结uboot中函数在何处调用问题吗，今天找到一个笨办法了，就是把函数本身名修改成另一个，然后再编译，就会提示哪个位置有错误或警告，那就是被调用位置呐。****阅读代码的取巧方法。</strong></p><p>使用上述方法后终于找到了所有输出信息对应的位置。</p><img src="/posts/2989473239/3d5bb221c3db83abc167c2220fc285b1.png" class="" title="img"><p>时发现了这个BUG，就是代码是灰色的，但是却是会执行的。下一步是想办法控制LED亮灭。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119389552">自制F1C200S demo板（一、电路）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119393266">自制F1C200S demo板（二、Win上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119460667">自制F1C200S demo板（三、Linux上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120074618">自制F1C200S demo板（四、TF卡启动）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120291080">自制F1C200S demo板（五、Linux初学1）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/121530962">自制F1C200S demo板（六、裸机寄存器点灯）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120330444">自制F1C200S demo板（七、Linux初学2）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C200S demo板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="demo板" scheme="https://zml3589110.github.io/tags/demo%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>f1c100sf1c200s 裸机程序</title>
    <link href="https://zml3589110.github.io/posts/931990122.html"/>
    <id>https://zml3589110.github.io/posts/931990122.html</id>
    <published>2025-09-10T07:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.277Z</updated>
    
    <content type="html"><![CDATA[<p>整理了F1C200S的裸机学习过程，只实现了一些基础的应用。<br>直接上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/F1C200S.git</span><br></pre></td></tr></table></figure><p>使用make构建工程，编译工具 arm-none-eab-gcc 10.3 下载使用XBOOT 大神的 xfel<br>详细编译说明readme.md ：<a href="https://gitee.com/dmcus/F1C200S/blob/master/README.md">https://gitee.com/dmcus/F1C200S/blob/master/README.md</a></p><p>没接触过make构建的参考学习例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/makefile-notes</span><br></pre></td></tr></table></figure><p>开发板使用：LC-PI-200S Board CherryPi ,其他开发板未测试，请根据实际情况调整代码。</p><p>已实现功能：<br>外设：        GPIO I2C SPI UART USB-CDC DISPLAY SD<br>移植其他开源库： SFUD LVGL8 LVGL9 FatFs infoNes VNes CherryUSB-CDC<br>外围设备：     GT911 24C02 W25Q128<br>RTOS:        RT-Thread 4.1 原版本使用scons构建，主要添加Makfe构建，移植RT-Thread Studio自动生成的代码。</p><p>暂未实现：音频、视频编解码、摄像头、麦克。</p><p>bootloader下载到flash 地址0，例子下载到 0x10000地址，运行后会拷贝到 DRAM 中运行，串口打印使用UART1。</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">doc  ------文档和原理图 使用LCPI F1C200S 开发板 集成CH340E -&gt; UART1</span><br><span class="line">sources ---源码</span><br><span class="line">    |bootloader -----SPL 烧录FLASH 0,log 使用 UART1</span><br><span class="line">    |drivers---------f1c200s驱动</span><br><span class="line">    |fc200s_brom ----sram运行的独立程序 烧录FLASH 0 支持串口</span><br><span class="line">    |examples--------peripherals examples 外设样例，裸机程序 使用LCPI F1C200S 开发板</span><br><span class="line">    |mksunxi --------.bin文件添加校验头工具</span><br><span class="line">    |rtt-------------rt-thread 烧录到FLASH 0X10000 log 使用 UART1</span><br><span class="line">tools -----make 工具 添加到环境变量</span><br><span class="line">1.bootload下载</span><br><span class="line"> cd sources&#x2F;bootloader</span><br><span class="line">   make all</span><br><span class="line">   make download</span><br><span class="line"> </span><br><span class="line">2.i2c uart gpio 等例子编译下载</span><br><span class="line">  cd sources&#x2F;examples&#x2F;uart</span><br><span class="line">  make all</span><br><span class="line">  make download</span><br></pre></td></tr></table></figure><p>感谢大神们的无私奉献，主要参考以下开源工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nminaylov&#x2F;F1C100s_projects.git</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;lhdjply&#x2F;f1c200s_library</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;VeiLiang&#x2F;BoloRTT.git</span><br></pre></td></tr></table></figure><hr><p>这个包里有个make download，因为我没有编译成功linux下的sunsi，所以我用windows的sunxi-fel下载到芯片，但串口没有任何响应，请问我的操作是否有误？</p><p>window 下操作，linux没测试过。需要先编译下载bootloader到 flash 0 ，然后下载例子到 flash 0x10000。串口使用的是 UART1输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download:$(BIN)</span><br><span class="line">    ifeq ($(TARGET),bootloader)</span><br><span class="line">xfel spinor write 0 $(BIN)</span><br><span class="line">    else</span><br><span class="line">xfel spinor write 0x10000 $(BIN)</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11525.html">f1c100s&#x2F;f1c200s 裸机程序。</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</title>
    <link href="https://zml3589110.github.io/posts/246263880.html"/>
    <id>https://zml3589110.github.io/posts/246263880.html</id>
    <published>2025-09-10T07:41:20.000Z</published>
    <updated>2025-09-10T13:10:14.184Z</updated>
    
    <content type="html"><![CDATA[<p>原始工程使用f1c100s&#x2F;f1c200s 裸机程序，参见 <a href="https://whycan.com/t_11525.html">https://whycan.com/t_11525.html</a></p><p>工程构建：make<br>操作系统：windows</p><p>FreeRTOS没有ARM9的例子，ARM7和ARM9内核很相似，主要参考ARM7_LPC2000 移植。</p><p>FreeRTOS源码下载：<br>哇酷下载：<a href="https://whycan.com/files/members/15085/RTOS-KernelV11.1.0.zip">RTOS-KernelV11.1.0.zip</a><br>github下载：<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/releases">https://github.com/FreeRTOS/FreeRTOS-Kernel/releases</a></p><p>一、文件目录结构搭建</p><p>1.解压重命名为FreeRTOS ，新建文件夹port</p><p>2.复制 FreeRTOS&#x2F;portable&#x2F;GCC&#x2F;ARM7_LPC2000 下 port.c portISR.c portmacro.h 到 port目录下</p><p>3.复制FreeRTOS&#x2F;portable&#x2F;MemMang 到FreeRTOS&#x2F;MemMang</p><p>4.复制 FreeRTOS&#x2F;examples&#x2F;template_configuration&#x2F;FreeRTOSConfig.h 到 include目录下</p><p>\5. 删除examples portable 文件夹。完成后的目录结构如下</p><img src="/posts/246263880/rtpng.png" class="" title="目录结构"><p>移植过程：</p><p>添加FreeRTOS 中断，修改工程文件 vectors.S，定义宏 <strong>USE_FREERTOS</strong> ， 修改 _software_interrupt 和 _irq 两个中断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*任务切换*&#x2F; </span><br><span class="line">_software_interrupt: </span><br><span class="line">#if defined (USE_FREERTOS)</span><br><span class="line">    .word vPortYieldProcessor</span><br><span class="line">#else</span><br><span class="line">    .word software_interrupt</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*系统嘀嗒心跳*&#x2F; </span><br><span class="line">_irq:</span><br><span class="line">#if defined (USE_FREERTOS) </span><br><span class="line">    .word vFreeRTOS_ISR</span><br><span class="line">#else</span><br><span class="line">    .word irq</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>port.c 和 portISR.c ，添加定时器初始化和定时器中断切换任务功能</p><p>port.c 添加头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;f1c100s_timer.h&quot;</span><br><span class="line">#include &quot;f1c100s_intc.h&quot;</span><br></pre></td></tr></table></figure><p>定时器time0初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Setup the timer 0 to generate the tick interrupts at the required frequency.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void prvSetupTimerInterrupt(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void vTickISR(void); </span><br><span class="line"> </span><br><span class="line">    tim_init(TIM0, TIM_MODE_CONT, TIM_SRC_HOSC, TIM_PSC_1);</span><br><span class="line">    tim_set_period(TIM0, 24000000UL&#x2F;1000UL);&#x2F;&#x2F;1ms中断</span><br><span class="line">    tim_int_enable(TIM0); </span><br><span class="line">    intc_set_irq_handler(IRQ_TIMER0, vTickISR); </span><br><span class="line">    intc_enable_irq(IRQ_TIMER0); </span><br><span class="line">    tim_start(TIM0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 接管所有的中断，添加上下文切换保存和恢复，添加naked属性，禁用编译器上下文管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*__attribute__((naked)) 很关键 不加调度</span><br><span class="line"> *使用naked属性可以告诉编译器不生成函数的prologue和epilogue代码，</span><br><span class="line"> *这样任务切换函数可以自行管理寄存器的入栈和恢复，从而简化上下文管理*&#x2F;</span><br><span class="line">void vFreeRTOS_ISR(void) __attribute__((naked));</span><br><span class="line">void vFreeRTOS_ISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void irq_handler(void);</span><br><span class="line">    &#x2F;* Save the context of the interrupted task. *&#x2F;</span><br><span class="line">    portSAVE_CONTEXT();</span><br><span class="line">    &#x2F;* irq all*&#x2F;</span><br><span class="line">    irq_handler();</span><br><span class="line">    &#x2F;* Restore the context of the new task. *&#x2F;</span><br><span class="line">    portRESTORE_CONTEXT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 系统嘀嗒中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef write32</span><br><span class="line">#define write32(x, y) (*((volatile uint32_t *)(x)) &#x3D; y)</span><br><span class="line">#endif</span><br><span class="line">#include &quot;task.h&quot;</span><br><span class="line">void vTickISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* Increment the RTOS tick count, then look for the highest priority</span><br><span class="line">     * task that is ready to run. *&#x2F;</span><br><span class="line">    if (xTaskIncrementTick() !&#x3D; pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskSwitchContext();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Ready for the next interrupt. *&#x2F;</span><br><span class="line">    write32((0x01C20C00) + 0x04, (1 &lt;&lt; 0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 添加 堆栈溢出 回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void vApplicationStackOverflowHook(TaskHandle_t xTask,</span><br><span class="line">                                   char *pcTaskName)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;statck over flow:%s&quot;,pcTaskName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeRTOSConfig.h 修改heap大小 和 位宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define configTOTAL_HEAP_SIZE                        512*1024</span><br><span class="line">#define configTICK_TYPE_WIDTH_IN_BITS              TICK_TYPE_WIDTH_32_BITS</span><br></pre></td></tr></table></figure><p>makefile 添加 <strong>CFLAGS+&#x3D;-DUSE_FREERTOS</strong><br>至此移植完成。</p><p>gcc和xfel：<br>usb下载工具 xfel 和USB驱动下载： <a href="https://github.com/xboot/xfel/releases/download/v1.3.2/xfel-windows-v1.3.2.7z">xfel-v1.3.2</a><br>gcc：<a href="https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C">arm-none-eab-gcc-10.3</a><br>make rm工具在工程目录下</p><p>完整移植好的FreeRTOS 11.1工程下载：<a href="https://whycan.com/files/members/15085/F1C200S_FreeRTOS.zip">F1C200S_FreeRTOS.zip</a></p><p>编译: arm-none-eabi-gcc 和xfel添加到环境变量 ，打开cmd命令行 ，进入 F1C200S_FreeRTOS 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br><span class="line">make download</span><br></pre></td></tr></table></figure><hr><p>花了五块验证程序可以用，只是FreeRTOS部分移到自己工程后，切换上下文有点问题。<br>修改汇编里面的中断后成功启动，感谢楼主</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11538.html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</summary>
    
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/categories/FreeRtos/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/tags/FreeRtos/"/>
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>USB转串口芯片</title>
    <link href="https://zml3589110.github.io/posts/4211420882.html"/>
    <id>https://zml3589110.github.io/posts/4211420882.html</id>
    <published>2025-09-10T03:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沁恒"><a href="#沁恒" class="headerlink" title="沁恒"></a>沁恒</h1><h2 id="CH9102X"><a href="#CH9102X" class="headerlink" title="CH9102X"></a>CH9102X</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="CP2102-GMR替换为CH9102X后无法识别USB设备"><a href="#CP2102-GMR替换为CH9102X后无法识别USB设备" class="headerlink" title="CP2102-GMR替换为CH9102X后无法识别USB设备"></a>CP2102-GMR替换为CH9102X后无法识别USB设备</h4><p>我做了两块板子，一块是用CP2102-GMR的，另一块以为货期问题，使用CH9102X作为替换，百度上很多都说<a href="https://bbs.elecfans.com/zhuti_dianlu_1.html">电路</a>不用修改就可以直接替换的，但是使用CP2102的板子能正常被电脑识别，使用CH9102X的板子连接上USB后，系统提示无法识别USB设备描述，安装官方的VCP也是无法识别，下附电路图为CP2102的，CH9102X为直接替换，是需要修改什么电路吗？</p><img src="/posts/4211420882/pYYBAGK1MI6AOJkUAAIpE9sw_p0850.png" class="" title="img"><p>解答:</p><p>如上提示代表USB设备枚举不成功。原理图影响USB识别的原因应该为芯片#6脚在5V供电模式下没有外接退耦电容所致（建议容值104）。手册说明如下所示：</p><img src="/posts/4211420882/1652858167945200.png" class="" title="img"><p>加了电容之后可以识别到了，但是DTR的引脚可以正常控制，RTS引脚控制不了，一直是高电平状态，用调试助手打开关闭也没有效果</p><p>CH9102等第三代USB转串口芯片同时支持VCP和CDC两种驱动模式，如上现象应该是您使用的是CDC串口驱动导致，请更新使用如下VCP驱动即可，驱动链接：<a href="http://www.wch.cn/downloads/CH343SER_EXE.html">http://www.wch.cn/downloads/CH343SER_EXE.html</a>?<br>关于CDC串口和VCP串口等区别，也看下方案中相关说明：<a href="http://www.wch.cn/application/357.html">http://www.wch.cn/application/357.html</a>?</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://bbs.elecfans.com/jishu_2289360_1_1.html">CP2102-GMR替换为CH9102X后无法识别USB设备是为什么？</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">CH9102X沁恒USB转串口芯片</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/categories/CH9102X/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="沁恒" scheme="https://zml3589110.github.io/tags/%E6%B2%81%E6%81%92/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/tags/CH9102X/"/>
    
    <category term="CP2102" scheme="https://zml3589110.github.io/tags/CP2102/"/>
    
  </entry>
  
  <entry>
    <title>DNS自动选择最佳服务器的实战指南</title>
    <link href="https://zml3589110.github.io/posts/2322562202.html"/>
    <id>https://zml3589110.github.io/posts/2322562202.html</id>
    <published>2025-09-09T08:25:20.000Z</published>
    <updated>2025-09-10T13:10:14.372Z</updated>
    
    <content type="html"><![CDATA[<p>简介：DNS，作为互联网的关键服务，负责将域名转换为IP地址以优化网络连接。DNS自动选取功能使系统能根据网络条件选择响应最快的服务器。DNS跳跃（DnsJumper）工具可帮助用户测试和切换到最佳DNS服务器。文章概述了DNS解析过程、服务器选择、缓存机制、优选技术和DnsJumper的使用方法，还讨论了安全性和网络性能改善等实用知识点。</p><img src="/posts/2322562202/350a1c87c7b83de0dc9e8ba252434266.png" class="" title="dns自动选取"><h2 id="1-DNS作用及解析过程"><a href="#1-DNS作用及解析过程" class="headerlink" title="1. DNS作用及解析过程"></a>1. DNS作用及解析过程</h2><h3 id="1-1-DNS定义与作用"><a href="#1-1-DNS定义与作用" class="headerlink" title="1.1 DNS定义与作用"></a>1.1 DNS定义与作用</h3><p>域名系统（Domain Name System, DNS）是互联网的一项核心服务，它负责将人类可读的域名转换为机器可识别的IP地址。DNS的存在使得用户无需记忆复杂的数字序列，而只需要输入易于理解的域名即可访问网站，极大地提高了互联网的易用性。</p><h3 id="1-2-DNS解析过程"><a href="#1-2-DNS解析过程" class="headerlink" title="1.2 DNS解析过程"></a>1.2 DNS解析过程</h3><p>DNS解析过程涉及用户请求域名到获得IP地址的转换，主要步骤如下：</p><ol><li>用户输入域名后，设备首先查询本地缓存是否有对应的域名解析记录。</li><li>若本地缓存未命中，则请求会到达配置的递归DNS服务器。</li><li>递归DNS服务器会启动迭代解析流程，依次查询根域名服务器、顶级域名服务器及权威域名服务器，最终返回目标域名对应的IP地址给用户。</li></ol><p>在整个解析过程中，可能涉及多种缓存机制，以优化响应时间并减轻根服务器的负载</p><h2 id="2-DNS服务器选择与缓存机制"><a href="#2-DNS服务器选择与缓存机制" class="headerlink" title="2. DNS服务器选择与缓存机制"></a>2. DNS服务器选择与缓存机制</h2><h3 id="2-1-DNS服务器的工作原理"><a href="#2-1-DNS服务器的工作原理" class="headerlink" title="2.1 DNS服务器的工作原理"></a>2.1 DNS服务器的工作原理</h3><p>DNS服务器在处理查询请求时主要采用两种方法：递归解析和迭代解析。</p><ul><li><strong>递归解析</strong> ：在这种方式中，当一个DNS解析器（比如，用户的电脑）向DNS服务器发起请求时，如果该服务器没有所请求域名的记录，则会代替请求者去别的DNS服务器查询，直至找到记录并返回给请求者。递归查询对于客户端来说比较简单，因为客户端只需要向一个服务器发出请求，就可以得到最终结果。</li><li><strong>迭代解析</strong> ：这种方式中，DNS服务器不会代替请求者查询，而是返回一个更靠近所查询域名记录的DNS服务器的地址，请求者需要向这个新的地址发出请求。如果新的服务器也无记录，则再次返回另一个地址，如此迭代，直到找到记录为止，或者返回错误信息表示未找到。</li></ul><p>递归解析和迭代解析的对比：</p><ul><li><strong>性能影响</strong> ：递归解析可能导致服务器过载，因为需要为大量请求进行多次查询；而迭代解析将查询工作分散到多个服务器，减轻单个服务器的压力。</li><li><strong>效率</strong> ：递归解析通常更快，因为它为请求者隐藏了查询过程；迭代解析则对客户端的智能程度要求更高。</li><li><strong>实现复杂性</strong> ：递归解析对DNS服务器来说更复杂，因为它需要管理查询状态并可能与多个服务器通信；迭代解析的逻辑相对简单。</li></ul><h4 id="2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色"><a href="#2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色" class="headerlink" title="2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色"></a>2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色</h4><p>DNS系统由多个层级的服务器组成，每个层级的服务器都有其特定的角色和职责：</p><ul><li><strong>根域名服务器</strong> ：它们是DNS层级结构的最顶层，负责解析顶级域名（如.com、.org、.net等）的地址。当本地DNS服务器没有相关记录时，它会首先联系根域名服务器来获取顶级域名服务器的地址。</li><li><strong>顶级域名服务器（TLD）</strong> ：管理着所有二级域名的DNS记录。例如，在请求 <code>google.com </code>时，根域名服务器会提供 <code>.com </code>顶级域名服务器的地址，之后本地DNS服务器将查询发送至 <code>.com </code>顶级域名服务器。</li><li><strong>权威域名服务器</strong> ：这些服务器拥有特定域名的完整数据记录。它们要么是域名注册商提供的，要么是自行管理的。当顶级域名服务器指向了相应的权威服务器后，解析过程便会在这里完成，返回给查询者IP地址或其他相关信息。</li></ul><p>DNS层级结构保证了域名查询的高效和分摊管理责任，通过逐级查询，最终获得准确的IP地址映射信息。</p><h3 id="2-2-DNS缓存机制的原理与作用"><a href="#2-2-DNS缓存机制的原理与作用" class="headerlink" title="2.2 DNS缓存机制的原理与作用"></a>2.2 DNS缓存机制的原理与作用</h3><h4 id="2-2-1-缓存的作用与优势"><a href="#2-2-1-缓存的作用与优势" class="headerlink" title="2.2.1 缓存的作用与优势"></a>2.2.1 缓存的作用与优势</h4><p>DNS缓存是在本地存储域名到IP地址映射记录的过程，这样可以加快后续相同域名查询的速度，并减轻上游DNS服务器的负担。</p><ul><li><strong>减少查询延迟</strong> ：由于缓存记录了之前解析过的域名信息，因此在本地进行快速查询，避免了重复查询整个DNS层级结构的时间损耗。</li><li><strong>降低网络负载</strong> ：缓存减少了对上游服务器的请求，从而减少了网络流量。</li><li><strong>提高系统可靠性</strong> ：在本地有缓存的情况下，即使上游服务器不可用，部分查询也可能得到快速响应。</li></ul><h4 id="2-2-2-缓存过程中的常见问题及解决方案"><a href="#2-2-2-缓存过程中的常见问题及解决方案" class="headerlink" title="2.2.2 缓存过程中的常见问题及解决方案"></a>2.2.2 缓存过程中的常见问题及解决方案</h4><p>尽管缓存机制有很多优点，但也存在一些问题：</p><ul><li><strong>缓存过时问题</strong> ：如果域名记录发生变化，而本地缓存尚未更新，就可能出现解析错误的情况。解决这个问题的一种方法是设置一个合理的缓存超时时间，这样记录在一定时间后会过期，迫使DNS服务器重新从权威服务器获取最新信息。</li><li><strong>缓存污染问题</strong> ：恶意的DNS服务器可能会发送错误的记录到缓存中，导致解析错误。对于这个问题，可以通过验证记录的来源和配置安全的DNS解析器来加强防护。</li><li><strong>缓存策略优化</strong> ：需要针对不同的应用场景和记录类型，制定合理、灵活的缓存策略，以平衡速度与准确性。例如，对于经常变动的网站，可以设置较短的缓存时间，而对于相对稳定的域名，则可以设置较长的缓存时间。</li></ul><p>缓存机制是DNS系统高效运行的关键组成部分，但必须合理管理和优化，以保证其长期稳定提供服务。接下来的章节将进一步探讨与DNS缓存相关的技术细节，包括缓存策略的优化和实际应用中的最佳实践。</p><p>为了更好地理解DNS缓存策略和常见的DNS问题，下文将展示一个具体的DNS服务器配置缓存的代码示例，并进行详细分析。</p><h2 id="3-DNS优选技术与自动选取原理"><a href="#3-DNS优选技术与自动选取原理" class="headerlink" title="3. DNS优选技术与自动选取原理"></a>3. DNS优选技术与自动选取原理</h2><h3 id="3-1-DNS优选技术概述"><a href="#3-1-DNS优选技术概述" class="headerlink" title="3.1 DNS优选技术概述"></a>3.1 DNS优选技术概述</h3><h4 id="3-1-1-测速技术"><a href="#3-1-1-测速技术" class="headerlink" title="3.1.1 测速技术"></a>3.1.1 测速技术</h4><p>DNS优选技术的核心是能够快速准确地为用户选择出响应速度最快、服务质量最佳的DNS服务器。为了实现这一目标，必须先对DNS服务器的响应时间进行准确的测量。</p><p>测速技术可以通过发送查询请求到不同的DNS服务器并记录它们响应的时间来实现。这些时间测量包括但不限于：</p><ul><li><strong>请求时间（RTT）</strong> ：从发出查询请求到收到响应的时间。RTT越低，说明距离客户端越近或处理速度越快。</li><li><strong>丢包率</strong> ：在测试过程中数据包丢失的比例。一个稳定的DNS服务器应具备低丢包率。</li><li><strong>服务质量（QoS）</strong> ：对响应速度和丢包率之外的其他因素的综合评估，如服务器的负载状况。</li></ul><p>现代网络工具如 <code>dig </code>, <code>nslookup </code>, 或专用的DNS测速工具可以用来进行这些测量。实践中，通过编写脚本或使用现成的网络管理工具，可以自动化这一过程并持续监测DNS服务器的性能。</p><h4 id="3-1-2-智能决策算法"><a href="#3-1-2-智能决策算法" class="headerlink" title="3.1.2 智能决策算法"></a>3.1.2 智能决策算法</h4><p>优选技术不仅依赖于准确的测速，还需要智能决策算法来分析测速结果，并据此做出最优的DNS选择。这些算法可以采用不同的策略和参数进行决策，例如：</p><ul><li><strong>加权轮询</strong> ：为每个DNS服务器基于其性能表现赋予不同的权重，然后按照权重进行轮询。</li><li><strong>最快响应优先</strong> ：简单选择最近一次测量中响应最快的服务器。</li><li><strong>自适应算法</strong> ：依据网络状况和历史数据动态调整决策策略。</li></ul><p>智能算法的设计必须考虑各种可能影响DNS查询性能的因素，并且能够适应网络环境的变化。例如，当某个服务器突然变得不可用或响应变慢时，算法需要能够迅速调整，将流量转移到表现更好的服务器上。</p><h3 id="3-2-DNS自动选取机制"><a href="#3-2-DNS自动选取机制" class="headerlink" title="3.2 DNS自动选取机制"></a>3.2 DNS自动选取机制</h3><h4 id="3-2-1-自动选取的实现方式"><a href="#3-2-1-自动选取的实现方式" class="headerlink" title="3.2.1 自动选取的实现方式"></a>3.2.1 自动选取的实现方式</h4><p>DNS自动选取机制主要通过在设备或系统级别实现智能DNS客户端来达成。智能DNS客户端会监听系统的DNS查询请求，并根据优选技术的结果动态地选择最佳DNS服务器进行响应。实现这一机制的基本步骤如下：</p><ol><li><strong>初始化</strong> ：客户端启动时，向多个DNS服务器发送查询请求，收集初步的性能数据。</li><li><strong>监控</strong> ：在正常运行过程中，持续监控所有已知DNS服务器的性能状态。</li><li><strong>决策</strong> ：根据实时或准实时的性能数据，利用决策算法动态选择最优DNS服务器。</li><li><strong>更新</strong> ：当网络条件或性能数据发生变化时，更新DNS选择决策，并通知系统的其余部分。</li></ol><h4 id="3-2-2-自动选取的算法分析"><a href="#3-2-2-自动选取的算法分析" class="headerlink" title="3.2.2 自动选取的算法分析"></a>3.2.2 自动选取的算法分析</h4><p>自动选取算法的效率和效果直接关系到DNS优选技术的成功与否。我们以一个简化的伪代码例子来说明这一算法过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码展示DNS自动选取算法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化权重字典</span></span><br><span class="line">server_weights = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_weights</span>(<span class="params">server_performance</span>):</span></span><br><span class="line">    <span class="comment"># 更新服务器权重</span></span><br><span class="line">    <span class="comment"># 此处省略权重计算的具体逻辑</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> server_performance:</span><br><span class="line">        server_weights[server] = calculate_weight(server_performance[server])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_dns</span>():</span></span><br><span class="line">    <span class="comment"># 根据权重选择DNS服务器</span></span><br><span class="line">    selected_dns = <span class="built_in">max</span>(server_weights, key=server_weights.get)</span><br><span class="line">    <span class="keyword">return</span> selected_dns</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 模拟性能监控更新</span></span><br><span class="line">server_performance = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.4</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.45</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.15</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更新权重</span></span><br><span class="line">update_weights(server_performance)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择最佳DNS</span></span><br><span class="line">best_dns = select_dns()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前最佳DNS服务器为:&quot;</span>, best_dns)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个权重字典 server_weights ，用于存储每个DNS服务器当前的权重。 update_weights 函数根据每个服务器的性能表现来更新权重，而 select_dns 函数则根据当前的权重来选择最佳的DNS服务器。实际应用中， calculate_weight 函数会非常复杂，它需要综合考虑多个性能参数并最终输出权重值。</p><p>值得注意的是，实际的自动选取算法可能还会包含容错逻辑，例如在选择过程中剔除掉响应异常的DNS服务器，或者在所有DNS服务器都表现不佳时提供默认备选方案。</p><p>本章节介绍了DNS优选技术及其背后的测速技术和智能决策算法。同时，深入探讨了DNS自动选取机制的实现方式和关键算法，为下一章节深入分析DnsJumper等软件提供了理论基础。</p><h2 id="4-DnsJumper功能与使用场景"><a href="#4-DnsJumper功能与使用场景" class="headerlink" title="4. DnsJumper功能与使用场景"></a>4. DnsJumper功能与使用场景</h2><p>DnsJumper 是一款小巧的网络工具软件，旨在帮助用户轻松管理和优化 DNS 设置。它不仅支持多种操作系统，还具有友好的用户界面，使得普通用户也能进行专业级别的 DNS 设置。本章节将对 DnsJumper 的功能特性进行深入解析，并分享其在不同使用场景中的实际应用案例。</p><h3 id="4-1-DnsJumper软件介绍"><a href="#4-1-DnsJumper软件介绍" class="headerlink" title="4.1 DnsJumper软件介绍"></a>4.1 DnsJumper软件介绍</h3><h4 id="4-1-1-DnsJumper的功能特性"><a href="#4-1-1-DnsJumper的功能特性" class="headerlink" title="4.1.1 DnsJumper的功能特性"></a>4.1.1 DnsJumper的功能特性</h4><p>DnsJumper 以其轻量级和多功能性著称，它集成了 DNS 测速、切换、备份和恢复等多种功能。这些功能可以在不需要深入了解网络技术的情况下，简单快捷地帮助用户优化网络连接。</p><ul><li><strong>DNS 测速功能</strong> ：通过内置的测速功能，DnsJumper 能够测试多个 DNS 服务器的响应时间，帮助用户找出速度最快的 DNS 服务器进行连接。</li><li><strong>智能 DNS 切换</strong> ：DnsJumper 支持自动选择最佳的 DNS 服务器，采用智能算法根据响应时间进行优化。</li><li><strong>一键备份和恢复</strong> ：软件提供了简单快捷的 DNS 设置备份和恢复功能，确保在出现问题时能快速恢复到稳定状态。</li></ul><h4 id="4-1-2-软件界面与操作流程"><a href="#4-1-2-软件界面与操作流程" class="headerlink" title="4.1.2 软件界面与操作流程"></a>4.1.2 软件界面与操作流程</h4><p>DnsJumper 的用户界面直观明了，即使没有专业知识背景的用户也能快速上手。</p><ol><li><strong>打开 DnsJumper 软件</strong> ：用户可以双击桌面快捷方式或在程序文件夹中找到软件图标来启动 DnsJumper。</li><li><strong>使用测速功能</strong> ：在主界面中，用户可以看到“测试 DNS”按钮，点击之后软件会自动测试网络环境中的 DNS 服务器速度，并将结果以列表形式展示出来。</li><li><strong>切换 DNS</strong> ：用户可以根据测速结果，选择其中响应时间最短的 DNS 服务器，点击“应用”按钮来更改当前系统配置。</li><li><strong>备份与恢复</strong> ：如果用户想要备份当前的 DNS 设置，可以在菜单选项中选择“备份 DNS 设置”，并在需要时通过“恢复 DNS 设置”来还原。</li></ol><h3 id="4-2-DnsJumper的实际应用"><a href="#4-2-DnsJumper的实际应用" class="headerlink" title="4.2 DnsJumper的实际应用"></a>4.2 DnsJumper的实际应用</h3><h4 id="4-2-1-常见使用场景分析"><a href="#4-2-1-常见使用场景分析" class="headerlink" title="4.2.1 常见使用场景分析"></a>4.2.1 常见使用场景分析</h4><p>DnsJumper 的应用非常广泛，下面是几个常见使用场景的详细分析：</p><ul><li><strong>家庭网络优化</strong> ：对于家庭用户来说，使用 DnsJumper 可以有效地解决网络慢、打开网页卡顿等问题。通过简单几步操作，用户就可以找到最适合本地网络环境的 DNS 服务器，从而提高上网速度和稳定性。</li><li><strong>网吧或公共热点</strong> ：在网吧或咖啡厅等公共 Wi-Fi 环境，由于用户量大，DNS 服务器的响应时间可能会延长。使用 DnsJumper 可以帮助管理员快速找到并切换到响应速度更快的 DNS 服务器，改善上网体验。</li><li><strong>跨国办公网络</strong> ：对于跨国公司而言，不同国家和地区的网络环境差异较大。DnsJumper 可以帮助 IT 管理员快速评估和优化各个分支的 DNS 设置，提高办公效率。</li></ul><h4 id="4-2-2-使用DnsJumper进行DNS切换的实际案例"><a href="#4-2-2-使用DnsJumper进行DNS切换的实际案例" class="headerlink" title="4.2.2 使用DnsJumper进行DNS切换的实际案例"></a>4.2.2 使用DnsJumper进行DNS切换的实际案例</h4><p>让我们通过一个案例来看一下如何使用 DnsJumper 来进行 DNS 切换：</p><p>假设你是一名 IT 管理员，在一家拥有多个办公地点的跨国公司工作。某天，你接到报告称，位于纽约的办公室的网络访问速度很慢。为了诊断并解决问题，你决定使用 DnsJumper 进行以下步骤：</p><ol><li><strong>下载并安装 DnsJumper</strong> ：首先，你需要在受影响的办公室的电脑上下载并安装 DnsJumper。</li><li><strong>运行软件并测试 DNS</strong> ：打开 DnsJumper，使用其内置的测速功能来测试当前纽约办公室连接的 DNS 服务器速度。</li><li><strong>分析测试结果</strong> ：将测试结果与全球各大 DNS 服务器的平均响应时间进行比较，寻找是否存在明显的延迟。</li><li><strong>选择最佳 DNS 服务器</strong> ：根据测试数据，选择一个响应时间更短的 DNS 服务器。</li><li><strong>应用更改并监控效果</strong> ：使用 DnsJumper 应用新选的 DNS 服务器，并监控网络速度的提升情况。如果效果良好，则进行长期设置；如果效果不明显，可以尝试测试其他的 DNS 服务器。</li></ol><p>通过本案例可以清晰看到 DnsJumper 如何帮助解决网络性能问题，通过几步简单的操作，便可以大大改善网络访问质量。</p><h2 id="5-网络安全与设置方法"><a href="#5-网络安全与设置方法" class="headerlink" title="5. 网络安全与设置方法"></a>5. 网络安全与设置方法</h2><h3 id="5-1-DNS与网络安全的关系"><a href="#5-1-DNS与网络安全的关系" class="headerlink" title="5.1 DNS与网络安全的关系"></a>5.1 DNS与网络安全的关系</h3><h4 id="5-1-1-DNS劫持与防护措施"><a href="#5-1-1-DNS劫持与防护措施" class="headerlink" title="5.1.1 DNS劫持与防护措施"></a>5.1.1 DNS劫持与防护措施</h4><p>DNS劫持是一种常见的网络安全威胁，攻击者通过篡改DNS服务器的记录，使用户在访问网站时被重定向到恶意网站。这种攻击通常发生在用户访问不安全的网站，或者在用户设备被植入恶意软件的情况下。</p><p>为了防范DNS劫持，用户可以采取以下几种措施： - 使用安全的DNS服务，例如Google Public DNS（8.8.8.8和8.8.4.4）和Cloudflare（1.1.1.1）。 - 启用DNSSEC（域名系统安全扩展），通过加密DNS查询和响应来确保数据的完整性。 - 使用HTTPS来访问网站，而不是HTTP，因为HTTPS为数据传输提供加密保护。 - 维护操作系统和浏览器的最新安全补丁，防止恶意软件的入侵。</p><h4 id="5-1-2-安全的DNS设置指南"><a href="#5-1-2-安全的DNS设置指南" class="headerlink" title="5.1.2 安全的DNS设置指南"></a>5.1.2 安全的DNS设置指南</h4><p>设置一个安全的DNS环境是保护网络不受DNS劫持影响的关键步骤。以下是设置安全DNS的指南：- 首先，选择一个可靠的DNS提供商，并获取他们的DNS服务器地址。 - 在本地网络设备（如路由器）或操作系统中配置这些地址。如果设备支持，启用DNSSEC选项。 - 对于高级用户，可以配置防火墙规则，限制非授权的DNS查询。 - 定期检查DNS服务器的健康状态和响应时间，确保服务的可靠性。 - 对于企业用户，可以实施内部DNS系统，利用内部DNS服务器提供保护，同时减少对外部DNS服务的依赖。</p><h3 id="5-2-DNS切换对网络的影响"><a href="#5-2-DNS切换对网络的影响" class="headerlink" title="5.2 DNS切换对网络的影响"></a>5.2 DNS切换对网络的影响</h3><h4 id="5-2-1-正面与负面影响分析"><a href="#5-2-1-正面与负面影响分析" class="headerlink" title="5.2.1 正面与负面影响分析"></a>5.2.1 正面与负面影响分析</h4><p>DNS切换可以带来正面与负面影响。正面影响包括： - 提高网络速度：切换到更快的DNS服务器可以加快域名解析速度，从而提高整个网络的加载速度。 - 避免网络中断：在原DNS服务器出现问题时，切换到备用DNS可以减少或避免服务中断。 - 提升安全性：如前所述，切换到安全的DNS设置可以提升网络整体的安全性。</p><p>然而，DNS切换也可能带来一些负面影响： - 增加延迟：如果新DNS服务器响应较慢，那么可能会在短时间内增加DNS解析的延迟。 - 网络不稳定：频繁的DNS切换可能会导致网络连接不稳定。 - 配置错误风险：错误配置DNS设置可能会导致访问控制问题和网络服务中断。</p><h4 id="5-2-2-DNS切换的监控与调整策略"><a href="#5-2-2-DNS切换的监控与调整策略" class="headerlink" title="5.2.2 DNS切换的监控与调整策略"></a>5.2.2 DNS切换的监控与调整策略</h4><p>为了监控DNS切换带来的影响并及时调整策略，可以采取以下措施： - 使用网络监控工具（如Nagios或Zabbix）来跟踪DNS解析时间和网络性能指标。 - 制定监控阈值，一旦DNS解析时间超过设定阈值，系统就会发出警报。 - 定期检查DNS查询日志，以确定是否有异常的查询模式或频繁的失败。 - 实施DNS故障转移计划，确保在发现DNS问题时可以迅速切换到备用服务器。 - 根据监控结果和用户反馈调整DNS设置，并对策略进行优化。</p><p>通过上述方法，可以确保DNS切换既能够提升网络性能和安全性，又能够最小化可能产生的负面影响。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_42510243/article/details/147699615">DNS自动选择最佳服务器的实战指南</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">DNS</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="网络编程" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/categories/DnsJumper/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/categories/DNS/"/>
    
    
    <category term="网络协议" scheme="https://zml3589110.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="WIFI" scheme="https://zml3589110.github.io/tags/WIFI/"/>
    
    <category term="TCP/IP" scheme="https://zml3589110.github.io/tags/TCP-IP/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/tags/DNS/"/>
    
    <category term="域名" scheme="https://zml3589110.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/tags/DnsJumper/"/>
    
  </entry>
  
  <entry>
    <title>ESP01S基础资料</title>
    <link href="https://zml3589110.github.io/posts/1451356382.html"/>
    <id>https://zml3589110.github.io/posts/1451356382.html</id>
    <published>2025-09-09T03:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp01和esp01s的区别"><a href="#esp01和esp01s的区别" class="headerlink" title="esp01和esp01s的区别"></a>esp01和esp01s的区别</h1><p>其实，两者都是安信可公司出的两款物联网模块。ESP-01S其实是ESP-01的升级版，具体修改了哪些地方，我们详细看下。</p><p><strong>首先</strong>，安信可目前在售的模块如下（图片转自安信可官网）：</p><img src="/posts/1451356382/word-image-22.png" class="" title="img"><p>你会发现目前ESP-01S在售，而ESP-01已经不卖了。所以，网上有些店铺依然在卖ESP-01的，个人推测有两种可能：1、清库存；2、个别用户专门用这个。</p><p><strong>其次</strong>，管脚定义如下：</p><img src="/posts/1451356382/word-image-23.png" class="" title="img"><img src="/posts/1451356382/word-image-24.png" class="" title="img"><p>你会发现，两者都是8个管脚，而且管脚定义一样。不光管脚定义一样，模块尺寸也一样：</p><img src="/posts/1451356382/word-image-25.png" class="" title="img"><p><strong>第三</strong>，指示灯与上拉电阻。根据官方提供的模组选型表，我们可以知道：</p><img src="/posts/1451356382/word-image-26.png" class="" title="img"><p>指示灯的管脚，由ESP-01的TXD0变成了ESP-01S的GPIO2。然后ESP-01S模块的IO0、RST、EN管脚上增加了上拉电阻。</p><p>增加这些电阻有什么用？看下一条！</p><p><strong>第四</strong>，典型应用电路。第三点提到了ESP-01S模块中增加了上拉电阻，而增加上拉电阻的意义在于，对典型应用电路进行优化。效果如下：</p><img src="/posts/1451356382/word-image-27.png" class="" title="img"><p>ESP-01</p><img src="/posts/1451356382/word-image-28.png" class="" title="img"><p>ESP-01S</p><p>对比两者，你会发现ESP-01S的应用电路简化了，省掉了两个上拉电阻。</p><p>其实，综上所述，你会发现ESP-01S是官方用来替换ESP-01的。毕竟在选型表里已经给出了建议。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="http://www.mcublog.cn/esp8266/2020_03/esp01-esp01s/">esp01和esp01s的区别</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP01S基础资料收集</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
    <category term="ESP8266-12E/F" scheme="https://zml3589110.github.io/tags/ESP8266-12E-F/"/>
    
  </entry>
  
  <entry>
    <title>小白自制Linux开发板</title>
    <link href="https://zml3589110.github.io/posts/3433483963.html"/>
    <id>https://zml3589110.github.io/posts/3433483963.html</id>
    <published>2025-09-05T12:43:20.000Z</published>
    <updated>2025-09-10T13:10:14.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-瞎抄原理图与乱画PCB"><a href="#一-瞎抄原理图与乱画PCB" class="headerlink" title="一. 瞎抄原理图与乱画PCB"></a>一. 瞎抄原理图与乱画PCB</h1><p>因为墨云是基于高中物理水平的电路知识来学习、而且此前也就玩过树莓派、Esp8266之类的开发板，水平基础趋近于零，所以在写这个系列的时候抱着记录的心态、还望不足之处还望大佬们指正。</p><p>《论语》说：见贤思齐焉。所以现在墨云又开始瞎折腾了</p><p>为啥突然想做嵌入式开发呢，因为看见了下面两位牛人</p><p>【稚晖君】</p><p><a href="https://www.bilibili.com/video/av65365123/">https://www.bilibili.com/video/av65365123/</a></p><p>【在名片上运行的Business Card Linux】</p><p><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/"> https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a></p><p>于是躁动的心开始蠢蠢欲动。</p><p>先定个小目标：</p><p>　　<em>设计一个没啥作用，但是可以运行Linux的小板。</em></p><p>样子大概长这样：</p><p>　　<a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210609081210227-1578860150.png"><img src="/posts/3433483963/483434-20210609081210227-1578860150.png" class="" title="img"></a></p><p> 所以有了初步想法，那开始吧</p><h2 id="1-工具与芯片说明"><a href="#1-工具与芯片说明" class="headerlink" title="1. 工具与芯片说明#"></a>1. 工具与芯片说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#1.-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%8A%AF%E7%89%87%E8%AF%B4%E6%98%8E">#</a></h2><p><strong>立创EDA</strong>：电路图与PCB设计工具，本次硬件部分设计全部使用立创EDA完成</p><p><strong>F1C100s</strong> ：全志的一款基于Arm的小型Soc，自带32MB的内存，其升级版F1C200s为64MB内存，因为其极其便宜(当然最近因为芯片涨价影响)，可以运行Linux，最典型的基于该芯片的荔枝派开发板。</p><p><strong>CH340E</strong>：USB转串口通信芯片，是作为与外界通信的唯一接口 、CH340E个头小、外围电路少，使用简单。</p><p><strong>原理图</strong>：先后参考了(baipiao)了Licheepi Nano、Business LinuxCard、LiShanwenGit(<a href="https://www.oshwhub.com/LSW12315)%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%E5%B9%BF%E5%9C%BA%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%A1%B9%E7%9B%AE">https://www.oshwhub.com/LSW12315)立创开源广场的一系列项目</a></p><h2 id="2-原理图说明"><a href="#2-原理图说明" class="headerlink" title="2.原理图说明#"></a>2.原理图说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#2.%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E">#</a></h2><p> <strong>电源管理</strong></p><p> 电源部分使用USB方式供电，输入电压为5V，这里供电部分和串口电路共用相同USB端口。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100226272-904592004.png"><img src="/posts/3433483963/483434-20210607100226272-904592004.png" class="" title="img"></a></p><p>  通过查询F1c100s数据手册：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100558506-389190797.png"><img src="/posts/3433483963/483434-20210607100558506-389190797.png" class="" title="img"></a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100617030-1539276821.png"><img src="/posts/3433483963/483434-20210607100617030-1539276821.png" class="" title="img"></a></p><p> 通过综合分析，我们可以大概把电源分为4类</p><p>  Vdd-Core：1.1V</p><p>  Vcc-Dram：2.5V</p><p>  AVCC : 3.0V</p><p>  UVCC&#x2F;VCC-IO&#x2F;TV-AVCC&#x2F;TTL：3.3</p><p>  这里主要使用 SY8088AAC 同步降压DC-DC稳压器，为SOT32-5的封装方式，通过使用外围电阻调整输出电压。</p><p>  公式为：</p><p>​      <strong>Vout &#x3D; 0.6 * (&#96;1+Ra&#x2F;Rb)</strong> </p><p>而AVCC使用XC6206P302MR-SOT23的封装方式，输入5V 输出为3.0V</p><p>因为 AVCC为模拟电源电压，为了避免引入电源干扰，通常需要把把模拟电路与数字电路分开隔离开(这个地方解释可能不对，欢迎指正)。</p><p>电源部分的原理图如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075511811-1722536141.png"><img src="/posts/3433483963/483434-20210518075511811-1722536141.png" class="" title="img"></a></p><p>电压输入输出端都使用滤波电容进行处理，使用还要接入2.2uH的功率电感，注意一定要用功率电感，电流要求可以达到1A以及以上的才行</p><p>这个板子使用0805的功率电感，建议最好使用CD32类型的绕线功率电感。</p><p><strong>核心原理图</strong></p><p>对于核心部分的原理图如下，因为本次电路设计主要以验证为主，所以并没有做太多的外设电路。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075644565-3556161.png"><img src="/posts/3433483963/483434-20210518075644565-3556161.png" class="" title="img"></a></p><p>除了常规的核心、外围、DRAM工单引脚，核心部分还引出了</p><p> \1. TF卡引脚，作为本板子唯一的系统加载电路，这是必须的</p><p> 2.晶振，使用规格为24Mhz的有源晶振、加两个15pf的负载电容</p><p> 3.串口调试 作为板子与外界唯一交互的通道，这个也是必须的，然而在做这个成功的给自己挖坑了。</p><p> 4.LED灯，这是这个板子唯一的外设，也是用来学习驱动开发的第一步。</p><p> 5.dram_vref、Var1、Var2 这是必须要接的、外围电路，我也不知道的干啥的 <del>_</del>…</p><p> 6.USB OTG 也是作为一个通信接口来使用，通过这个接口可以为板载Flash下载程序，但是因为本板没有做Flash，所以目前唯一的作用就是放到验证fel是否可以调通。</p><p> 7.复位按钮</p><p><strong>挖坑点</strong></p><p>一直以来认为发光二极管也是二极管，所以就有下面的设计(乱画)，于是后来感觉板子没问题，但是就是串口死活不显示数据、在众多大佬的帮助下，才发现了这个其妙(naocan)</p><p>的接线方法，于是将两个发光二极管位置放了两个0欧的电阻，一下子就成功调通了。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518081301718-1938463553.png"><img src="/posts/3433483963/483434-20210518081301718-1938463553.png" class="" title="img"></a></p><p>对于芯片电源输入端的滤波电容与Dram_vref接线如下：</p><p>对于滤波电容简单的说法就是，对于供电端的电压，因为电路设计或者外界干扰等等，其实不是完美的电压，总会存在高频或是低频的噪声，而用小容量的电容就可以降低这些干扰。</p><p>常规的容值就是 10uf 、1uf、100nf</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075706884-1416748722.png"><img src="/posts/3433483963/483434-20210518075706884-1416748722.png" class="" title="img"></a></p><p><strong>通信电路</strong></p><p>我们在核心原理图中看到了引出的串口线路，而串口的接口如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608075946061-1759039430.png"><img src="/posts/3433483963/483434-20210608075946061-1759039430.png" class="" title="img"></a> <a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608080015029-894589865.png"><img src="/posts/3433483963/483434-20210608080015029-894589865.png" class="" title="img"></a></p><p>显然在你看看你超博的笔记本机身，并没有发现这个接口，偶尔还有一些老的笔记本上面可以看到类似的接口，对不起——那是显示屏的VGA接口。</p><p>那我们如何使用串口传输的信息呢，我们需要一个USB转串口的芯片，usb转串口的芯片很多，这里选择 CH340E 这个型号，因为其很小，接线也方便。</p><p>原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075726899-441537012.png"><img src="/posts/3433483963/483434-20210518075726899-441537012.png" class="" title="img"></a></p><p>前面提到，这个板子共用了电源与TTL共用了一套设计，也就是是说USB线插上就可以启动小板，并且开始进入串口调试。</p><p>原理图中的U5是一个自恢复保险丝。</p><p><em>这里需要注意一下：</em></p><p> 根据CH340E官方的原理图，当VCC接入5V的时候，V3 需要接一个100nf的电容，但是此处在V3直接接入5V，也可以工作。</p><p> 实际使用的时候最好不要这样做。</p><p><strong>TF卡接口</strong></p><p>和电脑主机在BIOS选择启动方式一样， F1C100s 支持多种方式的系统加载机制比如通过SPI接口加载Flash芯片中的镜像，或者通过TF卡接口加载镜像。</p><p>这里使用TF卡作为启动源，这样做是因为</p><p> 1.TF卡容量可以自己控制。</p><p> 2.系统烧写调试方便</p><p>这部分电路相对简单，原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075745633-24558076.png"><img src="/posts/3433483963/483434-20210518075745633-24558076.png" class="" title="img"></a></p><p><strong>OTG 与唯一的外设LED灯</strong></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075809957-1231071962.png"><img src="/posts/3433483963/483434-20210518075809957-1231071962.png" class="" title="img"></a></p><h2 id="3-PCB绘制"><a href="#3-PCB绘制" class="headerlink" title="3.PCB绘制#"></a>3.PCB绘制<a href="https://www.cnblogs.com/twzy/p/14714651.html#3.pcb%E7%BB%98%E5%88%B6">#</a></h2><p> PCB尺寸为42mm*29mm ，可以说非常小了，为了便于焊接，所有容阻都是用0805的封装方式</p><p> 电源走线为14mil ，信号线为8mil</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075900597-2044589685.png"><img src="/posts/3433483963/483434-20210518075900597-2044589685.png" class="" title="img"></a></p><h2 id="4-PCB焊接"><a href="#4-PCB焊接" class="headerlink" title="4.PCB焊接#"></a>4.PCB焊接<a href="https://www.cnblogs.com/twzy/p/14714651.html#4.pcb%E7%84%8A%E6%8E%A5">#</a></h2><p> 焊接PCB是一项手艺活，尤其是QFN方式封装的F1C100s 更是难到发指，还好借助焊台和热风枪，完美的完成了焊接，当然放大镜、洗板水是不可缺少的。</p><p> 并且因为板子时长需要在手上把玩（盘PCB）。所以选择了无铅稀浆进行焊接。</p><p>效果如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080628282-1076112978.png"><img src="/posts/3433483963/483434-20210518080628282-1076112978.png" class="" title="img"></a><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080325298-910819870.png"><img src="/posts/3433483963/483434-20210518080325298-910819870.png" class="" title="img"></a></p><p>成功运行Linux，</p><p>因为还没开始着手做Linux移植，暂时使用LicheePi 的镜像，下一节开始做Linux的移植。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080244837-276955395.png"><img src="/posts/3433483963/483434-20210518080244837-276955395.png" class="" title="img"></a></p><h2 id="5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记"><a href="#5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记" class="headerlink" title="5. 后记[#](https://www.cnblogs.com/twzy/p/14714651.html# 5.-后记)"></a>5. 后记[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 5.-后记)</h2><p>事实上世界上从来没有所谓轻易的成功，对于初次玩PCB的小白更是如此，现在这个小板能成功也是经历三四个月，五六次打板才成功的。以下是早期的趟雷PCB场景与先烈。 (右下角为成功的小板)</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080712817-696267996.png"><img src="/posts/3433483963/483434-20210518080712817-696267996.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080742813-715067385.png"><img src="/posts/3433483963/483434-20210518080742813-715067385.png" class="" title="img"></a></p><h3 id="硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包："><a href="#硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包：" class="headerlink" title="硬件资料包：[#](https://www.cnblogs.com/twzy/p/14714651.html# 硬件资料包：)"></a>硬件资料包：[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 硬件资料包：)</h3><p><a href="https://files.cnblogs.com/files/twzy/LinuxNano%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E5%9B%BE-%E5%A2%A8%E4%BA%91.zip"> 下载</a></p><h1 id="二-u-boot移植"><a href="#二-u-boot移植" class="headerlink" title="二. u-boot移植"></a>二. u-boot移植</h1><p>我们都知道，PC在启动的时候，首先是进入BIOS，再根据BIOS中配置信息引导后续的启动操作系统，比如配置Windows启动。</p><p>而对于嵌入式linux中，并没有BIOS，这时候就需要一种类似引导程序来处理。于是就有了BootLoader。</p><p>BootLoader是一段小程序，可以把它想象成PC机linux上的GRUB&#x2F;LILO引导程序，可以直接从flash或TF卡中运行，来装载内核。它可以初始化硬件设备，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统做好准备。</p><h2 id="1-嵌入式开发板的启动过程"><a href="#1-嵌入式开发板的启动过程" class="headerlink" title="1. 嵌入式开发板的启动过程#"></a>1. 嵌入式开发板的启动过程<a href="https://www.cnblogs.com/twzy/p/14865952.html#1.-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">#</a></h2><p>一个嵌入式系统从软件角度来看分为三个层次：</p><ul><li>引导加载程序</li></ul><p>​      包括固化在芯片中的boot程序（可选）和BootLoader两大部分，对于固化的boot程序。主要是芯片通过外围电路连接的实际情况选择读入程序的位置，比如：通过TF卡或是SPI以及其他方式启动，至于优先顺序这就要具体看芯片的数据手册，个人没做过具体测试。</p><ul><li>linux内核</li></ul><p>​     特定于嵌入式平台的定制内核</p><ul><li>文件系统</li></ul><p>​     包括了系统命令和应用程序</p><table><thead><tr><th>BootLoader</th><th>Boot Parameters</th><th>Kernel</th><th>Root Filesystem</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>BootLoader</strong>启动过程可分为单阶段和多阶段(stage1、stage2),其中stage1完成初始化硬件，如CPU寄存器、内存控制器，为stage2准备内存空间。一般stage1是可以直接在nor flash中运行的，并将stage2复制到内存RAM中，设置堆栈，然后跳转到stage2(从这也可以看出stage2是在RAM中运行的，与stage1不同)</p><p><strong>Boot Parameters</strong> 顾名思义，就是配置了要启动内核的参数，包含要加载系统内核相关文件的位置，要加载到内存中的位置，定位到文件系统的位置，相关输入输出的呈现等一系列参数。</p><p><strong>kernel</strong> 在存放在bootloader之后，对于SoC来说，代码都需要在RAM中运行，这里与MCU不一样的地方就是引入了MMU（内存管理单元）。对于MCU而言，由于其执行速度低，因此运行代码都在ROM中直接运行，而对于Flash而言，其读取速度远不及RAM的速度，因此对于运行速度非常快的SoC而言，所有的代码都需要在RAM中运行。但是这里有一个问题，RAM掉电数据将会丢失，故代码保存不可能放在RAM中，当前所有的嵌入式设备而言，代码保存都是放在ROM中，因此在SoC中运行代码需要将代码搬运到RAM中然后再执行。</p><p><strong>Root Filesystem</strong> 由于其执行过程需要对ROM进行读写操作，因此可以不用搬运到RAM中，但是实际过程中内核启动后会产生一个虚拟的文件系统，该文件系统是挂在根文件系统的关键所在，这里不详细讲解。整体来说，大致的过程为，嵌入式设备上电后将执行bootloader，对硬件进行硬件和堆栈初始化，然后搬运内核到RAM中并启动内核，紧接着挂载根文件系统。</p><h2 id="2-环境配置与参考项目"><a href="#2-环境配置与参考项目" class="headerlink" title="2. 环境配置与参考项目#"></a>2. 环境配置与参考项目<a href="https://www.cnblogs.com/twzy/p/14865952.html#2.-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%8F%82%E8%80%83%E9%A1%B9%E7%9B%AE">#</a></h2><p>系统：Ubuntu 16</p><p>编辑器：VSCode</p><p>参考项目：Lichee-Pi Nano </p><p>地址：<a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080525817-1455821238.png"><img src="/posts/3433483963/483434-20210826080525817-1455821238.png" class="" title="img"></a></p><p>Lichee-Pi Nano</p><p>需要注意的是一定要选择Nano版本，因为我们开发板使用的主控芯片和Nano的主控是一致的，所以后续我们要编译U-boot，内核都可以参考(bai piao)这里面的配置。</p><p>主控芯片：F1c100s&#x2F;F1c200s，100s内置32MB DDR1内存，200s内置64MB DDR1内存，200s贵一点，他们都是QFN88封装。</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右。</p><p>带有100M的SPI接口2个，SDIO接口1个，USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口，I2C I2S UART PWM等等。</p><p>还有就是他们不支持硬件浮点，所以浮点运算使用软浮点方式。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080450826-950498006.png"><img src="/posts/3433483963/483434-20210826080450826-950498006.png" class="" title="img"></a></p><p> F1c100s&#x2F;F1c200s芯片功能</p><h2 id="3-交叉编译器"><a href="#3-交叉编译器" class="headerlink" title="3.交叉编译器#"></a>3.交叉编译器<a href="https://www.cnblogs.com/twzy/p/14865952.html#3.%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8">#</a></h2><p>  我们通过PC版的Linux自带的gcc编译的程序只能在当前系统架构下的cpu架构(x86)下运行，如果我们想要编写的程序在嵌入式Linux下运行，那么就需要用到对应的编译器。</p><p>  我们做的开发板主控芯片F1C200S，内核为ARM9，其架构使用的是ARMv5架构，所以我们也要选用对应的编译器，同样，这样的编译器很多，这里我们使用最常用的arm-linux-gnueabi- ，因为交叉编译器F1C200S必须高于6.0版本，这里我们使用7.2版本</p><p>  <a href="https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz"> 点击下载</a></p><p>  <em>下载较慢时使用下载工具</em></p><p>下载完成后解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><p>然后在&#x2F;usr&#x2F;local目录下新建arm-linux-gcc目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc</span><br></pre></td></tr></table></figure><p>进入解压目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;</span><br></pre></td></tr></table></figure><p>将该目录下的所有文件复制到新建的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rd * &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;</span><br></pre></td></tr></table></figure><p>最后需要添加该工具链的环境变量使其可以在任何目录下执行，打开&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>在文件末尾添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;bin</span><br></pre></td></tr></table></figure><p>添加完毕，使路径生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>接下来在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-</span><br></pre></td></tr></table></figure><p>然后连按两次Tab键，如图在表示成功：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210823161114895-675144161.png"><img src="/posts/3433483963/483434-20210823161114895-675144161.png" class="" title="img"></a></p><p>如果没有出现，则进行下面操作，安装必要的动态链接库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure><p>至此，我们完成了编译工具的配置。</p><h2 id="4-编译U-boot"><a href="#4-编译U-boot" class="headerlink" title="4. 编译U-boot#"></a>4. 编译U-boot<a href="https://www.cnblogs.com/twzy/p/14865952.html#4.-%E7%BC%96%E8%AF%91u-boot">#</a></h2><p> 当Arm开发板上电以后第一个要加载到内存并运行的程序就是**BootLoader，**BootLoader****的同类型程序很多，如U-boot、X-boot、Rt-Thread，这里我们依然选中最常用的U-boot作为目标(因为其他的我也不会呀)，</p><p> 最新版本的uboot几乎包含当前主流的SoC芯片，前面提到本开发板使用的芯片和licheePI nano相同，大部分硬件也是兼容的，为了快速移植该部分，这里采用licheePI nano的u-boot来进行移植。在终端输入如下命令克隆u-boot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Lichee-Pi&#x2F;u-boot.git -b nano-v2018.01</span><br></pre></td></tr></table></figure><p>克隆完毕文件会保存在当前目录下，进入该目录，*<br>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd u-boot</span><br></pre></td></tr></table></figure><p>在该文件夹下有很多分支，我们可以查看所有分支，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>现在我们使用的是nano开发板，所以将当前分支切换到nano分支，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01u-boot</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928150820570-1873390261.png"><img src="/posts/3433483963/483434-20210928150820570-1873390261.png" class="" title="img"></a></p><p> 切换到Nano分支</p><p>默认的没有指定交叉工具链和架构，因此在编译之前需要指定交叉工具链和芯片架构，u-boot的交叉编译器在u-boot 的根目录下中的<strong>Makefile</strong>文件中定义了。打开文件找到<strong>CROSS_COMPILE</strong>变量，修改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH&#x3D;arm</span><br><span class="line">CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151000818-1228538185.png"><img src="/posts/3433483963/483434-20210928151000818-1228538185.png" class="" title="img"></a></p><p> 配制交叉编译环境</p><p>这样我们就能使用我们指定的编译器来编译u-boot了。</p><p>在u-boot项目的config目录下存在对多种板子的配置描述文件，由于每个板子的外设不同，因此编译之前必须要对u-boot进行配置。然而配置是一件比较繁琐的事情，特别是像u-boot这种比较复杂的项目而言，初学者几乎无法完成。幸运的是对于大部分开发板而言，config目录下有其配置好的默认配置文件。进入config目录中，然后执行ls查看当前所有的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151205314-374311839.png"><img src="/posts/3433483963/483434-20210928151205314-374311839.png" class="" title="img"></a></p><p> 查看配制文件</p><p>找到<strong>licheepi_nano_defconfig</strong> 和 <strong>licheepi_nano_spiflash_defconfig</strong>，前者表示为TF卡启动，后者表示从SPI 设备启动，因为我们做的小板只有从TF卡启动，所以我们需要使用 <strong>licheepi_nano_defconfig</strong> 。</p><p>现在回到上级目录，然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>这样我们把<strong>licheepi_nano_defconfig</strong> 作为默认配置项。</p><p>接下来我们就可以用图形界面进行配置了，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时出现图形配置选项，如下图所示</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151406633-1920865408.png"><img src="/posts/3433483963/483434-20210928151406633-1920865408.png" class="" title="img"></a></p><p> u-boot Menuconfig配制，注意红框中的配置，我们后续要用到。</p><p>至此我们的u-boot环境配置就完成了，但是我们还有个问题要解决：<strong>如何让u-boot引导系统</strong></p><p>我们在PC端安装Windows系统的时候往往需要选择启动顺序，比如需要优先通过光驱或u盘启动等。</p><p>同样在u-boot中也需要这样的配置，当然u-boot比PC配置稍微复杂一丢丢。我们前面提到Linux嵌入式系统结构分布中有个Boot Parameters 部分，这部分就是做引导配置的，那怎么配置呢，总体来说可以分为两部分：</p><ol><li>bootcmd，主要用于描述控制Linux内核文件以及其他描述文件加载到内存中位置以及启动Linux内核系统等</li><li>bootargs，用于配制文件系统、串口信息等。</li></ol><p><strong>bootcmd</strong></p><p>在最开始提到过，内核一般不在flash中运行，这样就需要将内核搬运到内存中，这个过程需要u-boot来完成。对于mmc (TF卡)而言，在u-boot有专门的命令<strong>load mmc</strong>，该命令可以将mmc中的代码从flash搬运到指定的地址处。</p><p>当u-boot中环境变量bootdelay计数到0时，此时uboot就会开始执行bootcmd中的命令。</p><p>bootdelay这个环境变量是一个计数器，当u-boot主体运行完毕后，此时bootdelay该变量的值将会开始递减，递减时间为1s，当递减到0时，此时u-boot将会跳转到bootcmd处开始执行bootcmd命令，（你可以简单理解为PC启动后有一两秒时间等待，你可以可以通过F8或Enter键打断进入Bios设置的过程，这个等待时间就由u-boot中的bootdelay来控制）。</p><p>下面我们需要记住这句指令，这就是我们当前制作的开发板需要用到的bootcmd全部内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>如果你需要详细了解这句话那就接着往下看，如果不需要则可以跳到 下面的u-boot参数配置环节</p><p>对于上面命令，我们根据分号拆分为3部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt; load mmc 0:1 0x80008000 zImage;</span><br><span class="line">2&gt; load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;</span><br><span class="line">3&gt; bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>其中两个 load mmc 命令、一个bootz 命令。</p><p>先看第一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage</span><br></pre></td></tr></table></figure><p>load mmc有三个参数：第一个参数是mmc(TF卡)分区，第二个参数是内存中目标地址，第三个参数是源文件。</p><p>即上面的命令意思是<strong>将mmc的0:1 分区中的zImage复制到内存中的0x80008000地址处。</strong>这里的zimage就是Linux内核，后续会提到该文件编译，0:1这个可以这样理解0表示TF卡(TF卡属于mmc存储器的一种)，1这表示TF卡的第一个分区(boot分区)后面会提到。</p><p>而对于内存位置 <strong>0x80008000</strong> 地址位置，将其理解为默认值就行了。这样完成了zImage的加载。</p><p>下面分析第二条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb</span><br></pre></td></tr></table></figure><p>有了上面的加载zImage的说明，可以很轻松的理解上面的命令意思是将mmc的0:1分区中的suniv-f1c100s-licheepi-nano.dtb文件加载到内存中的0x80c08000地址处。对于<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 这个文件，叫做设备树文件，简单来说就是当前开发板上面所有外设备描述文件，这部分将会在后续内核编译部分进行详细说明。</p><p>对于第三条命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz 0x80008000 - 0x80c08000</span><br></pre></td></tr></table></figure><p>的意思是告诉内核镜像的起始地址为0x80008000，加载的设备树地址为0x80c08000。这里是告诉cpu从这里开始启动Linux， bootz命令的格式是：bootz空格0x80008000空格-空格0x80c08000,注意-左右有空格。</p><p>除了bootz 命令外，有些系统里面还可能存在一个叫做bootm命令，这是是对没有使用设备树内核的镜像启动命令，早期版本的内核没有引入设备树，因此对于早期的内核一般使用的是bootm，其命令格式为bootm内核地址，比如bootm x0x30008000，意思是从0x30008000开始启动内核，启动内核的过程其实是将pc指针指向该地址，这样处理器就会从该地址处运行代码。</p><p> 这里我们就完成了bootcmd的说明，接下来我们看另外一个参数。</p><p><strong>bootargs</strong></p><p>bootargs也是u-boot环境变量中一个非常重要的变量，上面已经讲解了内核的启动可以通过bootcmd来完成，那接下来内核启动完毕后必须挂在根文件系统(rootfs)。但是内核并不知道根文件系统的具体位置，我们必须要告诉根文件的位置后内核才能将其挂载，这时就需要有bootargs变量。该变量的作用是告诉内核根文件系统的位置和属性以及必要的配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p>同上面分析的方法一样，我们依然将这部分命令拆成几部分来说明。这里需要说明的是，这部分配置信息是由u-boot 直接按照参数字符串方式提供给Linux内核，然后由Linux内核进行执行的，这也说明里为什么格式与bootcmd配置方式不一致。</p><p><strong>console&#x3D;ttyS0,115200</strong> 表示终端为ttyS0即串口0,波特率为115200；</p><p><strong>panic&#x3D;5</strong> 字面意思是恐慌，即linux内核恐慌，其实就是linux不知道怎么执行了，此时内核就需要做一些相关的处理，这里的5表示超时时间，当Linux卡住5秒后仍未成功就会执行Linux恐慌异常的一些操作。</p><p><strong>rootwait</strong> 该参数是告诉内核挂在文件系统之前需要先加载相关驱动，这样做的目的是防止因mmc驱动还未加载就开始挂载驱动而导致文件系统挂载失败，所以一般bootargs中都要加上这个参数。</p><p><strong>root&#x3D;&#x2F;dev&#x2F;mmcblk0p2</strong> 表示根文件系统的位置在mmc的0:2分区处，**&#x2F;dev<strong>是设备文件夹，内核在加载mmc中的时候就会在根文件系统中生成</strong>mmcblk0p2**设备文件，这个设备文件其实就是mmc的0:2分区(这里对应TF卡的第二个分区：rootfs)，这样内核对文件系统的读写操作方式本质上就是读写&#x2F;dev&#x2F;mmcblk0p2该设备文件。</p><p><strong>earlyprintk</strong> 参数是指在内核加载的过程中打印输出信息，这样内核在加载的时候终端就会输出相应的启动信息。rw表示文件系统的操作属性，此处rw表示可读可写。</p><h2 id="5-u-boot参数配置"><a href="#5-u-boot参数配置" class="headerlink" title="5.u-boot参数配置 #"></a>5.u-boot参数配置 <a href="https://www.cnblogs.com/twzy/p/14865952.html#5.u-boot%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p> 选中  <strong>Enable boot arguments</strong> 按空格选中，下面会显示：() <strong>Boot arguments</strong></p><p>然后选中<strong>Boot arguments</strong> ,按回车，进入配置窗口，接下来上面解释过的<strong>bootargs</strong> 参数信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152101050-1297588046.png"><img src="/posts/3433483963/483434-20210928152101050-1297588046.png" class="" title="img"></a></p><p> 配置bootargs信息</p><p>然后按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><p>同理配置：<strong>Enable a default value for bootcmd</strong> 按空格选中，下面会显示：**() bootcmd value** 配置项，</p><p>选中<strong>bootcmd value</strong> 进入配置界面，输入bootcmd命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152626755-371939279.png"><img src="/posts/3433483963/483434-20210928152626755-371939279.png" class="" title="img"></a></p><p> 配置bootcmd参数</p><p> 按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><h2 id="6-u-boot编译与烧录"><a href="#6-u-boot编译与烧录" class="headerlink" title="6.u-boot编译与烧录#"></a>6.u-boot编译与烧录<a href="https://www.cnblogs.com/twzy/p/14865952.html#6.u-boot%E7%BC%96%E8%AF%91%E4%B8%8E%E7%83%A7%E5%BD%95">#</a></h2><p>先保存图形配置界面后推出界面，在终端执行make -j4即可对整个u-boot进行编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152943605-978425396.png"><img src="/posts/3433483963/483434-20210928152943605-978425396.png" class="" title="img"></a></p><p>编译u-boot</p><p><strong>make -j4</strong>后面的-j4表示4个核心进行编译，若电脑的处理器是2核心，请使用make -j2进行编译。</p><p>编译完成后会在当前目录生成<strong>u-boot-sunxi-with-spl.bin</strong>烧录文件。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928153312700-1418379375.png"><img src="/posts/3433483963/483434-20210928153312700-1418379375.png" class="" title="img"></a></p><p>根目录下找到 <strong>u-boot-sunxi-with-spl.bin</strong> 文件</p><p>该文件就是我们最终要烧录的二进制文件。</p><p>在当前目录下会有一个隐藏的文件.config，该文件是u-boot编译后根据各个选项产生的配置文件，这个配置文件记录了所有配置选项的宏开关，编译的时候是根据最终的.config文件来进行编译的，当然编译前是需要有脚本解析.config文件然后进行相应的编译。</p><p>烧录到TF卡</p><p>只要将u-boot-sunxi-with-spl.bin烧录到tf卡的8k偏移处地址就可以了，烧录步骤如下：使用dd命令进行块搬移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if&#x3D;u-boot-sunxi-with-spl.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</span><br></pre></td></tr></table></figure><p>该命令中：</p><p>​    <strong>if</strong>  文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</p><p>​    <strong>of</strong>  文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</p><p>​    <strong>bs</strong> bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p><p>​    <strong>seek</strong> blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>这里的输出文件(<strong>of</strong>)为主机电脑的&#x2F;dev&#x2F;sdb文件，也就是TF卡，这里也体现了Linux一切皆文件的思想。</p><p><strong>&#x2F;dev&#x2F;sdb</strong> 这个可以用gparted 软件查看，该软件可以直接用命令安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>此时在Ubuntu下面可以看到如下软件：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081032210-139894885.png"><img src="/posts/3433483963/483434-20210930081032210-139894885.png" class="" title="img"></a></p><p>安装好GParted软件</p><p> 打开软件</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081827917-1823480007.png"><img src="/posts/3433483963/483434-20210930081827917-1823480007.png" class="" title="img"></a></p><p>GParted</p><p>在右上角可以看到两个硬盘，&#x2F;dev&#x2F;sda 为本地硬盘，&#x2F;dev&#x2F;sdb 是我们将要写数据的TF(当然这只是墨云自己的配置使然，具体情况请根据实际情况而定)，因此这里的of&#x3D;&#x2F;dev&#x2F;sdb 烧录到8k偏移地址处是指绝对地址，这个绝对地址指的是TF卡的物理地址。这8K的值是由F1C200S 中固化的启动代码决定的，所以照抄即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930082436650-910788822.png"><img src="/posts/3433483963/483434-20210930082436650-910788822.png" class="" title="img"></a></p><p>烧写u-boot</p><p>然后我们正常退出TF卡，然后插入我们自制的开发板，通过USB线连接电脑，</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085606475-1688206025.png"><img src="/posts/3433483963/483434-20210930085606475-1688206025.png" class="" title="img"></a></p><p>连接开发板</p><p>打开电脑中的命令行工具，我这里使用Xshell，</p><p>打开Xshell，新建连接：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084928442-133473812.png"><img src="/posts/3433483963/483434-20210930084928442-133473812.png" class="" title="img"></a></p><p>配置名称 ，协议选择Serial,</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085149724-1946801432.png"><img src="/posts/3433483963/483434-20210930085149724-1946801432.png" class="" title="img"></a></p><p> 配置串口</p><p>通过下拉选中com端口，波特率为115200，其他默认即可，点击确定，然后双击主界面左侧会话管理中的刚建立的会话，此时进入连接状态。</p><p>因为在你插入USB通电的时候开发板就已经启动了，所以当你打开串口连接的时候可能未必会看到信息，所以按一下重启键，就可以看到如下的输出信息了，这就是我们的u-boot，执行到u-bbot计数完成后会产生错误，那是因为我们还没有进行系统内核的移植，所以默认就会进入u-boot命令模式。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084405807-1935485286.png"><img src="/posts/3433483963/483434-20210930084405807-1935485286.png" class="" title="img"></a></p><p> 启动信息</p><p> 输入pri命令打印环境变量的所有值，可以找到已经配置的bootcmd 和bootargs</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930090109593-1345294928.png"><img src="/posts/3433483963/483434-20210930090109593-1345294928.png" class="" title="img"></a></p><p> pri命令结果</p><p>至此完成了u-boot移植的全部内容，对于u-boot的移植方法，在后续移植Linux内核和文件系统时都会用到，都是大同小异的，所以有了本篇的说明，之后操作将会非常简单。</p><p>而关于u-boot的内容事实上非常的复杂繁琐，有兴趣的可以自行去了解到，毕竟作为一个小白的我初衷只是先让小板先跑起来。</p><h2 id=""><a href="#" class="headerlink" title="#"></a><a href="https://www.cnblogs.com/twzy/p/14865952.html#">#</a></h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料#"></a>参考资料<a href="https://www.cnblogs.com/twzy/p/14865952.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a></h2><blockquote><p>Lite200 (lishanwen) – <a href="https://lishanwen.cn/index.php/2021/07/03/lite200/">https://lishanwen.cn/index.php/2021/07/03/lite200/</a></p><p>全志F1C200S F1C100S 介绍 ( 迪卡魏曼依奇君 ) <a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">https://blog.csdn.net/tunqimai9331/article/details/95938903</a></p><p>荔枝派Nano 全流程指南 (矽速科技) <a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p></blockquote><h1 id="三-Linux内核与文件系统移植"><a href="#三-Linux内核与文件系统移植" class="headerlink" title="三. Linux内核与文件系统移植"></a>三. Linux内核与文件系统移植</h1><h2 id="1-Linux内核"><a href="#1-Linux内核" class="headerlink" title="1.Linux内核#"></a>1.Linux内核<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.linux%E5%86%85%E6%A0%B8">#</a></h2><p>事实上对于F1C100S&#x2F;F1C200S，Linux官方源码已经对licheepi nano进行支持。所以我们完全可以通过licheepi nano的配置文件进行移植。</p><h3 id="1-1-下载内核源码"><a href="#1-1-下载内核源码" class="headerlink" title="1.1. 下载内核源码#"></a>1.1. 下载内核源码<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.1.-%E4%B8%8B%E8%BD%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81">#</a></h3><p>进入Linux系统官网：</p><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145110377-1315647665.png"><img src="/posts/3433483963/483434-20210930145110377-1315647665.png" class="" title="img"></a></p><p>这里面列出的都是一些主要版本，如主线版本，上时间支持版本，个人推荐使用最新的长时间支持版本（5.10.69）。但是因为我这个项目是在参考一位大神的文档的基础上构建的，所以使用的是5.7.1版本，接下来就给一个选择其他版本的方式。</p><p>选择任意一项点击 [browse]</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145220044-1573759475.png"><img src="/posts/3433483963/483434-20210930145220044-1573759475.png" class="" title="img"></a></p><p>在新打开页面选择 【summary】点击【tag】中的【…】切换下载</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145316299-265231365.png"><img src="/posts/3433483963/483434-20210930145316299-265231365.png" class="" title="img"></a></p><p> 如果想要直接下载5.7.1版本，请直接使用下面的连接</p><p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz</a></p><p>下载后完成后，将代码复制到Ubuntu虚拟机并解压源码。</p><h3 id="1-2-配置编译"><a href="#1-2-配置编译" class="headerlink" title="1.2.配置编译#"></a>1.2.配置编译<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.2.%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91">#</a></h3><p>与上一篇中编译u-boot一样，我们也需要配置对Linux编译进行配置：</p><ul><li>指定架构类型</li><li>指定交叉编译工具</li><li>项目配置</li></ul><p>指定架构，就这个很好理解，就是指定CPU类型，就是配置为Arm就行，交叉编译工具即为上一篇已经安装好的编译工具。</p><p>用VS打开Linux内核代码，找到<strong>Makefile</strong>文件：</p><p>修改如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH              ?&#x3D; arm</span><br><span class="line">CROSS_COMPILE     ?&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>如果没找到ARCH 或 CROSS_COMPILE字段，自己手动添加也行，如下图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930151530833-1001068341.png"><img src="/posts/3433483963/483434-20210930151530833-1001068341.png" class="" title="img"></a></p><blockquote><p> 事实上这两个字段可以不用指定，在进行make的时候加上对应的参数就行，这里为了避免麻烦，所以直接放到了makefile文件中</p></blockquote><p>接下来就是指定项目配置了，这个操作就是让Linux内核认F1C100S&#x2F;F1C200S这颗soc。</p><p>进入内核源码中的<strong>arch&#x2F;arm&#x2F;configs</strong>目录中，可以看到有很多开发板的配置文件，其中<strong>sunxi_defconfig</strong>是全志的配置文件，但是该配置文件非常不全，需要额外配置大量的选项，一般选项多大上千个，这里先使用licheepi_nano的配置文件。</p><p><a href="https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip"> https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip</a></p><p>下载该文件，解压出<strong>linux-licheepi_nano_defconfig</strong>，然后将其放到arch&#x2F;arm&#x2F;configs&#x2F;目录下</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930154001937-799886630.png"><img src="/posts/3433483963/483434-20210930154001937-799886630.png" class="" title="img"></a></p><p> 然后通过终端进入Linux-5.7.1根目录，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005103913552-1730316057.png"><img src="/posts/3433483963/483434-20211005103913552-1730316057.png" class="" title="img"></a></p><p> 进入图形配置界面，如图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005104057991-2077580949.png"><img src="/posts/3433483963/483434-20211005104057991-2077580949.png" class="" title="img"></a></p><p>该界面和u-boot配置一样，所以操作方式也是一样的，上下键移动选项，使用空格键进行选中或取消选择，同样通过空格键或回车键，进入子选项配置，通过Tab键选择保存和退出即可返回上级菜单或命令行界面，也可以直接双击Esc键返回上级目录。</p><h3 id="1-3-配置TF卡设备树信息"><a href="#1-3-配置TF卡设备树信息" class="headerlink" title="1.3 配置TF卡设备树信息#"></a>1.3 配置TF卡设备树信息<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.3-%E9%85%8D%E7%BD%AEtf%E5%8D%A1%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF">#</a></h3><p>我们在完成内核配置后还需要配置TF卡的设备树配置，否则即便是能正常运行内核，在加载文件系统的时候还是会有问题，在这里配置很简单：</p><p>在<strong>linux-5.7.1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录下，分别修改<strong>suniv-f1c100s.dtsi</strong>、<strong>suniv-f1c100s-licheepi-nano.dts</strong> 两个文件（记住这两个文件、以后我们修改的地方多了^_^）</p><p>修改<strong>suniv-f1c100s.dtsi</strong>文件</p><p>首先添加头文件(如果有则忽略)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>在soc-&gt;pio 下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>soc下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">            interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">            pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">            pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status &#x3D; &quot;disabled&quot;;</span><br><span class="line">            #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">            #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>如图，图中的配置可能与读者实际内容不一致，这是因为我改了很多东西，忽略即可，只需要关注红色框中的内容即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009162310863-1685576565.png"><img src="/posts/3433483963/483434-20211009162310863-1685576565.png" class="" title="img"></a></p><p> 修改<strong>suniv-f1c100s-licheepi-nano.dts</strong>文件，在根节点添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>外部添加mmc0使能代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位置如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202201/483434-20220114080223936-810553130.png"><img src="/posts/3433483963/483434-20220114080223936-810553130.png" class="" title="img"></a></p><p>接下来执行make命令开始编译内核和设备树相关的文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>首次进行编译，通常会需要很长时间，编译完成后，就会在在<strong>arch&#x2F;arm&#x2F;boot</strong>目录下生成内核文件：<strong>zImage</strong>，在<strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong>目录下设备树文件：<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 。</p><p>在编译过程中，因为所配置Ubuntu系统的差异，可能会因缺少某些组件导致编译报错，不要慌，将对应的错误关键信息复制到搜索引擎后安装即可，一下是作者碰到的两个编译报错，如果有必要可以提前安装：</p><p> <strong>linux-内核编译配置 lexer.lex.c错误</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wu@ubuntu:~&#x2F;linux-5.4.8$ make exynos_defconfig</span><br><span class="line">HOSTCC scripts&#x2F;basic&#x2F;fixdep</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;conf.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;confdata.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;expr.o</span><br><span class="line">LEX scripts&#x2F;kconfig&#x2F;lexer.lex.c</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: flex: not found</span><br><span class="line">scripts&#x2F;Makefile.host:9: recipe for target ‘scripts&#x2F;kconfig&#x2F;lexer.lex.c’ failed</span><br><span class="line">make[1]: * [scripts&#x2F;kconfig&#x2F;lexer.lex.c] Error 127</span><br><span class="line">Makefile:567: recipe for target ‘exynos_defconfig’ failed</span><br><span class="line">make: * [exynos_defconfig] Error 2 </span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install flex</span><br></pre></td></tr></table></figure><p><strong>编译Linux内核时遇到：“error : openssl&#x2F;bio.h :No such file or folder”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts&#x2F;extract-cert.c:21:25: fatal error: openssl&#x2F;bio.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts&#x2F;Makefile.host:90: recipe for target &#39;scripts&#x2F;extract-cert&#39; failed</span><br><span class="line">make[1]: * [scripts&#x2F;extract-cert] Error 1</span><br><span class="line">Makefile:556: recipe for target &#39;scripts&#39; failed</span><br><span class="line">make: * [scripts] Error 2</span><br></pre></td></tr></table></figure><p>安装openssl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="1-4-TF分区配置"><a href="#1-4-TF分区配置" class="headerlink" title="1.4 TF分区配置#"></a>1.4 TF分区配置<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.4-tf%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE">#</a></h3><p>在上一篇中提到过u-boot 中的bootcmd 配置了Linux内核文件和设备树文件存放位置，即TF卡的0:1分区中，而且我们已经得到了对应的文件，那我们应该怎么操作呢。</p><p>还记得我们在上一篇中安装的Gparted软件吗，如果不记得，可以通过以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>把需要写入系统的TF卡插到电脑的USB上，打开该软件，可以看到此时有两个存储设备，一个是sda另一个是sdb，其中sdb就是我们的TF卡。如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009080733737-2007833399.png"><img src="/posts/3433483963/483434-20211009080733737-2007833399.png" class="" title="img"></a></p><p>选中sdb，我们可以看到分区表中显示为未分配，对于常规Linux嵌入式系统我们需要分两个区，一个是存放zImage和dtb文件，即在bootcmd中配置的0:1分区，另一个区存放根文件系统。对于第一个分区，格式为fat16格式，因为u-boot只能识别这个格式，对于第二个区，一般为ext4格式，为Linux内核识别的格式。下面开始分区吧。</p><p>选中未分配空间并右击鼠标，点击[新建]，然后填写相关属性，然后点击[添加],所示。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081003602-856502421.png"><img src="/posts/3433483963/483434-20211009081003602-856502421.png" class="" title="img"></a></p><p> 需要注意【之前的空余空间】选择1M，这是给u-boot预留的(u-boot在分区表中是无法看到的)，【新大小】选择32M ，【文件系统】选择fat16，【卷标】输入boot。</p><p>我们这里可以用相同的方式新建第二分区——ext4分区，如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081827144-1948779214.png"><img src="/posts/3433483963/483434-20211009081827144-1948779214.png" class="" title="img"></a></p><p> 这里我们设置为100M，文件系统为ext4，卷标为rootfs，然后添加添加。</p><p>配置好分区表后，点击工具来中的【对钩】使配置的分区表生效。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082014437-279426574.png"><img src="/posts/3433483963/483434-20211009082014437-279426574.png" class="" title="img"></a></p><p>配置分区完毕后，我们就可以在文件管理器中看到挂载的两个分区，如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082321646-1578987260.png"><img src="/posts/3433483963/483434-20211009082321646-1578987260.png" class="" title="img"></a></p><h3 id="1-5-内核复制与执行"><a href="#1-5-内核复制与执行" class="headerlink" title="1.5 内核复制与执行#"></a>1.5 内核复制与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.5-%E5%86%85%E6%A0%B8%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>那么，我们将刚才生成好的zImage和dtb文件复制到TF卡的BOOT分区中</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082706512-1631849134.png"><img src="/posts/3433483963/483434-20211009082706512-1631849134.png" class="" title="img"></a></p><p>退出TF卡，插入开发板，上电，按重启，我们就可以看到u-boot启动完成后，自动进入了内核启动环节，但是启动后一会就报错了，因为挂载文件系统产生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32)</span><br><span class="line">DRAM: 32 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Snail Card</span><br><span class="line">DRAM:  32 MiB</span><br><span class="line">MMC:   SUNXI SD&#x2F;MMC: 0</span><br><span class="line">*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">reading zImage</span><br><span class="line">4515448 bytes read in 231 ms (18.6 MiB&#x2F;s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">6105 bytes read in 26 ms (228.5 KiB&#x2F;s)</span><br><span class="line">## Flattened Device Tree blob at 80c00000</span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ff7d8 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 5.7.1 (twzy@ubuntu) (gcc version 7.2.1 20171011 (Linaro GCC 7.2-2017.11), GNU ld (Linaro_Binutils-2017.11) 2.28.2.20170706) #55 Tue Sep 28 21:04:24 CST 2021</span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr&#x3D;0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: LinuxCard by Kevin</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 8128</span><br><span class="line">[    0.000000] Kernel command line: console&#x3D;tty0 console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2  rw</span><br><span class="line">[    0.000000] Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache hash table entries: 2048 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 21496K&#x2F;32768K available (7168K kernel code, 403K rwdata, 1664K rodata, 1024K init, 246K bss, 11272K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] SLUB: HWalign&#x3D;32, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;1, Nodes&#x3D;1</span><br><span class="line"></span><br><span class="line"> …………………</span><br><span class="line"></span><br><span class="line">[    6.598874] Run &#x2F;etc&#x2F;init as init process</span><br><span class="line">[    6.603993] Run &#x2F;bin&#x2F;init as init process</span><br><span class="line">[    6.609078] Run &#x2F;bin&#x2F;sh as init process</span><br><span class="line">[    6.613763] Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class="line">[    6.629985] CPU: 0 PID: 1 Comm: swapper Not tainted 5.7.1 #55</span><br><span class="line">[    6.636727] Hardware name: Allwinner suniv Family</span><br><span class="line">[    6.642216] [&lt;c010d604&gt;] (unwind_backtrace) from [&lt;c010ab60&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class="line">[    6.651031] [&lt;c010ab60&gt;] (show_stack) from [&lt;c01165a4&gt;] (panic+0xe8&#x2F;0x2e4)</span><br><span class="line">[    6.658951] [&lt;c01165a4&gt;] (panic) from [&lt;c071d080&gt;] (kernel_init+0xd8&#x2F;0x110)</span><br><span class="line">[    6.666960] [&lt;c071d080&gt;] (kernel_init) from [&lt;c0100140&gt;] (ret_from_fork+0x14&#x2F;0x34)</span><br><span class="line">[    6.675547] Exception stack(0xc1835fb0 to 0xc1835ff8)</span><br><span class="line">[    6.681293] 5fa0:                                     00000000 00000000 00000000 00000000</span><br><span class="line">[    6.690714] 5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">[    6.700102] 5fe0: 00000000 00000000 00000000 00000000 00000013 00000000</span><br><span class="line">[    6.707633] Rebooting in 5 seconds..</span><br><span class="line">[   12.687513] Reboot failed -- System halted</span><br></pre></td></tr></table></figure><p>内核移植就基本结束了，要想让小板真正的运行起来，还需要Linux的文件系统，那开始吧。</p><h2 id="2-文件系统移植"><a href="#2-文件系统移植" class="headerlink" title="2.文件系统移植#"></a>2.文件系统移植<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D">#</a></h2><p> 根文件系统(rootfs)是内核启动后挂载的第一个文件系统，如果没有根文件系统，内核将无法开启shell以及其他进程。</p><blockquote><p>实际上内核启动后会先挂载一个虚拟的文件系统，这个虚拟文件系统是在内存中运行的，其主要运行核心进程，虚拟文件系统挂载之后才挂载硬盘（TF卡或者emmc）上的根文件系统。</p></blockquote><p>制作文件系统也有很多方式，如通过busyBox、Buildroot等工具制作。</p><p>本次使用Buildroot，制作过程相对简单，兼容性好，由于根文件系统制作比较简单。</p><p>进入buildroot官网</p><p><a href="https://buildroot.org/downloads">https://buildroot.org/downloads</a></p><p>这里选择buildroot2018.2.11版本，将下载好软件包传入Ubuntu系统中，然后解压并进入源码目录中，输入清理命令。主要用于初始化一些设置，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>然后输入以下命令进入配置界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时会终端进入图形配置界面，如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144509521-972063330.png"><img src="/posts/3433483963/483434-20211009144509521-972063330.png" class="" title="img"></a></p><h3 id="2-1-Target-options配置"><a href="#2-1-Target-options配置" class="headerlink" title="2.1 Target options配置#"></a><strong>2.1 Target options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.1-target-options%E9%85%8D%E7%BD%AE">#</a></h3><p>先选择<strong>Target options</strong>选项，进行对应芯片soc相关的配置，如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144541062-504084831.png"><img src="/posts/3433483963/483434-20211009144541062-504084831.png" class="" title="img"></a></p><p>配置如图所示，下面是对其的解释</p><ul><li>第一个选项为架构选择，这里选择ARM架构小端模式，</li><li>第二个为输出的二进制文件格式，这里选择EFL格式，</li><li>第三个为架构体系，这里选择arm926t，因为F1C200S&#x2F;F1C100S的架构就是这个架构，</li><li>第四个为矢量浮点处理器，这里不勾选，因为对于F1C200S&#x2F;F1C100S而言，其内部没有浮点运算单元，只能进行软浮点运算，也就是模拟浮点预运算。</li><li>第五个为应用程序二进制接口，这里选择EABI，原因是该格式支持软件浮点和硬件实现浮点功能混用。</li><li>第六个为浮点运算规则，这里使用软件浮点</li><li>第七个选择指令集，这里选择ARM指令集，因为thumb主要针对Cortex M系列而言的，对于运行操作系统的A系列以及ARM9和ARM11而言，使用的都是32位的ARM指令集。</li></ul><p>按【Tab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-2-Build-options配置"><a href="#2-2-Build-options配置" class="headerlink" title="2.2 Build options配置#"></a><strong>2.2 Build options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.2-build-options%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第二个<strong>Build options</strong>选项，配置如图</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150105319-120500590.png"><img src="/posts/3433483963/483434-20211009150105319-120500590.png" class="" title="img"></a></p><p>按T【ab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-3-Toolchain配置"><a href="#2-3-Toolchain配置" class="headerlink" title="2.3 Toolchain配置#"></a><strong>2.3 Toolchain配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.3-toolchain%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第三个<strong>Toolchain</strong>选项，配置如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150540766-1755147867.png"><img src="/posts/3433483963/483434-20211009150540766-1755147867.png" class="" title="img"></a></p><p>这里我们选择一些C\C++相关的库，这样我们就可以在开发板上直接编译程序了，保存返回。</p><h3 id="2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置"><a href="#2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置" class="headerlink" title="2.4 System configuration配置[#](https://www.cnblogs.com/twzy/p/15355842.html#2.4 system-configuration配置)"></a><strong>2.4 System configuration配置</strong>[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.4">https://www.cnblogs.com/twzy/p/15355842.html#2.4</a> system-configuration配置)</h3><p>对于<strong>System configuration</strong>选项，这里主要是配置一些系统登录时候显示的内容，配置如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009151624384-1186247221.png"><img src="/posts/3433483963/483434-20211009151624384-1186247221.png" class="" title="img"></a></p><p>这里主要配置了登录时候显示的内容和root账号登录密码，接下来保存配置并且退回到命令行界面。</p><p>然后执行构建文件系统命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>因为是首次编译，而且buildroot在制作文件系统的时候需要联网获取组件，所以会编译很久，那么“去和妲己玩耍吧”</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009153556289-1299034541.png"><img src="/posts/3433483963/483434-20211009153556289-1299034541.png" class="" title="img"></a></p><p>当你终于被别人坑的自闭的时候，文件系统大概也许可能已经编译完毕了。</p><h3 id="2-5-文件系统移植与执行"><a href="#2-5-文件系统移植与执行" class="headerlink" title="2.5 文件系统移植与执行#"></a>2.5 文件系统移植与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>此时在源码的<strong>output&#x2F;images</strong>目录下有一个rootfs.tar，这个文件就是最终生成的根文件系统镜像，现在只需要将该镜像解压到TF卡的第二分区即可。插入TF卡到电脑端，进入<strong>out&#x2F;images</strong>目录，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;&lt;你的用户名&gt;&#x2F;rootfs&#x2F;</span><br><span class="line"># 墨云的账号是twzy</span><br><span class="line">sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;twzy&#x2F;rootfs&#x2F;</span><br></pre></td></tr></table></figure><p>此时可以看到TF卡的rootfs分区中有文件系统了</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172303012-746246639.png"><img src="/posts/3433483963/483434-20211009172303012-746246639.png" class="" title="img"></a></p><p>插入开发板，连接好串口，打开串口助手或者其他串口终端软件，可以看到根文件系统成功挂载，同时进入shell交互，用户名默认为root，密码：123456，进入root账号后</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172655126-653041256.png"><img src="/posts/3433483963/483434-20211009172655126-653041256.png" class="" title="img"></a></p><p>那么恭喜，你已经拥有了自己的Linux发行版。</p><p>至此我们完成了全部的系统移植任务，从下一篇开始我们将会升级我们的硬件设备和做一些更加有意义的东西，期待吗？</p><h3 id="2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格"><a href="#2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格" class="headerlink" title="2.6 升级逼格[#](https://www.cnblogs.com/twzy/p/15355842.html#2.6 升级逼格)"></a>2.6 升级逼格[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.6">https://www.cnblogs.com/twzy/p/15355842.html#2.6</a> 升级逼格)</h3><p>我们发现登录进自制的Linux系统后，命令行前置无论怎样只显示一个**#**号，逼格略低呀，怎么处理呢？</p><p>修改&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1&#x3D;&#39;[\u@\h: \w\a\]$&#39;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172755348-361576513.png"><img src="/posts/3433483963/483434-20211009172755348-361576513.png" class="" title="img"></a></p><p>重启小板，就可以看到与与常规Linux一样的操作体验了，只是root账号的时候还是显示 <strong>$</strong> 符号</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173048942-1924983487.png"><img src="/posts/3433483963/483434-20211009173048942-1924983487.png" class="" title="img"></a></p><p>需要注意的是，在开发板运行过程中，如果想要重启，请先执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><p>命令正常关闭系统后，在按重启按钮，否则有很大概率回造成文件系统损坏。</p><h2 id="3-点个灯吧"><a href="#3-点个灯吧" class="headerlink" title="3. 点个灯吧#"></a>3. 点个灯吧<a href="https://www.cnblogs.com/twzy/p/15355842.html#3.-%E7%82%B9%E4%B8%AA%E7%81%AF%E5%90%A7">#</a></h2><p>还记得我们在第一篇中提到过的我们自制小开发板的唯一的那个外设——LED灯吗？</p><p>那我们就利用Linux提供的GPIO系统通过shell命令进行点灯实验吧。</p><p>我们首先需要回到文件系统制作菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt; </span><br><span class="line">        GPIO Support -&gt;</span><br><span class="line">                &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;… (sysfs interface)。</span><br></pre></td></tr></table></figure><p>按如下方式进行配置，然后编译完rootfs，重新写入小板</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173731029-1575334130.png"><img src="/posts/3433483963/483434-20211009173731029-1575334130.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009163731073-1479927383.png"><img src="/posts/3433483963/483434-20211009163731073-1479927383.png" class="" title="img"></a></p><p>通过硬件可知LED灯连接的是<strong>PE6</strong>接口，低电平亮灯</p><p>这里我们先要了解一下GPIO编号和值的计算方式</p><blockquote><p>引脚编号 &#x3D; 控制引脚的寄存器基数 + 控制引脚寄存器位数<br>批注：<br>引脚编号是gpiochipxxx下的base + 第几个GPIO，也就是base加偏移，偏移的是位数。<br>例如gpiochip34 下的第1个GPIO那么编号就是34 + 1 &#x3D; 35</p></blockquote><p>对于F1C200S&#x2F;F1C100S这里：A&#x3D;0、B&#x3D;1、C&#x3D;2D&#x3D;3、E&#x3D;4 ……、32是固定值、6就是偏移量</p><p>举个栗子（如果使想用 PE6，那么引脚编号就可能等于 4 x 32 + 6 &#x3D; 134。</p><p>这是一些参考命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1、导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line"># 2、设置方向</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 3、查看方向</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 4、设置输出（对于LED 设置1 为高电平即LED灯灭，设置0 为低电平，LED灯亮）</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 5、查看输出值</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 6、取消导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction # 灯亮 （默认设置为高电平）</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯灭 </span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯亮</span><br><span class="line"></span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173632837-1965450968.png"><img src="/posts/3433483963/483434-20211009173632837-1965450968.png" class="" title="img"></a></p><p> 我们这里借助Linux内建的GPIO子系统进行了电灯实验，但是真正Linux灵魂点灯是要通过驱动方式来实现的，但是谁让我是小白呢，以后再说吧。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_7275.html">小白自制Linux开发板(F1C200s)整理系列，持续更新中</a></li><li><a href="https://www.cnblogs.com/twzy/p/14714651.html">瞎抄原理图与乱画PCB</a></li><li><a href="https://www.cnblogs.com/twzy/p/14865952.html"> 二. u-boot移植</a></li><li><a href="https://www.cnblogs.com/twzy/p/15355842.html">三. Linux内核与文件系统移植</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">小白自制Linux开发板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zml3589110.github.io/posts/0.html"/>
    <id>https://zml3589110.github.io/posts/0.html</id>
    <published>2025-09-05T08:43:20.000Z</published>
    <updated>2025-09-15T10:01:53.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C200S一步到位编译法"><a href="#F1C200S一步到位编译法" class="headerlink" title="F1C200S一步到位编译法"></a>F1C200S一步到位编译法</h1><p>兜兜转转还是玩上了MangoPi-R3！因为是ARM9的芯片内核架构，所以总觉得过时了的，至少也要整个ARM-A7的架构芯片。</p><img src="/posts/0/f5689089589dcee6cd852c4468152336.png" class="" title="在这里插入图片描述"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://mangopi.cc/f1c_mainline">https://mangopi.cc/f1c_mainline</a><br><a href="https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780">https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这款微型开发板专为运行 Linux 而设计。尽管机身很小，但它具有所有重要功能。板载F1C200S作为主控芯片，提供多种常用外设端口：GPIO、I2C&amp;SPI、SDIO、Audio port(record,play), Video(RGB565 Display, touch, DVP), USB Host, OTG等. 此外，板卡内置64MB DDR和板载128MB Nand Flash，全面支持Linux生态，运行完整的Python。</p><p>目前该产品是完全开源的，用户可以根据自己的需求编译任意模块。但是，它主要面向 Python 开发人员和高级爱好者，因为它上手有点困难。</p><h3 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h3><table><thead><tr><th>芯片型号</th><th>F1C100S</th><th>F1C200S</th><th>F1C500S</th><th>F1C600</th></tr></thead><tbody><tr><td>内存</td><td>SIP 32MB DDR1</td><td>64MB DDR1</td><td>128MB DDR1</td><td>256MB DDR1</td></tr></tbody></table><ul><li>QFN88封装（10x10mm）</li><li>板载 128MB Nand Flash</li><li>ARM926EJ-S内核，420MHz系统时钟默认频率，可超频至700MHz及以上</li><li>丰富的 GPIO 引脚</li><li>板载 SDIO 接口，用于连接 SD 卡或 SDIO WiFi + BT 模块</li><li>DVP摄像头接口，支持OV2640、GC0328等摄像头。</li><li>RGB565显示接口和6线触摸接口</li><li>板载麦克风和功率放大器</li><li>低功耗</li><li>支持完整的Python运行</li></ul><h3 id="芯片优缺点"><a href="#芯片优缺点" class="headerlink" title="芯片优缺点"></a>芯片优缺点</h3><ul><li>缺点：主频过低，内核太古老（ARM9）</li><li>优点：便宜，内置DDR，资料丰富（老芯片的优势）</li></ul><h3 id="MangoPi的Buildroot一键编译"><a href="#MangoPi的Buildroot一键编译" class="headerlink" title="MangoPi的Buildroot一键编译"></a>MangoPi的Buildroot一键编译</h3><p>地址：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r">https://github.com/mangopi-sbc/buildroot-mangopi-r</a></p><p>安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rsync wget unzip build-essential git bc swig libncurses-dev libpython3-dev libssl-dev</span><br><span class="line">sudo apt install python3-distutils</span><br></pre></td></tr></table></figure><p>下载BSP包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mangopi-sbc/buildroot-mangopi-r</span><br></pre></td></tr></table></figure><h3 id="第一次编译"><a href="#第一次编译" class="headerlink" title="第一次编译"></a>第一次编译</h3><p>注意：构建固件不需要 Root 权限。</p><h3 id="应用默认配置"><a href="#应用默认配置" class="headerlink" title="应用默认配置"></a>应用默认配置</h3><p>注意：应用 defconfig 会将所有 buildroot 配置重置为默认值。</p><p>通常，您只需要应用一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot-mangopi-r</span><br><span class="line">make widora_mangopi_r3_defconfig</span><br></pre></td></tr></table></figure><h3 id="常规编译"><a href="#常规编译" class="headerlink" title="常规编译"></a>常规编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j16</span><br></pre></td></tr></table></figure><h3 id="如果更改了-DTS-或-kenrel-构建"><a href="#如果更改了-DTS-或-kenrel-构建" class="headerlink" title="如果更改了 DTS 或 kenrel 构建"></a>如果更改了 DTS 或 kenrel 构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-kernel.sh</span><br></pre></td></tr></table></figure><h3 id="如果更改了-Uboot，则构建"><a href="#如果更改了-Uboot，则构建" class="headerlink" title="如果更改了 Uboot，则构建"></a>如果更改了 Uboot，则构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-uboot.sh</span><br></pre></td></tr></table></figure><h3 id="加快构建进度"><a href="#加快构建进度" class="headerlink" title="加快构建进度"></a>加快构建进度</h3><p><strong>在百度云下载离线的 dl</strong><br>Buildroot 将在编译固件时下载源代码。您可以获取“dl”文件夹的可信存档以加快速度。 <a href="https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111">https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>没有搞清楚这里是怎么用的，现在是下载了两个包：</p><ul><li>buildroot-dl-20220130.zip</li><li>buildroot-mangopi-r-master.zip<br>是不是把buildroot-dl-20220130.zip解压到buildroot-mangopi-r-master目录里面呢？</li></ul><blockquote><p>明白了，把buildroot-dl-20220130.zip解压出来并改名为dl，然后再把dl移动到buildroot-mangopi-r-master.zip解压出来的文件夹目录里面去就行了，编译的好快 啊。</p></blockquote><p>最终编译完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;u-boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;u-boot-sunxi-with-spl.bin&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;bootfs.vfat&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;rootfs&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;rootfs.ext4&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): writing MBR</span><br><span class="line">board/allwinner/generic/genimage-nor.cfg:33: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.kqghzcncg8<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.kqghzcncg8/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0xa00000@0x600000)</span><br><span class="line">board/allwinner/generic/genimage-nand.cfg:39: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.cjWlxAkEjg<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.cjWlxAkEjg/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0x7700000@0x600000)</span><br><span class="line"></span><br><span class="line">real20m23.669s</span><br><span class="line">user93m8.759s</span><br><span class="line">sys31m2.006s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译出来的文件：buildroot-mangopi-r-master&#x2F;output&#x2F;images</p><p>一步到位，所有版本都编译出来了（牛逼！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootfs.vfat     rootfs.ext4        sysimage-sdcard.img</span><br><span class="line">devicetree.dtb  rootfs.squashfs    u-boot.bin</span><br><span class="line">kernel.itb      rootfs.tar         u-boot-sunxi-with-nand-spl.bin</span><br><span class="line">rootfs.cpio     splash.bmp         u-boot-sunxi-with-spl.bin</span><br><span class="line">rootfs.cpio.gz  sysimage-nand.img  zImage</span><br><span class="line">rootfs.ext2     sysimage-nor.img</span><br></pre></td></tr></table></figure><h3 id="刷固件"><a href="#刷固件" class="headerlink" title="刷固件"></a>刷固件</h3><p>指导说明文档：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md">https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md</a></p><p>Windows下失败了，转战Linux下烧录</p><h2 id="Linux下烧录"><a href="#Linux下烧录" class="headerlink" title="Linux下烧录"></a>Linux下烧录</h2><h3 id="使用sunxi-tools"><a href="#使用sunxi-tools" class="headerlink" title="使用sunxi-tools"></a>使用sunxi-tools</h3><p>sunxi-tools 是全志 SoC（全志科技开发的智能应用处理器 SoC）ARM 设备的命令行工具集合。</p><p>设置和安装 sunxi-tools</p><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-dev libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><p>下载代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>什么是dfu？ 设备固件升级（DFU）是一种独立于分销商和设备的机制，用于通过其制造商提供的改进版本来升级USB设备的固件，从而提供（例如）一种部署固件错误的方法修复。在固件升级操作过程中，USB 设备将有效地改变其工作模式，从而成为 PROM 编程器。按照官方 DFU 规范，任何类型的 USB 设备都可以实现此功能。DFU 还允许用户自由使用备份固件来刷新 USB 设备。结果之一是刷新的 USB 设备可以充当多种设备类型。</p><p>什么是 dfu-util？ dfu-util 是一个实现 USB DFU（通用串行总线设备固件升级）协议的主机 (PC) 程序。DFU 会将固件下载到通过 USB 连接的设备，或从设备下载固件。其应用范围从微控制器板等小型设备到手机设备。使用 dfu-util，您可以从支持 DFU 的设备下载&#x2F;上传固件。</p><p>通过 apt-get 安装 dfu-util</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dfu-util</span><br></pre></td></tr></table></figure><h3 id="安装putty"><a href="#安装putty" class="headerlink" title="安装putty"></a>安装putty</h3><p>putty 是一个 Telnet、SSH 和串口连接软件。</p><p>安装串口工具putty</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install putty</span><br></pre></td></tr></table></figure><p>打开串口调试软件putty</p><p>默认安装的情况下，putty被添加到&#x2F;usr&#x2F;bin目录下，所以可以直接在终端使用putty命令打开。</p><p>在ubuntu上找串口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ dmesg | grep tty</span><br><span class="line">[    0.004000] console [tty0] enabled</span><br><span class="line">[    1.247164] 00:05: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A</span><br><span class="line">[25931.988675] usb 2-2.2: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>由此可知，板子的串口是ttyUSB0</p><p>一般串口的名字在dev下，如果没有外接串口卡，默认是dev。</p><p>使用命令<code>ls /dev/ttyUSB0</code>查看是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ ls /dev/ttyUSB0</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>如果结果存在，则串口地址为&#x2F;dev&#x2F;ttyUSB0</p><p>在putty中填入串口，然后打开串口格式化</p><p>序列号：填写对应的序列号<br>速度：填写115200</p><img src="/posts/0/f788e924e13b4e0c9512ea233e08c6d4.png" class="" title="在这里插入图片描述"><blockquote><p>打开有问题时记得加<code>sudo putty</code></p></blockquote><h3 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h3><p>putty打开以后，就进入固件位置:<br>同时按下tiny200的开机键和rst键，然后松开</p><p>此时运行.\fel-uboot.sh脚本</p><img src="/posts/0/1e5e0df7bf4da9879602649309c9e1ef.png" class="" title="在这里插入图片描述"><p>putty里面就有打印数据了</p><p>然后等待操作完成后，在putty里面输入命令：mtd erase spi-nand0，格式化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U-Boot SPL 2020.07 (Feb 16 2022 - 01:28:19 +0000)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from FEL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2020.07 (Feb 16 2022 - 01:28:19 +0000) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Allwinner F1C100s Generic Device</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   mmc@1c0f000: 0, mmc@1c10000: 1</span><br><span class="line">Setting up a 800x480 lcd console (overscan 0x0)</span><br><span class="line">In:    serial</span><br><span class="line">Out:   vga</span><br><span class="line">Err:   vga</span><br><span class="line">Allwinner mUSB OTG (Peripheral)</span><br><span class="line">Hit any key to stop autoboot:  0</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">unrecognized JEDEC id bytes: ff, c8, 51</span><br><span class="line">Failed to initialize SPI flash at 0:0 (error -2)</span><br><span class="line">List of MTD devices:</span><br><span class="line">* spi-nand0</span><br><span class="line">  - device: spi-nand@1</span><br><span class="line">  - parent: spi@1c05000</span><br><span class="line">  - driver: spi_nand</span><br><span class="line">  - <span class="built_in">type</span>: NAND flash</span><br><span class="line">  - block size: 0x20000 bytes</span><br><span class="line">  - min I/O: 0x800 bytes</span><br><span class="line">  - OOB size: 128 bytes</span><br><span class="line">  - OOB available: 4 bytes</span><br><span class="line">  - 0x000000000000-0x000008000000 : <span class="string">&quot;spi-nand0&quot;</span></span><br><span class="line">=========================</span><br><span class="line">Boot Device: fel</span><br><span class="line">Boot Slot 0: empty</span><br><span class="line">Boot Slot 1: spi-nand</span><br><span class="line">=========================</span><br><span class="line">Booting from FEL...</span><br><span class="line">DFU waiting on SPI-NAND...</span><br><span class="line">musb-hdrc: peripheral reset irq lost!</span><br><span class="line">=&gt; mtd erase spi-nand0</span><br><span class="line">Erasing 0x00000000 ... 0x07ffffff (1024 eraseblock(s))</span><br><span class="line">=&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加文件权限<br>使用ll命令查看文件权限。</p><p>如果文件没有执行权限，则需要添加权限，通过以下命令添加权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x fel-uboot.sh</span><br><span class="line">chmod +x dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><h3 id="开始烧录"><a href="#开始烧录" class="headerlink" title="开始烧录"></a>开始烧录</h3><p>输入固件文件夹</p><p>按下开发板子上的 boot 按钮和 rst 按钮，然后松开rst按钮并运行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./fel-uboot.sh &amp;&amp; ./dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><p>开始烧录啦，挺壮观的！</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_28877125/article/details/123143116">mangopi R3–Allwinner F1C200S一步到位编译法</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Allwinner F1C200S一步到位编译法</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/categories/mangopi-R3/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/tags/mangopi-R3/"/>
    
  </entry>
  
  <entry>
    <title>全志f1c200s开发板设计</title>
    <link href="https://zml3589110.github.io/posts/3905997731.html"/>
    <id>https://zml3589110.github.io/posts/3905997731.html</id>
    <published>2025-09-05T07:15:20.000Z</published>
    <updated>2025-09-10T13:10:14.199Z</updated>
    
    <content type="html"><![CDATA[<p>开发板如图所示，模仿树莓派取了一个mango-pi的名字，haha~。<br>硬件主要参考了荔枝派nano和正点原子开发板。经过测试，全部功能正常。</p><img src="/posts/3905997731/985ac40194d0411885bbe6b33a72921a.jpeg" class="" title="请添加图片描述"><img src="/posts/3905997731/2a533be2bf2d1a5be799288c43c75be5.png" class="" title="在这里插入图片描述"><h2 id="芯片特征"><a href="#芯片特征" class="headerlink" title="芯片特征"></a>芯片特征</h2><ol><li>全志F1C200s与F1C100s的区别为F1C200s含有64M SIP RAM，而F1C100s只有32M SIP RAM。F1C200s支持1080p视频解码，F1C100s仅支持720p。</li><li>ARM9架构</li><li>主频 408MHz</li><li><strong>内置RAM简化设计</strong></li><li>支持从spi flash和SD卡启动</li></ol><img src="/posts/3905997731/f26481d46f8a51926a9cab2683435852.png" class="" title="在这里插入图片描述"><h2 id="开发板包含资源"><a href="#开发板包含资源" class="headerlink" title="开发板包含资源"></a>开发板包含资源</h2><ol><li>SD卡*1</li><li>SPI FLASH*1</li><li>调试串口通过type-C引出</li><li>USB-A接口*2</li><li>OTG*1</li><li>按键*2</li><li>调试RGB led*1</li><li>支持正点原子40p RGB屏幕接口和触摸屏IIC接口</li><li>引出串口1路。</li></ol><p>PCB和原理图：<br><strong>链接：<a href="https://pan.baidu.com/s/1M2AIeIsibin_yUDbtMdzwA">https://pan.baidu.com/s/1M2AIeIsibin_yUDbtMdzwA</a><br>提取码：e0xq</strong></p><p>(下载至 全志&#x2F;mango-pi下)</p><h1 id="mangopi自制linux开发板驱动适配进度"><a href="#mangopi自制linux开发板驱动适配进度" class="headerlink" title="mangopi自制linux开发板驱动适配进度"></a>mangopi自制linux开发板驱动适配进度</h1><h2 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h2><p>目前自制的mangopi设备驱动适配已完成部分包含：</p><ul><li>基于扫描的gpio-keys子系统适配</li><li>LED子系统适配</li><li>RGB接口LCD显示屏适配</li><li>ft5406触摸屏适配</li><li>博通RTL8188EUS无线网卡适配</li><li>PWM驱动适配</li><li>显示屏背光适配</li></ul><hr><p>以下这几项在下载到荔枝派源码时已经适配好了：</p><ul><li>SPI FLASH驱动</li><li>USB驱动</li><li>串口驱动</li></ul><img src="/posts/3905997731/985ac40194d0411885bbe6b33a72921a.jpeg" class="" title="请添加图片描述"><hr><p>mangopi内核代码和uboot代码是基于licheepi nano修改的。<br>mangopi有哪些外设资源可以看：<a href="https://blog.csdn.net/qq_27350133/article/details/124107951">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></p><p>内核源码：<strong><a href="https://github.com/LiangtaoZhong/linux-mangopi-kernel5.2">https://github.com/LiangtaoZhong/linux-mangopi-kernel5.2</a></strong><br>uboot源码：<strong><a href="https://github.com/LiangtaoZhong/uboot-mangopi">https://github.com/LiangtaoZhong/uboot-mangopi</a></strong></p><h2 id="过程记录博客"><a href="#过程记录博客" class="headerlink" title="过程记录博客"></a>过程记录博客</h2><ol><li><a href="https://blog.csdn.net/qq_27350133/article/details/124107951?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124181468?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】使用genimage工具制作img系统镜像</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124246500?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】Linux板卡刷写img镜像后对分区进行扩容&#x2F;调整分区大小</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124261591?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】不带中断引脚采用扫描的方式实现通用gpio-keys</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124560457?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】系统运行期间替换内核镜像和设备树</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124602894?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】RGB接口 LCD驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124619357?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】PWM驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124800980?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】屏幕背光驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124974526?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】FT5426触摸屏适配</a></li></ol><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_27350133/article/details/124107951">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124687320">mangopi自制linux开发板驱动适配进度</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志f1c200s开发板设计</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记F1C100S之u-boot编译过程记录</title>
    <link href="https://zml3589110.github.io/posts/2357015472.html"/>
    <id>https://zml3589110.github.io/posts/2357015472.html</id>
    <published>2025-09-05T07:15:20.000Z</published>
    <updated>2025-09-10T13:10:14.215Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通-自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就-高手勿喷高手勿喷高手勿喷"><a href="#本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通-自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就-高手勿喷高手勿喷高手勿喷" class="headerlink" title="本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通 :) 自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就~ 高手勿喷高手勿喷高手勿喷~~~"></a><strong>本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通 :) 自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就~ 高手勿喷高手勿喷高手勿喷~~~</strong></h5><p>由于是学习，所以采用了虚拟机安装ubuntu的方式，比较耐折腾，安装好后复制出来备份，需要重新安装系统的时候替换出来就可以了~<br>1、具体虚拟机安装ubuntu的过程在此不详细记录了，百度一堆一堆的。建议安装的时候断网，免得安装过程中下载插件。<br>2、安装好系统后，第一步先更新一下apt-get，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>备注：快速打开命令行的快捷键是Ctrl+Alt+t</p><img src="/posts/2357015472/apt-get.jpg" class="" title="更新apt-get"><p>3、紧着接安装git工具，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/git%E5%B7%A5%E5%85%B7.jpg" class="" title="安装git工具"><p>4、获取编译工具，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir f1c100s</span><br><span class="line">cd f1c100s</span><br></pre></td></tr></table></figure><p>以上是先建立了一个f1c100s的目录，然后进入f1c100s。也可以省去此步骤、没有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;releases.linaro.org&#x2F;components&#x2F;toolchain&#x2F;binaries&#x2F;7.2-2017.11&#x2F;arm-linux-gnueabi&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/none.jpg" class="" title="获取编译工具"><p>5、此时技巧来了，再次按Ctrl+Alt+t新建一个命令行窗口，拽取u-boot源码，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir uboot</span><br><span class="line">cd uboot</span><br></pre></td></tr></table></figure><p>当然上面两行诗创建uboot目录和进入uboot目录的命令，可以省去，没有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Lichee-Pi&#x2F;u-boot.git</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/u-boot%E6%BA%90%E7%A0%811.jpg" class="" title="拽取u-boot源码1"><p>这时等待拽取源码或者获取编译工具结束，静静的等待 ·-· 。。。<br>6、其实我们还可以做点别的<br>根据坛友们的经验，尤其是晕哥的<a href="https://whycan.cn/t_3019.html">全志开发资料精华汇总, 持续更新 (<strong><strong><strong>请大家继续补充</strong></strong></strong>**)</a>LinjieGuo的<a href="https://whycan.cn/t_3138.html">尝试从零构建F1C100s开发环境</a></p><p>需要补充安装下面这些包，具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br><span class="line">sudo apt-get install device-tree-compiler</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install swig python-dev python3-dev</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/libncurses5-dev.jpg" class="" title="libncurses5-dev"><img src="/posts/2357015472/device-tree-compiler.jpg" class="" title="device-tree-compiler"><p>7、待获取编译环境的命令行窗口获取完毕后，安装vim编辑器，不装用vi也可以，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><p>我也搞不清楚什么时候用apt install什么时候用apt-get install，好像喵过一眼是说这是两个组合命令，get是获取，apt是安装，不作数，我这里糊涂着呢~<br>另外，不管你开了多少个命令行，貌似只能有一个apt-get运行，如果有运行中的apt-get再运行会报错。</p><img src="/posts/2357015472/vim.jpg" class="" title="vim"><p>有关vim编辑器的使用自行百度补脑，不细说了~百度有很多。<br>8、解压编译环境，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxJf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/tar.jpg" class="" title="tar"><p>9、拷贝编译环境到&#x2F;opt&#x2F;目录，也就是平常说的安装，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r .&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi &#x2F;opt&#x2F;</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/cp.jpg" class="" title="cp"><p>10、配置编译环境，添加path环境变量，具体方法是用vim打开&#x2F;etc&#x2F;目录下面的bash.bashrc，在末尾添加<br>PATH&#x3D;”$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin”，这一行，具体操作是运行sudo vim &#x2F;etc&#x2F;bash.bashrc命令<br>然后按光标向下按键移动显示内容到最后面一行，再按光标向右键，移动到行尾，这时按“i”键，转化为插入模式。输入PATH&#x3D;”$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin”输入完后按ESC键，甭管显示什么，输入：wq保存退出即可。还是如前面提到的，具体怎么使用请百度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;bash.bashrc</span><br></pre></td></tr></table></figure><p>这里少截了一个图，借用后面更新source &#x2F;etc&#x2F;bash.bashrc命令的图吧~</p><img src="/posts/2357015472/bash.jpg" class="" title="bash"><p>添加的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;&quot;$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin&quot;</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/path.jpg" alt="path"><br><img src="https://whycan.cn/files/members/2412/wq.jpg" alt="wq"><br>最后运行更新命令，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;bash.bashrc</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/bash.jpg" class="" title="bash"><p>小试一下gcc是否正常，使用gcc显示版本号的方式测试安装是否正常，出来一堆，反正我看不懂~~~<br>命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -v</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/gcc.jpg" alt="gcc"><br>自此整个编译环境获取、配置完毕。嗷嗷嗷，忘记说了，觉得有必要提醒一下，<br>从步骤7开始，都是在最开始打开的那个窗口或者说是步骤4哪里的那个窗口才可以完成的。<br>也许在其他窗口执行会有问题。</p><p>11、关闭所有的命令行窗口，按Ctrl+Alt+t重新打开一个窗口（因为之前分开三个窗口操作，为了节省时间），<br>命令行窗口之间操作的内容比如安装了XX，是不会过度到操作窗口以外的，除非是后面新打开的命令行窗口，不严谨的描述~高手勿喷！<br>正题：进入uboot目录，在进入u-boot目录，反正最终你找的u-boot目录，进去就OK了，运行git branch -a查看分支。具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd uboot</span><br><span class="line">cd u-boot</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/gitbranch.jpg" alt="gitbranch"><br>选择nano-v2018.01分支，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/nano2018.jpg" alt="nano2018"></p><p>12、开始编译咯，运行命令make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_spiflash_defconfig指定配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_spiflash_defconfig</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/makearch1.jpg" alt="makearch1.jpg"><br>可视化配置，具体怎么配置坛内或者百度搜吧，我也不造~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm menuconfig</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/menuconfig.png" alt="menuconfig"></p><p>正式开始编译，运行命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j1</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/make_ok.png" alt="make_ok"><br>顺利编译<br><img src="https://whycan.cn/files/members/2412/makels.png" alt="makels"><br>其中末尾的J1是因为我电脑配置低，只分配给了虚拟机一个处理器，只有一个核心，可根据具体实际情况更改，核心数量越多编译越快。四核就是J4，J8都是土豪~~~~~</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_3269.html">学习笔记F1C100S之u-boot编译过程记录</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">学习笔记F1C100S之u-boot编译过程记录</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="uboot" scheme="https://zml3589110.github.io/tags/uboot/"/>
    
  </entry>
  
</feed>
