<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵逸尘个人博客</title>
  
  <subtitle>记录工作生活</subtitle>
  <link href="https://zml3589110.github.io/atom.xml" rel="self"/>
  
  <link href="https://zml3589110.github.io/"/>
  <updated>2025-09-15T09:59:25.695Z</updated>
  <id>https://zml3589110.github.io/</id>
  
  <author>
    <name>ZhaoYichen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>全志F1C200S F1C100S 介绍</title>
    <link href="https://zml3589110.github.io/posts/3233973243.html"/>
    <id>https://zml3589110.github.io/posts/3233973243.html</id>
    <published>2025-09-15T09:52:20.000Z</published>
    <updated>2025-09-15T09:59:25.695Z</updated>
    
    <content type="html"><![CDATA[<p>很久以前发现了一颗性价比极高而且比较好玩的SOC，加群请仔细阅读本博客（见DKTool界面，请备注“来自博客”）</p><p>那就是全志F1C100S F1C200S，其中F1C100S内置32MB DDR1内存，F1C200S内置64MB DDR1内存。</p><p>这个片子能从淘宝轻松的买到，如果找靠谱的店家或者找代理商的话，F1C100S 是10块钱一片，F1C200S是13块钱一片。</p><p>从淘宝买一定要注意分辨是拆机还是库存还是正规代理货源，千万别图便宜，拆机良率可能20%；</p><p> 根据用量，找代理商价格100s是9元多，200s是13块左右。我有靠谱的代理联系方式，并可提供BSP。</p><p>这么10来块钱，32MB 和 64MB 的外扩内存都买不到啊，用来驱动RGB屏幕啥的，STM32赶紧靠边站。</p><p>其实F1C100S F1C200S F1C500S F1C600 R6都是一个芯片，他们都是QFN88封装。</p><p>资源方面，</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右，也有720M出货的。</p><p>有人说可以跑到900MHz，但我没有成功，uboot还没起来就挂了。</p><p>带有100M的SPI接口，2个SDIO接口，1个USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口。</p><p>I2C I2S UART PWM等等。</p><p>因为引脚比较少，所以复用严重，但也是有考虑的，如果IO不够用，就使用I2C扩展IO。</p><p><img src="/%E5%85%A8%E5%BF%97f1c200s%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AE%BE%E8%AE%A1/f26481d46f8a51926a9cab2683435852.png" alt="f26481d46f8a51926a9cab2683435852"></p><p>我们玩的以F1C100S和F1C200S为主。</p><p>目前能从网上找到的只有F1C200S和F1C600的寄存器手册。其实他们里面的内容都是一模一样的。</p><p>目前能找到F1C200s和F1C600的完整数据手册和寄存器手册，当然完整是相对的，基础外设的寄存器都是开放的，高级解码部分是不开放的。</p><p>关于F1C100S&#x2F;F1C200S的资料，可以从挖坑网获得，whycan.cn（资料非常零散，找出自己需要的不易）</p><p>里面真是花式玩F1C100S，下面按照系统区分来列举一下：</p><p>1.流出的全志官方C600的BSP ，linux-3.10。支持硬解码编码，但不支持TVIN。可以从github搜到源码，因为C600面向的是智能音箱，所以bsp部分并没有默认支持显示屏，需要自己趟坑修改。其他问题不知。</p><p>2.全志官方的RTOS，名叫melis 2.0。这是全志自己的小系统，支持所有外设，硬件解码编码，TVIN,TVOUT各种外设，学习难度也是很大的，开发环境也是很难，如果能玩转，出些产品还是可以的。不过一般没人去研究他哈。（坑网可以获得）</p><p>3.全志官方的linux，名叫tina。有针对F1C200S的tina版本，3.0或者3.5，内核版本是linux3.10，这个软件支持部分比较丰富，还有比较完善的指导文档。不过这个资料是需要和代理商签NDA的，也就是保密协议，个人或小公司应该是不会被理会的吧。</p><p>4.社区支持的有linux-4.15，linux5.2，linux-5.6不支持硬解解码编码。其中荔枝派用的就是这个，有很多东西也是他们维护的。另外前一阵火的运行linux的名片用的就是这个片子。</p><p>5.XBOOT，九鼎xboot大佬支持的XBOOT，xboot是可以理解为裸机程序也可以理解为一个小系统，可以用来引导linux，也可以用来直接lua开发（很多人玩裸机或rtt从这里提炼驱动），直接用xboot开发也是比较方便的，在xboot群里有人做公司产品的。</p><p>6.RT-thread，这个最开始是RTT支持荔枝派做的，后来RTT有了融资，考虑盈利，把这一部分闭源了做了柿饼pie(串口屏)，在网上还能找到之前的资料。原来RTT官方支持的现在不能找到了，不过想玩RTT的饼子们，可以从github找第三方移植的RTT，现在支持了lcd和音频，资料还是不错的。有一个领头人@staunchheart ，他想玩RTT，大家可以找他一起完善 ，他已经可以用RTT的IDE studio进行开发了呢）</p><p>7.UCOS，这是xboot群的大佬，自己移植的ucos，把TVOUT都支持了，移植了NES模拟器，并做了掌机开发板，现在淘宝有售，名字叫小淘气科技，价格也很贵哟，人家可是付出了多少个夜晚研究出来的，有需求的希望支持一下，让做技术的人生活的更开心。</p><p>8.裸机keil开发，这是坑网达克罗德大神自己写的，在坑网上有资料，还可以用jlink调试开发。</p><p>9.VFS，这是simon大佬公司维护的项目，使用IAR，在单片机上跑裸机，并可以运行linux子系统。 </p><p>10.Aodzip大佬做了uboot kernel rootfs的buildroot的支持，并且uboot支持dfu下载程序，支持spi nor启动，spi nand启动，sdio0 4bit 的TF卡，SD NAND，emmc启动；sdio1 1bit 的tf卡或emmc或sd nand的启动。并且支持dfu烧写。好像还支持硬件解码编码，有大佬可以试试。</p><p>玩F1C200S的人大部分是想用来带屏的，所以GUI是大家关心的。 列举一些大家使用的GUI。</p><p>1、周立功的AWTK（首推，打算PDA就用这个了）</p><p>2、开源的littlevgl GUI</p><p>3、Qt</p><p>4、minigui</p><p>5、RTX</p><p>总之，这款片子被大家玩起来了。我也做了个核心板。</p><p>粗略算过，不算flash，核心的BOM成本在15块钱。如果全部自己手焊的话，一块板子不到20。</p><p>这是我画的板子，做了几十个挂淘宝已经卖完了。欢迎大家一起来玩，一起交流。</p><p>现在下图中的板子已经淘汰了，我又设计了新板子呢，而且在做手持机。现在没有可卖的了。如果有想要核心板PCB的话，我可以出售立创EDA工程文件，可以在本文中找到联系群号。我自己都没有可以用的了。</p><img src="/posts/undefined/3f290d98648cea18077fce729f0b23fb.jpeg" class="" title="img"><p>上图中最底部的两个板子就是最新的核心板，增加了LCD接口，也能接通用40PIN的显示屏了。但我没有 继续做下去，毕竟核心板并不好玩，做来卖也是赚不了几十块钱，而且很麻烦。有一款我在立创库里开源过，后来 无人问津就关闭了呢。</p><p>所以玩就玩的好， 想必各位买板子回去也是想接各种东西进行测试的，所以为什么不做一个集成的板子呢！</p><p>于是PDA开始设计。</p><img src="/posts/undefined/808e89637f87cbd53859891e93e16e6b.png" class="" title="img"><h1 id="DKTool"><a href="#DKTool" class="headerlink" title="DKTool"></a>DKTool</h1><p>同时呢， 为了方便烧写 固件什么的方便一些，我做个了windows下的图形烧录工具（其实就是封装了一下sunxi-fel）</p><p>1、支持监测插入电脑的芯片型号，判断是F1C100S还是F1C200S，</p><p>2、支持监测spi flash的容量</p><p>3、支持烧录文件到spi flash</p><p>4、支持读取spi flash数据以文件的方式存储</p><p>5、支持烧写文件到DDR</p><p>6、支持读取DDR中数据以文件方式存储</p><p>7、支持读写指定内存地址的32bit数据（可以读写ddr，也可以用来设置寄存器啥的）</p><p>8、我觉得最好的功能还就集成了USB驱动部分，DKTool驱动就是本工具使用的驱动，</p><p>另一个则是烧录全志官方BSP固件用的工具。</p><p>（全志BSP生成的固件内包含了很多东西，比较复杂，搞不懂）</p><img src="/posts/undefined/2802096db368dfe56fbcb5edf2e89bf4.png" class="" title="img"><img src="/posts/undefined/69cd843646efe61a9ae0e619e1bcab63.png" class="" title="img"><p>烧写工具还有很多BUG需要完善，所以不在这发布了。可以到群里去找，最新版本0229，不再更新。以后PDA出来再做配套软件，会加上可以烧写emmc等功能。</p><p>4层板的PDA正在进行中，还制作了钢网，OK了后续再更新。</p><p>PDA的硬件第一版有些不合理，又做了第二版，就是 下面的工程版PDA。</p><p>工程PDA算是OK了，知道了一些BUG，下一版不出问题就是正式版了，</p><p>另外，RGB屏已经驱动成功，音频带喇叭也已经驱动成功，N76E003的 烧录我要改版到可以使用一个Type-C口烧录。</p><p>N76E003模拟N多个额PCF8574。</p><p>不出现什么意外，今年看看能不能做出来。</p><p>2020今年家有喜事，暂时放下了一段时间，慢慢来吧。</p><p>下面绿色的框子不太好看，正式版用的是黑色亚克力。</p><p>2020年10月：</p><p>3寸屏太小了，板子上塞不了多少东西，于是我又换了一个屏幕3.5寸的（大显家的）。</p><p>在此说一下PDA的配置</p><p>CPU:F1C100S&#x2F;F1C200S</p><p>RAM:内置32MB&#x2F;64MB</p><p>Flash:TF卡槽焊盘+SD Nand焊盘+EMMC焊盘（看情况进行焊接）</p><p>音频：麦克风+iphone6以上高音质喇叭</p><p>接口：Type-C USB2.0 slave；充电、单片机&#x2F;SOC下载程序、串口调试单片机&#x2F;SOC、调试蓝牙模块</p><pre><code>       USB2.0 母口  可以插U盘</code></pre><p>按键：美上美优质滚轮编码器（手感贼棒！！！）</p><p>屏幕：3.5寸电容触摸 480*800分辨率 IPS屏 非全贴合</p><p>摄像头：OV5640 500万像素</p><p>WiFi：ESP8266EX  工作在sdio网卡模式，实测速度1MB&#x2F;S</p><p>蓝牙：杰里方案，支持连接手机，通过该蓝牙，可以手机放歌，当蓝牙音箱用；可以借助蓝牙功能，PDA实现打电话功能。可以BLE数据传输，通过微信小程序配置WIFI网络。</p><p>电源管理：暂时保密，同时锂电池充电管理</p><p>电池：诺基亚BL-5C  1000mAh</p><p>包边：不锈钢装饰条</p><p>正反面：亚克力广告贴（最终效果逼格高！）</p><p>2021年7月：</p><p>换屏了，3.8寸的带弧度的屏，这样做出来才像PDA</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">全志F1C200S F1C100S 介绍</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C200S F1C100S 介绍</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="DKTool" scheme="https://zml3589110.github.io/tags/DKTool/"/>
    
  </entry>
  
  <entry>
    <title>F1C200S使用keil5开发问题</title>
    <link href="https://zml3589110.github.io/posts/3416408887.html"/>
    <id>https://zml3589110.github.io/posts/3416408887.html</id>
    <published>2025-09-15T07:04:20.000Z</published>
    <updated>2025-09-15T07:07:35.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h2 id="Folders-x2F-Extensions报错"><a href="#Folders-x2F-Extensions报错" class="headerlink" title="Folders&#x2F;Extensions报错"></a>Folders&#x2F;Extensions报错</h2><img src="/posts/undefined/5aa9d2c17b19c786354a4e476f1acac8.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_44346906/article/details/136306006">keil5编译失败。‘Manage Project Items - Folders&#x2F;Extensions‘ to manage ARM Compiler Versions. ‘Options for</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序在Keil环境中开发问题收集</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/categories/Keil/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/tags/Keil/"/>
    
  </entry>
  
  <entry>
    <title>Web Serial网页串口</title>
    <link href="https://zml3589110.github.io/posts/3511617639.html"/>
    <id>https://zml3589110.github.io/posts/3511617639.html</id>
    <published>2025-09-10T13:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）"><a href="#使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）" class="headerlink" title="使用 Web Serial API 在浏览器中实现串口通讯（纯前端）"></a>使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>串口是非常常用的一种电脑与设备交互的接口。目前在浏览器上直接使用电脑上的串口设备了，这篇文章将介绍相关内容。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><strong>Web Serial API 相关内容参考如下：</strong></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Serial">https://developer.mozilla.org/en-US/docs/Web/API/Serial</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/SerialPort">https://developer.mozilla.org/en-US/docs/Web/API/SerialPort</a><br><a href="https://wicg.github.io/serial/">https://wicg.github.io/serial/</a></p><p><strong>这个API目前还处于实验性质，只有电脑上的Chrome、Edge、Opera等浏览器支持：</strong></p><img src="/posts/3511617639/dc7c13d0e94905685d30ef0d7b849e95.png" class="" title="在这里插入图片描述"><p><strong>另外还需要注意的是从网页操作设备是比较容易产生安全风险的，所以这个API只支持本地调用或者是HTTPS方式调用。</strong></p><p><strong>对于这个API谷歌有提供示例工程：</strong></p><p>在线使用：<a href="https://googlechromelabs.github.io/serial-terminal/">https://googlechromelabs.github.io/serial-terminal/</a><br>项目地址：<a href="https://github.com/GoogleChromeLabs/serial-terminal">https://github.com/GoogleChromeLabs/serial-terminal</a></p><p><strong>下面这个项目做的挺不错的，直接拿来用也很好：</strong></p><p>在线使用：<a href="https://itldg.github.io/web-serial-debug/">https://itldg.github.io/web-serial-debug/</a><br>项目地址：<a href="https://gitee.com/itldg/web-serial-debug">https://gitee.com/itldg/web-serial-debug</a> or <a href="https://github.com/itldg/web-serial-debug">https://github.com/itldg/web-serial-debug</a></p><img src="/posts/3511617639/5dfa19735e8d90d6a670175264b30bae.png" class="" title="在这里插入图片描述"><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><strong>使用下面方法可以侦测电脑上串口设备插入与拔出：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局串口设备插入事件</span></span><br><span class="line">navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial connected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局串口设备拔出事件</span></span><br><span class="line">navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial disconnected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以对单个的串口设备设置插入与拔出事件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用下面方法可以显示电脑上的串口设备选择授权，或者显示已授权的串口设备列表：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestPort方法将显示一个包含已连接设备列表的对话框，用户选择可以并授予其中一个设备访问权限</span></span><br><span class="line"><span class="comment">// 对于USB虚拟串口而言该方法还可以传入一个过滤器，指定PID&amp;VID的串口</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="keyword">await</span> navigator.serial.requestPort();</span><br><span class="line"><span class="comment">// port.forget(); // 取消授权</span></span><br><span class="line"><span class="comment">// port.getInfo() // 获取PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getDevices方法可以返回已连接的授权过的设备列表</span></span><br><span class="line"><span class="keyword">const</span> ports = <span class="keyword">await</span> navigator.serial.getPorts();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 open 方法打开选中的串口设备后就可以进行数据交互了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open时可以传入串口参数</span></span><br><span class="line"><span class="keyword">await</span> port.open(&#123;</span><br><span class="line">    baudRate: <span class="number">115200</span>,</span><br><span class="line">    <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span><br><span class="line">    <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span><br><span class="line">    <span class="comment">// flowControl: none, // 流控制，默认无</span></span><br><span class="line">    <span class="comment">// parity: none,      // 校验，默认无</span></span><br><span class="line">    <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>打开后就可以发送数据了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="comment">// const data= new Uint8Array(length);</span></span><br><span class="line"><span class="keyword">const</span> writer = port.writable.getWriter();</span><br><span class="line"><span class="keyword">await</span> writer.write(encoder.encode(<span class="string">&quot;PING&quot;</span>));</span><br><span class="line"><span class="comment">// await writer.write(data);</span></span><br><span class="line">writer.releaseLock();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>同样可以设置数据接收：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (port.readable) &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = port.readable.getReader();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Do something with |value|…</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// Handle |error|…</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.releaseLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据接收本身很简单，但需要注意的是在关闭串口前需要释放 reader 对象。</p><p><strong>下面是关闭串口操作：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 await port.close(); 即可关闭串口，如果正在读写数据，需要先释放相关资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keepReading = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readUntilClosed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (port.readable &amp;&amp; keepReading) &#123;</span><br><span class="line">    reader = port.readable.getReader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do something with |value|...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// Handle |error|...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      reader.releaseLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> port.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closed = readUntilClosed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sometime later...</span></span><br><span class="line">keepReading = <span class="literal">false</span>;</span><br><span class="line">reader.cancel();</span><br><span class="line"><span class="keyword">await</span> closed;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除了上面内容外还可以使用 setSignals 和 getSignals 来设置和获取流控制情况。</strong></p><h2 id="代码与演示"><a href="#代码与演示" class="headerlink" title="代码与演示"></a>代码与演示</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Serial API Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">button</span>,<span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">20rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">resize</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-x</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">5rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="string">&quot;serial&quot;</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert(&quot;Your browser support Web Serial API.&quot;); // 浏览器不支持 Web Serial API</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Your browser is not support Web Serial API.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备插入事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port connected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备拔出事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port disconnected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSelect&quot;</span>&gt;</span>select<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnOpen&quot;</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnClose&quot;</span>&gt;</span>close<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSend&quot;</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptOutput&quot;</span>&gt;</span>D0 D1 D2 D3 D4 D5 D6 D7<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptInput&quot;</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSelect = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSelect&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnOpen = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnOpen&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnClose = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnClose&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSend = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSend&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptOutput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptOutput&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptInput&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reader = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reading = <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 选择串口</span></span></span><br><span class="line"><span class="javascript">        btnSelect.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                port = <span class="keyword">await</span> navigator.serial.requestPort(); <span class="comment">// 弹出系统串口列表对话框，选择一个串口进行连接</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ports = <span class="keyword">await</span> navigator.serial.getPorts(); <span class="comment">// 获取已连接的授权过的设备列表</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ports);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// await port.forget(); // 取消授权</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(port.getInfo()); // 打印PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e); <span class="comment">// The prompt has been dismissed without selecting a device.</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateInputData</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data); <span class="comment">// event.data.buffer就是接收到的inputreport包数据了</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> hexstr = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> array) &#123;</span></span><br><span class="line"><span class="javascript">                hexstr += (<span class="built_in">Array</span>(<span class="number">2</span>).join(<span class="number">0</span>) + data.toString(<span class="number">16</span>).toUpperCase()).slice(-<span class="number">2</span>) + <span class="string">&quot; &quot;</span>; <span class="comment">// 将字节数据转换成（XX ）形式字符串</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            iptInput.value += hexstr;</span><br><span class="line"><span class="javascript">            iptInput.scrollTop = iptInput.scrollHeight; <span class="comment">// 滚动到底部</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 读取数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">listenReceived</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;On reading.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            reading = <span class="literal">true</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span> (port.readable &amp;&amp; reading) &#123;</span></span><br><span class="line">                reader = port.readable.getReader();</span><br><span class="line"><span class="javascript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span></span><br><span class="line">                        if (done) &#123;</span><br><span class="line"><span class="javascript">                            <span class="comment">// |reader| has been canceled.</span></span></span><br><span class="line"><span class="javascript">                            <span class="keyword">break</span>;</span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 需要特别注意的是：实际使用中即使对端是按一个个包发送的串口数据，接收时收到的也可能是分多段收到的</span></span></span><br><span class="line">                        updateInputData(value);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line">                    reader.releaseLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.close(); <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">            port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port closed.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 打开串口</span></span></span><br><span class="line"><span class="javascript">        btnOpen.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (port === <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not selected.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.open(&#123;</span></span><br><span class="line">                baudRate: 115200,</span><br><span class="line"><span class="javascript">                <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// flowControl: none, // 流控制，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// parity: none,      // 校验，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">            listenReceived();</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port opened.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">        btnClose.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                reading = <span class="literal">false</span>;</span></span><br><span class="line">                reader?.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取发送窗口十六进制字符串转换为字节数组</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getOutputData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> outputDatastr = iptOutput.value.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 去除所有空白字符</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (outputDatastr.length % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; <span class="regexp">/^[0-9a-fA-F]+$/</span>.test(outputDatastr)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取字节数组长度</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> byteLength = outputDatastr.length / <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 创建字节数组</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> outputData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteLength);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 将字符串转成字节数组数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteLength; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    outputData[i] = <span class="built_in">parseInt</span>(outputDatastr.substr(i * <span class="number">2</span>, <span class="number">2</span>), <span class="number">16</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 返回数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> outputData;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">throw</span> <span class="string">&quot;Data is not even or 0-9、a-f、A-F&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送数据</span></span></span><br><span class="line"><span class="javascript">        btnSend.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> writer = port.writable.getWriter();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> writer.write(getOutputData()); <span class="comment">// 发送数据</span></span></span><br><span class="line">            writer.releaseLock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面测试时我将串口的TX&#x2F;RT短接在一起，发送什么数据就会收到什么数据：</p><img src="/posts/3511617639/0256cd59c4a24e64aa50d9562bd40a80.gif" class="" title="在这里插入图片描述"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Web Serial API 访问串口非常方便，目前来说唯一的问题是这还是实验性质的功能，可能之后接口还会变动，需要根据实际情况进行调整。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/132522118">使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Web Serial网页串口</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/categories/Web/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>全志F1C100s使用记录</title>
    <link href="https://zml3589110.github.io/posts/968082855.html"/>
    <id>https://zml3589110.github.io/posts/968082855.html</id>
    <published>2025-09-10T11:59:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料索引与基础说明"><a href="#资料索引与基础说明" class="headerlink" title="资料索引与基础说明"></a>资料索引与基础说明</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最早接触到F1C100s是前两年的一个文章，里面使用F1C100s制作了一张可以运行Linux的名片，就是下图这个。下图上实际电路部分就占用角落一点点面积，当时觉得蛮有意思的的，可以跑Linux的开发板可以做这么小，成本和常见单片机最小系统板差不多，用来玩挺有意思的。</p><img src="/posts/968082855/b51b5b133d25d5997d2a341c993397b5.png" class="" title="在这里插入图片描述"><p>在这里文章里了解到 Sipeed Lichee Nano （荔枝派Nano），这个差不多可以当作F1C100s的最小系统板板用了，某宝一搜一大片，当时价格还不错，这两年因为疫情等各种原因价格上涨不少。</p><img src="/posts/968082855/3d4704387a6e3e446f72b4c9251458a6.png" class="" title="在这里插入图片描述"><p>这篇文章将介绍下上手玩F1C100s需要的一些基础信息，方便回头查询使用。</p><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><ul><li><strong>linux-sunxi community</strong><br><a href="https://linux-sunxi.org/Main_Page%E5%85%A8%E5%BF%97SoCs%E7%A4%BE%E5%8C%BAlinux">https://linux-sunxi.org/Main_Page全志SoCs社区linux</a> wiki，全志除了新出的基于RISC-V的D1，其它的芯片资料都是不开放的，mainlinux相关的开发都是由社区维护的，主要资料就是在这里；<br><strong>全志的芯片都以 <code>sunxi</code> 来指代，后面凡是看到 <code>sunxi</code> 或是 <code>sun\*</code> 的内容可能就是全志相关的内容；</strong>比如F1C100s就关联 <em>suniv</em> ；<br><a href="https://linux-sunxi.org/F1C100s">https://linux-sunxi.org/F1C100s</a><br>上面可以下载到F1C100s芯片的一些文档；</li><li><strong>WhyCan Forum(哇酷开发者社区)</strong><br><a href="https://whycan.com/index.html">https://whycan.com/index.html</a><br>这个论坛虽然嵌入式相关的内容都有涉及，但目前主要还是全志相关的内容多些；<br><a href="https://whycan.com/t_717.html">https://whycan.com/t_717.html</a><br>上面这篇文章中有很多F1C100s相关的例子资料等；<br><a href="https://whycan.com/t_3177.html">https://whycan.com/t_3177.html</a><br>F1C100s开发时的一个坑，编译工具链引起的问题；</li><li><strong>荔枝派Nano 全流程指南 与 资料下载</strong><br><a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a><br><a href="https://dl.sipeed.com/shareURL/LICHEE/Nano">https://dl.sipeed.com/shareURL/LICHEE/Nano</a></li><li><strong>My Business Card Runs Linux</strong><br><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/">https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a><br>这个就是开头说的那个可以运行Linux的名片的文章；</li></ul><h2 id="u-boot-amp-linux"><a href="#u-boot-amp-linux" class="headerlink" title="u-boot &amp; linux"></a>u-boot &amp; linux</h2><p>F1C100s玩的最多的就是拿来搞Linux玩，重要的是针对该芯片的uboot和linux的修改，这里收集了一些主要的项目：</p><p><strong>u-boot</strong></p><ul><li><a href="https://github.com/Icenowy/u-boot">https://github.com/Icenowy/u-boot</a><br>这个项目有 <em>f1c100s</em> 和 <em>f1c100s-spiflash</em> 两个分支，后者更加新点；<br>分支中有 <em>licheepi_nano_defconfig</em> 和 <em>licheepi_nano_spiflash_defconfig</em> 两个配置文件；</li><li><a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a><br>这个项目包含荔枝派所有的u-boot，对于F1C100s而言则是在前面项目的 f1c100s-spiflash 分支基础上新增了 <em>nano-lcd800480</em> 分支，增加了对lcd的支持；</li></ul><p><strong>linux</strong></p><ul><li><p><a href="https://github.com/Icenowy/linux">https://github.com/Icenowy/linux</a><br>这个项目主要查看 <em>f1c100s</em> 分支；</p></li><li><p><a href="https://github.com/Lichee-Pi/linux">https://github.com/Lichee-Pi/linux</a><br>这个项目目前主要查看 <em>nano-4.14-exp</em> 、 <em>nano-5.2-tf</em> 、 <em>nano-5.2-flash</em> 三个分支；<br><em>nano-4.14-exp</em> 分支是在前面项目的基础上修复了一个bug，这个分支可以下载<br><a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 这个配置文件进行测试；</p></li></ul><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>F1C100s是全志的一颗比较便宜的芯片，其功能框图如下：</p><img src="/posts/968082855/7bf76defe2cb6abf7faeb95d27d9338c.png" class="" title="在这里插入图片描述"><p>典型应用如下：</p><img src="/posts/968082855/42ce2ee954569f4714c54cc5d205035e.png" class="" title="在这里插入图片描述"><ul><li><strong><code>F1C100s的内核是 ARM926EJ-S ，ARMv5架构，有MMU，没有硬件FPU，主频默认为408MHz；</code></strong></li><li><strong><code>F1C100s内置32MB DDR1内存；</code></strong></li><li><strong><code>F1C200s是F1C100s的兄弟型号，其它特性都相同，内存容量翻倍为64MB；</code></strong></li></ul><p>F1C100s和F1C200s价格便宜的时候可以在1~2刀左右，带有LCD、摄像头、音频、视频等接口，还内置几十兆内存，用来简单的点屏使用比单片机之类的好多了。所以经常可以看到用F1C100s来做行车记录仪或是复古游戏机等产品。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>F1C100s的启动过程在它流出的手册中并没有找到相关描述，在 <em>全志V3s</em> 的 <em>DataSheet</em> 的 <em>4.2. Boot System</em> 章节中倒是有相似描述，可以作为参考：</p><img src="/posts/968082855/c0effa5c4bcc99fcb1419b633e545da2.png" class="" title="在这里插入图片描述"><p>芯片上电启动后，芯片会先执行内部固化的程序（BROM），该程序会依次检查外部存储器是否可用，如果可用再从中加载第二阶段程序（SPL）并执行。如果前面过程失败了则会进入全志系列处理器内置的FEL模式。</p><p><strong>对于F1C100s而言启动时寻找用户程序的位置顺序如下：</strong></p><ul><li>SDC0接口（<em>PF0~PF5</em>）上的SD（TF）卡；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nor Flash；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nand Flash；</li></ul><p><strong>对于SD（TF）卡而言在它上面的数据存储布局通常如下****：</strong></p><table><thead><tr><th>start</th><th>sector</th><th>size</th><th>usage</th></tr></thead><tbody><tr><td>0KB</td><td>0</td><td>8KB</td><td>Unused, available for an MBR or (limited) GPT partition table</td></tr><tr><td>8KB</td><td>16</td><td>32KB</td><td>Initial SPL loader</td></tr><tr><td>—-</td><td>—-</td><td>———</td><td>——————</td></tr><tr><td>40KB</td><td>80</td><td>Max 984KB</td><td>U-Boot</td></tr><tr><td>1MB</td><td>2048</td><td>-</td><td>bootfs and rootfs</td></tr></tbody></table><p>上面参数中SPL从8K位置开始不能动（这是由BROM决定的）；文件系统可以根据需要来分区，boot分区在前，通常为FAT格式。</p><p>如果使用上文列出的那些 u-boot 项目，编译后会得到 <strong>u-boot-sunxi-with-spl.bin</strong> 这个文件会拼合 spl 和 u-boot ，直接把这个文件写入到 8KB 开始的位置就行了。</p><p>更多内容可以参考：<a href="https://linux-sunxi.org/Bootable_SD_card">https://linux-sunxi.org/Bootable_SD_card</a></p><p><strong>对于SPI Flash</strong>而言其实和SD（TF）卡而言差不多，最关键的就是将 <em>u-boot-sunxi-with-spl.bin</em> 文件放在头部，即从0位置开始写入；其它内容根据需求而设置，只要对应的调整 u-boot 读取启动内核时相关位置参数就行。</p><p>需要注意的是默认情况下SPI Flash最大支持16M，更大就需要在程序中设置bank了。</p><h2 id="FEL模式"><a href="#FEL模式" class="headerlink" title="FEL模式"></a>FEL模式</h2><p>上文中可以了解到F1C100s要是启动外部程序均失败的话就会进入FEL模式，用户可以通过USB和芯片进行交互 。在FEL模式你可以直接运行 u-boot 和 linux 等，也可以将数据写入spiflash中（可以用作烧录固件到设备中）。</p><p>FEL模式其实也就是BROM上的一段程序，可以在 <code>u-boot</code> 命令行中使用 <code>go 0xffff0020</code> 跳转进入。另外也可以通过在SD（TF）卡写入下面数据来通过SD（TF）卡启动跳转：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sdX 为SD（TF）卡，使用 sudo fdisk -l 查看</span></span><br><span class="line"><span class="comment"># 如果有自动挂载的分区则逐条使用 sudo umount /dev/sdXn 进行卸载</span></span><br><span class="line">wget https://github.com/linux-sunxi/sunxi-tools/raw/master/bin/fel-sdboot.sunxi</span><br><span class="line">sudo dd <span class="keyword">if</span>=fel-sdboot.sunxi of=/dev/sdX bs=1024 seek=8</span><br></pre></td></tr></table></figure><p>如果外接了SPI Flash，并且SPI Flash中有可运行的程序的话可以将F1C100s的 <em>Pin60 - PC1 - SPI0_CS</em> 即 SPI Flash 的 1 脚接地后进入FEL模式。</p><p>为了和FEL模式下的芯片交互我们还需要用到 <em>sunxi-tools</em> 工具包，针对运行程序或烧录等操作需要用到其中的 <em>sunxi-fel</em> 工具，工具包项目地址如下：<br><a href="https://github.com/Icenowy/sunxi-tools">https://github.com/Icenowy/sunxi-tools</a></p><p>针对F1C100s的 <em>sunxi-fel</em> 工具可以使用下面方式下载、编译、安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-1.0-0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译完成后可以使用下面方式安装到系统目录</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br><span class="line"><span class="comment"># 不过其实不推荐安装到系统目录，因为全志不同的芯片需要用不同分支的sunxi-tools</span></span><br><span class="line"><span class="comment"># 更加推荐使用时临时添加环境目录，比如下面这样</span></span><br><span class="line"><span class="comment"># export PATH=$PATH:sunxi-tools目录路径</span></span><br><span class="line"><span class="comment"># 这种方式使用时需要用下面方式</span></span><br><span class="line"><span class="comment"># sudo `which sunxi-fel` [-选项] 命令 参数</span></span><br></pre></td></tr></table></figure><p>安装完成后可以使用 <code>sudo sunxi-fel -l</code> 列出所有处于FEL模式的设备、使用 <code>sudo sunxi-fel ver</code> 设备 BROM 信息：</p><img src="/posts/968082855/4914896309688605f6efd130124b559b.png" class="" title="在这里插入图片描述"><p>可以使用 <code>sudo sunxi-fel uboot /path/u-boot-sunxi-with-spl.bin</code> 来直接运行u-boot程序；</p><p>可以使用 <code>sudo sunxi-fel -p spiflash-write addr file</code> （addr常用0）将数据写入spiflash（注意最大16M，再大可能需要改程序）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./sunxi-fel [options] <span class="built_in">command</span> arguments... [<span class="built_in">command</span>...]</span><br><span class="line">        -v, --verbose                   Verbose logging</span><br><span class="line">        -p, --progress                  <span class="string">&quot;write&quot;</span> transfers show a progress bar</span><br><span class="line">        -l, --list                      Enumerate all (USB) FEL devices and <span class="built_in">exit</span></span><br><span class="line">        -d, --dev bus:devnum            Use specific USB bus and device number</span><br><span class="line">            --sid SID                   Select device by SID key (exact match)</span><br><span class="line"></span><br><span class="line">        spl file                        Load and execute U-Boot SPL</span><br><span class="line">                If file additionally contains a main U-Boot binary</span><br><span class="line">                (u-boot-sunxi-with-spl.bin), this <span class="built_in">command</span> also transfers that</span><br><span class="line">                to memory (default address from image), but won<span class="string">&#x27;t execute it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        uboot file-with-spl             like &quot;spl&quot;, but actually starts U-Boot</span></span><br><span class="line"><span class="string">                U-Boot execution will take place when the fel utility exits.</span></span><br><span class="line"><span class="string">                This allows combining &quot;uboot&quot; with further &quot;write&quot; commands</span></span><br><span class="line"><span class="string">                (to transfer other files needed for the boot).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        hex[dump] address length        Dumps memory region in hex</span></span><br><span class="line"><span class="string">        dump address length             Binary memory dump</span></span><br><span class="line"><span class="string">        exe[cute] address               Call function address</span></span><br><span class="line"><span class="string">        reset64 address                 RMR request for AArch64 warm boot</span></span><br><span class="line"><span class="string">        readl address                   Read 32-bit value from device memory</span></span><br><span class="line"><span class="string">        writel address value            Write 32-bit value to device memory</span></span><br><span class="line"><span class="string">        read address length file        Write memory contents into file</span></span><br><span class="line"><span class="string">        write address file              Store file contents into memory</span></span><br><span class="line"><span class="string">        write-with-progress addr file   &quot;write&quot; with progress bar</span></span><br><span class="line"><span class="string">        write-with-gauge addr file      Output progress for &quot;dialog --gauge&quot;</span></span><br><span class="line"><span class="string">        write-with-xgauge addr file     Extended gauge output (updates prompt)</span></span><br><span class="line"><span class="string">        multi[write] # addr file ...    &quot;write-with-progress&quot; multiple files,</span></span><br><span class="line"><span class="string">                                        sharing a common progress status</span></span><br><span class="line"><span class="string">        multi[write]-with-gauge ...     like their &quot;write-with-*&quot; counterpart,</span></span><br><span class="line"><span class="string">        multi[write]-with-xgauge ...      but following the &#x27;</span>multi<span class="string">&#x27; syntax:</span></span><br><span class="line"><span class="string">                                          &lt;#&gt; addr file [addr file [...]]</span></span><br><span class="line"><span class="string">        echo-gauge &quot;some text&quot;          Update prompt/caption for gauge output</span></span><br><span class="line"><span class="string">        ver[sion]                       Show BROM version</span></span><br><span class="line"><span class="string">        sid                             Retrieve and output 128-bit SID key</span></span><br><span class="line"><span class="string">        clear address length            Clear memory</span></span><br><span class="line"><span class="string">        fill address length value       Fill memory</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>对于Windows上装虚拟机来操作的话这之间还有一个坑：默认情况下FEL模式的USB设备Windows是无法识别的，这样就更没法传递给虚拟机使用了。这个问题可以使用 <a href="https://zadig.akeo.ie/">https://zadig.akeo.ie/</a> 这个工具来安装驱动解决（主要关注VID和PID就行）：</p><img src="/posts/968082855/d87e33cc9a73f2a6abb879e47a64a048.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/ac578738576c24cc2425ccc38f0d0748.png" class="" title="在这里插入图片描述"><p>除了 <em>sunxi-fel</em> ，也可以使用第三方的 <em>XFEL</em> 工具来进行FEL模式下的交互操作， <em>XFEL</em> 还有提供windows版本的可执行文件。项目地址如下：<br><a href="https://github.com/xboot/xfel">https://github.com/xboot/xfel</a></p><p>关于FEL模式的更多内容可以参考下面链接：<br><a href="https://linux-sunxi.org/FEL">https://linux-sunxi.org/FEL</a><br><a href="https://linux-sunxi.org/FEL/USBBoot">https://linux-sunxi.org/FEL/USBBoot</a></p><h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><p>电路设计上主要有下面一些注意点：</p><ul><li><strong>SD（TF）卡连接在SDC0</strong><br><code>Pin53 - PF5 - SDC0_D2</code><br><code>Pin54 - PF4 - SDC0_D3</code><br><code>Pin55 - PF3 - SDC0_CMD</code><br><code>Pin56 - PF2 - SDC0_CLK</code><br><code>Pin57 - PF1 - SDC0_D0</code><br><code>Pin58 - PF0 - SDC0_D1</code></li><li><strong>SPI Flash连接在SPI0</strong><br><code>Pin59 - PC0 - SPI0_CLK</code><br><code>Pin60 - PC1 - SPI0_CS</code><br><code>Pin61 - PC2 - SPI0_MISO</code><br><code>Pin62 - PC3 - SPI0_MOSI</code></li><li><strong>FEL模式通过USB通讯</strong><br><code>Pin68 - USB-DM</code><br><code>Pin69 - USB-DP</code></li><li><strong>控制台交互通过UART0</strong><br><code>Pin48 - PE1 - UART0_TX</code><br><code>Pin49 - PE0 - UART0_RX</code></li><li><strong>供电</strong><br><code>VCC-CORE - 1.0~1.2V</code><br><code>VCC-DRAM - 2.3~2.7V</code> <code>SVREF - 通过电阻将VCC-DRAM分压成一半</code><br><code>AVCC - 2.5~3.1V</code><br><code>VCC-IO / UVCC / HPVCC / TV_VCC - 2.5~3.1V</code></li></ul><p>电路设计上可以参考 荔枝派Nano 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/7bc367ee1b31ab3fc06a93c7b97acccf.png" class="" title="在这里插入图片描述"><p>如果对电路功能上没啥需求，只需要跑个Linux玩的话可以参考 Business Card 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/231b714136edcf31d159cd2ecfbd7d67.png" class="" title="在这里插入图片描述"><h1 id="u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）"><a href="#u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）" class="headerlink" title="u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）"></a>u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>测试用开发板可以参考上面文章中电路绘制，或者也可以直接购买荔枝派Nano进行测试。</p><img src="/posts/968082855/fff757aeb13d7b8676e87b0322bc8c83.png" class="" title="在这里插入图片描述"><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>下载安装Ubuntu Desktop（使用版本为20.04）：<br><a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p><p>安装完成后进行基础环境安装与设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install -y build-essential</span><br><span class="line">sudo apt install -y libusb-1.0-0-dev zlib1g-dev</span><br><span class="line">sudo apt install -y pkg-config</span><br><span class="line">sudo apt install -y python python3 python-dev python3-dev</span><br><span class="line">sudo apt install -y swig</span><br><span class="line">sudo apt install -y libncurses-dev libncurses5-dev</span><br><span class="line">sudo apt install -y libssl-dev</span><br><span class="line">sudo apt install -y kpartx</span><br><span class="line">sudo apt install -y mtd-utils</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为需要从GitHub下载项目所以还要安装git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y git</span><br><span class="line"><span class="comment"># git使用时可能需要设置用户名和邮箱</span></span><br><span class="line"><span class="comment"># git config --global user.name &quot;naisu&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email naisu@example.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立工作目录并进入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本文将工作目录设置在用户目录（$HOME）下的f1c100s-sdk文件夹中</span></span><br><span class="line"><span class="comment"># cd ~</span></span><br><span class="line">mkdir f1c100s-sdk</span><br><span class="line"><span class="built_in">cd</span> f1c100s-sdk/ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="制作toolchain和rootfs"><a href="#制作toolchain和rootfs" class="headerlink" title="制作toolchain和rootfs"></a>制作toolchain和rootfs</h2><p>为了方便这里使用buildroot来制作rootfs，这里有个坑。这里如果使用linaro等组织提供的现成的交叉编译工具链来编译buildroot项目生成rootfs，在使用时系统启动过程中可能会出现 Kernel panic - not syncing: Attempted to kill init! exitcode&#x3D;0x0000000b ，而使用buildroot自己生成的编译工具链就不会出现这个问题了。所以我们这里统一使用buildroot生成的编译工具链。</p><p>下载、解压与配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">wget https://buildroot.org/downloads/buildroot-2022.02.tar.xz</span><br><span class="line">tar -xJf buildroot-2022.02.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入buildroot-2022.02目录</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2022.02/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行配置</span></span><br><span class="line"><span class="comment"># 这里做测试使用，只要配置下目标和工具链即可，详见后面截图</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/posts/968082855/8497be47fe917fc84b72e565f9bec9e2.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/8935dd6dc710379acf7c9b4a3ef3da4e.png" class="" title="在这里插入图片描述"><p>编译完成后 <em>output</em> 目录下的 <em>host</em> 目录中就是交叉编译工具链（toolchain）； <em>output</em> 目录下的 <em>images</em> 目录中的 <em>rootfs.tar</em> 就是生成的根文件系统。</p><h3 id="设置编译工具链"><a href="#设置编译工具链" class="headerlink" title="设置编译工具链"></a>设置编译工具链</h3><p><strong>注意PATH使用自己的路径，每次打开终端都需要重新设置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabi-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/nx/f1c100s-sdk/buildroot-2022.02/output/host/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="u-boot-amp-linux编译"><a href="#u-boot-amp-linux编译" class="headerlink" title="u-boot &amp; linux编译"></a>u-boot &amp; linux编译</h2><h3 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h3><p>下载、配置、编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-lcd800480 --depth=1 https://github.com/Lichee-Pi/u-boot.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入u-boot目录</span></span><br><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置文件</span></span><br><span class="line">make licheepi_nano_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认bootcmd</span></span><br><span class="line">gedit include/configs/suniv.h</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND <span class="meta-string">&quot;run distro_bootcmd&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后就可以编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后当前目录下的 <em>u-boot-sunxi-with-spl.bin</em> 文件就是我们需要的。</p><h3 id="boot-scr"><a href="#boot-scr" class="headerlink" title="boot.scr"></a>boot.scr</h3><p>根据上面对bootcmd的修改，u-boot启动时会从第一分区读取 <em>boot.scr</em> 文件，并执行其中的脚本。我们可以通过这个来设置要传递给linux内核的参数、来加载内核和设备树、来启动内核。</p><p>在uboot目录下新建boot.cmd文件，向其中写入u-boot要执行的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">touch boot.cmd</span><br><span class="line">gedit boot.cmd</span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置传递给内核的bootargs参数</span></span><br><span class="line"><span class="comment"># 读取内核镜像和设备树到内存中指定位置</span></span><br><span class="line"><span class="comment"># 启动内核程序</span></span><br><span class="line">setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">load mmc 0:1 0x80008000 zImage</span><br><span class="line">load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">bootz 0x80008000 - 0x80C00000</span><br></pre></td></tr></table></figure><p>使用u-boot编译后tools目录下的 <em>mkimage</em> 工具可以将boot.cmd文件生成为 <em>boot.scr</em> 文件，通过下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm架构；不压缩；script文件；输入boot.cmd文件；输出boot.scr文件</span></span><br><span class="line">tools/mkimage -A arm -C none -T script -d boot.cmd boot.scr</span><br></pre></td></tr></table></figure><p>生成的 <em>boot.scr</em> 文件就在当前目录下。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-4.14-exp --depth=1 https://github.com/Lichee-Pi/linux.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入linux目录</span></span><br><span class="line"><span class="built_in">cd</span> linux/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载使用荔枝派Nano的linux配置文件</span></span><br><span class="line">wget https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</span><br><span class="line">cp config .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据需要配置，没有需要的话直接按两下Esc保存退出</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line"><span class="comment"># 过程中如果出现需要设置的选项全部选n</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后在 <em>arch&#x2F;arm&#x2F;boot&#x2F;</em> 目录下的 <em>zImage</em> 文件就是压缩后的内核程序；在 <em>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;</em> 目录下的 <em>suniv-f1c100s-licheepi-nano.dtb</em> 或 <em>suniv-f1c100s-licheepi-nano-with-lcd.dtb</em> 文件就是编译后的设备树文件。</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>嵌入式linux开发最终是需要在系统上运行应用程序来实现特定的功能需求，这里编写个基础的应用程序用于测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 建立程序文件夹并进入</span></span><br><span class="line">mkdir helloworld</span><br><span class="line"><span class="built_in">cd</span> helloworld/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立程序文件并编写程序</span></span><br><span class="line">touch helloworld.c</span><br><span class="line">gedit helloworld.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabi-gcc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure><p>生成的 <em>helloworld</em> 就是我们需要的可执行文件了。</p><h2 id="文件烧录"><a href="#文件烧录" class="headerlink" title="文件烧录"></a>文件烧录</h2><p>前面编译生成的内容可以分块分别烧录进SD卡进行测试，也可以将 u-boot &amp; linux &amp; rootfs 整块打包烧录进SD卡进行测试，其实本质上是一样的，这里先进行分块测试的介绍，打包烧录介绍将在后面的章节说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将SD卡插入Ubuntu中</span></span><br><span class="line"><span class="comment"># 使用 lsblk 查看SD卡设备号sdX</span></span><br><span class="line"><span class="comment"># 我这里显示为sdb，下面均以此进行说明</span></span><br></pre></td></tr></table></figure><h3 id="分区设置"><a href="#分区设置" class="headerlink" title="分区设置"></a>分区设置</h3><p>准备SD卡并按要求分区，空间划分参考本文开头的给出的文章，下面是在Ubuntu终端中进行分区划分示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果已经分过区了那么Ubuntu可能会自动挂载</span></span><br><span class="line"><span class="comment"># 逐条使用 sudo umount /dev/sdbn 进行卸载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对SD（TF）卡进行分区</span></span><br><span class="line">sudo fdisk /dev/sdb</span><br><span class="line"><span class="comment"># 如果有分区的话可以输入 d 回车依次删除</span></span><br><span class="line"><span class="comment"># 输入 n 新建分区，分区大小根据需要设置即可</span></span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，输入使用 lsblk 查看分区情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/sdb1</span><br><span class="line">sudo mkfs.ext4 /dev/sdb2</span><br></pre></td></tr></table></figure><h3 id="分块烧录"><a href="#分块烧录" class="headerlink" title="分块烧录"></a>分块烧录</h3><p><strong>u-boot</strong><br><em>u-boot-sunxi-with-spl.bin</em> 文件需要放置在SD卡8k开始的位置上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin  of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><p><strong>linux &amp; dtb &amp; boot.scr</strong><br>这三个放在刚才新建的第一个分区里（sdb1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝linux和dtb</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/linux/</span></span><br><span class="line">sudo cp arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝boot.scr</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo cp boot.scr /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br></pre></td></tr></table></figure><p><strong>rootfs</strong><br>这个放在刚才新建的第二个分区里（sdb2）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并拷贝rootfs</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/buildroot-2022.02/</span></span><br><span class="line">sudo tar -xf output/images/rootfs.tar -C /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br></pre></td></tr></table></figure><p><strong>测试程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝helloworld</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/helloworld/</span></span><br><span class="line">sudo cp helloworld /mnt/root/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="上电测试"><a href="#上电测试" class="headerlink" title="上电测试"></a>上电测试</h2><p>上电打印信息与应用程序测试结果与关键日志如下：</p><p><em>默认通过UART0 PE0-RX PE1-TX 波特率115200</em><br><em>我这里使用的是F1C200s，所以内存显示为 64 MiB</em><br><em>前面生成的rootfs登陆用户名为root，无密码</em></p><img src="/posts/968082855/93e44242d33e3d5eee3579a3f39b0796.gif" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Lichee Pi Nano</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">mmc0 is current device</span><br><span class="line">Scanning mmc 0:1...</span><br><span class="line">Found U-Boot script /boot.scr</span><br><span class="line">reading /boot.scr</span><br><span class="line">279 bytes <span class="built_in">read</span> <span class="keyword">in</span> 14 ms (18.6 KiB/s)</span><br><span class="line"><span class="comment">## Executing script at 80c50000</span></span><br><span class="line">reading zImage</span><br><span class="line">3841152 bytes <span class="built_in">read</span> <span class="keyword">in</span> 200 ms (18.3 MiB/s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7464 bytes <span class="built_in">read</span> <span class="keyword">in</span> 25 ms (291 KiB/s)</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd27 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.14.0-licheepi-nano+ (nx@nx-ubuntu) (gcc version 10.3.0 (Buildroot 2022.02)) <span class="comment">#1 Tue Mar 15 16:07:52 CST 2022</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">[    1.331930] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.375977] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.390277] mmc0: new high speed SDHC card at address aaaa</span><br><span class="line">[    1.396880] mmcblk0: mmc0:aaaa SC16G 14.8 GiB </span><br><span class="line">[    1.407742]  mmcblk0: p1 p2</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Starting syslogd: OK</span><br><span class="line">Starting klogd: OK</span><br><span class="line">Running sysctl: OK</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Welcome to Buildroot</span><br><span class="line">buildroot login: root</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">helloworld</span><br><span class="line"><span class="comment"># ./helloworld </span></span><br><span class="line">Hello, world!</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h2><p>前面分块烧录在测试的时候用用还行，但是如果是要批量生产或是交给他人使用就不方便了，这个时候可以制作系统成单个系统镜像文件来处理。</p><p>前面讲了对SD卡分区等操作，其实不管是分区还是数据拷贝等，最终在SD卡上无非就是一片按照一定顺序存储的数据。把这段数据原模原样的拷贝成一个文件，这就是系统镜像文件，使用的时候只要把这个文件内容拷贝到SD卡上就可以了。</p><h3 id="制作镜像文件"><a href="#制作镜像文件" class="headerlink" title="制作镜像文件"></a>制作镜像文件</h3><p><strong>从已有SD卡制作镜像文件</strong><br>如果有已经烧录完成所有内容的SD卡的话直接使用 dd 命令将SD卡内容复制到一个文件即可得到系统镜像文件。比如针对前面流程下的SD卡可以使用下面方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 将SD卡中有用的数据保存镜像文件中</span></span><br><span class="line"><span class="comment"># 大小为 1M(uboot) + 32M(bootfs) + 200M(rootfs) + 2M(多拷贝点，防止不明意外)</span></span><br><span class="line"><span class="comment"># 数据比较大会花点时间</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sdb of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>从编译生成的文件制作</strong><br>如果还没有烧录好的SD卡也可以直接从编译生成的文件制作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 向镜像文件写入空数据固定大小</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的设备挂载点</span></span><br><span class="line">sudo losetup -f</span><br><span class="line"><span class="comment"># 我这里显示 /dev/loop13，接下来都以此进行说明</span></span><br><span class="line"><span class="comment"># 将镜像文件挂载到 /dev/loop13</span></span><br><span class="line">sudo losetup /dev/loop13 f1c100s-system-image.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对挂载的设备进行分区</span></span><br><span class="line">sudo fdisk /dev/loop13</span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 接着 a回车 1回车 (将分区1设置为可启动)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，会有点问题提示不用管</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分区表</span></span><br><span class="line">sudo kpartx -av /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/mapper/loop13p1</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第一个分区向里拷贝linux、dtb、boot.scr</span></span><br><span class="line">sudo mount /dev/mapper/loop13p1 /mnt</span><br><span class="line">sudo cp linux/arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp linux/arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line">sudo cp u-boot/boot.scr /mnt/</span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第二个分区向里解压并拷贝rootfs</span></span><br><span class="line">sudo mount /dev/mapper/loop13p2 /mnt</span><br><span class="line">sudo tar -xf buildroot-2022.02/output/images/rootfs.tar -C /mnt/</span><br><span class="line"><span class="comment"># 根据需求也可以拷贝应用程序进去</span></span><br><span class="line"><span class="comment"># sudo cp helloworld/helloworld /mnt/root/</span></span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载设备</span></span><br><span class="line">sudo kpartx -d /dev/loop13</span><br><span class="line">sudo losetup -d /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向头部写入uboot，注意conv=notrunc选项参数一定不能漏</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot/u-boot-sunxi-with-spl.bin  of=f1c100s-system-image.bin bs=1024 seek=8 conv=notrunc</span><br></pre></td></tr></table></figure><p><strong>压缩系统镜像</strong><br>前面生成的系统镜像比较大，不适合存储，可以对镜像镜像压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 将系统镜像以zip方式镜像压缩</span></span><br><span class="line">zip f1c100s-system-image.zip f1c100s-system-image.bin</span><br></pre></td></tr></table></figure><h3 id="使用镜像文件"><a href="#使用镜像文件" class="headerlink" title="使用镜像文件"></a>使用镜像文件</h3><p><strong>在Linux上可以直接使用 *dd* 命令将镜像文件写入SD卡中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压镜像文件压缩包</span></span><br><span class="line">unzip f1c100s-system-image.zip</span><br><span class="line"><span class="comment"># 将镜像文件写入SD卡，写入可能较慢</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=f1c100s-system-image.bin of=/dev/sdb bs=1M</span><br></pre></td></tr></table></figure><p>当然我更加推荐使用工具来烧录，<strong>这里推荐使用 BalenaEtcher 工具</strong> ，这个工具支持windos、macos、linux，其官方页面和项目地址分别如下：<br><a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a><br><a href="https://github.com/balena-io/etcher">https://github.com/balena-io/etcher</a><br>下面是用这个工具进行烧录的演示：</p><img src="/posts/968082855/3b2b282db96c566137f8554efdbcc6b5.gif" class="" title="在这里插入图片描述"><p>上面演示了使用BalenaEtcher工具进行烧录和启动测试，其中有两点值得注意的：</p><ul><li>原始的.bin后缀名的系统进行经过压缩后变得非常小（235MB &gt; 5.98MB），可见压缩非常有用；</li><li>BalenaEtcher可以直接使用压缩包进行烧录（比如我上面演示中）；</li></ul><h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><ul><li><strong>buildroot编译过程中下载文件慢</strong><br>buildroot编译过程中会下载很多文件，有可能会下着下着就不动了，或是下载缓慢。首先可以尝试使用 <code>ctrl + c</code> 终止当前工作后再 <code>make</code> ，会从终止的步骤重新开始；<br>如果上面的方式不行，那自行查看编译输出信息，其中有文件下载地址的，手动用下载工具进行下载，把下载的内容压缩包或解压后内容放到buildroot的 <code>dl</code> 目录下，然后重复前面步骤；</li><li><strong>编译过程中因为缺少文件报错</strong><br>百度、必应等查找Ubuntu下安装这些文件的方法；</li><li><strong>编译或使用中其它不明的问题</strong><br>使用 <code>make clean</code> 或者 <code>make distclean</code> 后重复配置编译过程；</li></ul><h2 id="SDK数据包"><a href="#SDK数据包" class="headerlink" title="SDK数据包"></a>SDK数据包</h2><p>鉴于整个过程中有很多东西需要下载，部分内容可能下载缓慢，所以将本文中出现的主要的几个项目内容进行了打包，方便将来使用。下载链接如下：</p><p>链接：<a href="https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g">https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g</a><br>提取码：<code>ezrw</code></p><p>下载下来是个zip格式压缩包，解压后得到下面内容（Ubuntu上可以使用 unzip 进行解压）：</p><img src="/posts/968082855/f3eaf553ab39f4d46e3bed21d55995f2.png" class="" title="在这里插入图片描述"><p>各个文件说明如下：</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>helloworld</td><td>内部含有helloworld.c文件</td></tr><tr><td>buildroot-2022.02.tar.xz</td><td>使用 wget <a href="https://buildroot.org/downloads/buildroot-2022.02.tar.xz">https://buildroot.org/downloads/buildroot-2022.02.tar.xz</a> 下载得到的压缩包</td></tr><tr><td>buildroot-2022.02-with-dl.tar.xz</td><td>根据上面项目 make menuconfig &gt; make &gt; make clean 后的文件夹进行重新打包压缩 其dl文件夹中包含了所有make时需要下载的东西</td></tr><tr><td>linux.tar.xz</td><td>使用 git clone -b nano-4.14-exp –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/linux.git">https://github.com/Lichee-Pi/linux.git</a> 下载 得到的linux文件夹中放入使用 wget <a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 下载的config文件<br/>然后对linux文件夹重新打包</td></tr><tr><td>sunxi-tools.tar.xz</td><td>使用 git clone -b f1c100s-spiflash –depth&#x3D;1 <a href="https://github.com/Icenowy/sunxi-tools.git">https://github.com/Icenowy/sunxi-tools.git</a> 下载 得到的sunxi-tools文件夹重新打包</td></tr><tr><td>u-boot.tar.xz</td><td>使用 git clone -b nano-lcd800480 –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> 下载 到的u-boot文件夹重新打包</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于现有的一些项目，详细记录 <em>u-boot &amp; linux &amp; rootfs 编译与烧录测试（ 基于SD卡）</em> 整个流程内容，可以作为进一步的移植、开发与使用的基础。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/122704052">资料索引与基础说明</a></li><li><a href="https://blog.csdn.net/Naisu_kun/article/details/123142958">u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C100s使用记录</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="F1C100S" scheme="https://zml3589110.github.io/tags/F1C100S/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266内置网页配置</title>
    <link href="https://zml3589110.github.io/posts/2546212267.html"/>
    <id>https://zml3589110.github.io/posts/2546212267.html</id>
    <published>2025-09-10T08:09:20.000Z</published>
    <updated>2025-09-10T13:10:14.324Z</updated>
    
    <content type="html"><![CDATA[<p>1、写入一个网页到FLASH指定位置：</p><p>（1）找到可以放置网页的位置；扇区：4KBytes-0x001000</p><p>ESP8266-01:FLASH:25Q80&#x3D;8Mbits&#x3D;1MBytes&#x3D;0x100000: 256扇区</p><p>eagle.flash.bin——————————————–0x000000: 0扇区—–64KBytes</p><p>eagle.irom0text.bin————————————–0x010000: 16扇区—-944KBytes</p><p>esp_init_data_default_v05.bin———————–0x0FC000: 252扇区</p><p>blank.bin—————————————————0x0FE000: 254扇区</p><p>FLASH中前64K为系统程序1，紧接着是系统程序2，倒数4个扇区（16KBytes）中为系统参数区。<br>用户可用区域在系统程序2与系统参数区中间部分，<br>至于从何扇区开始，到何处结束，则由前后扇区内容决定。在ld-&gt;eagle.app.v6.ld中可以查看各区域设置的长度，<br>其中最后一项是irom0_0_seg-&gt;len即为eagle.irom0text.bin的允许长度。由此可以计算出用户可用区域的起始结束地址</p><img src="/posts/2546212267/34f8765cbe2ed465be5ed6dd8770a434.png" class="" title="img"><p>eagle.irom0text.bin—0x010000—0x06C000: 0x05C000</p><p>因此用户可用区域为: 0x06C000—0x0FC000: 576KBytes: 144扇区</p><p>（2）放入写好的网页，读取出来看看数据是否写入正确；</p><p>使用ESP8266烧写工具在指定位置放入一个WEB页面，利用OS_printf输出到串口助手查看。</p><p>新建一个login.html ；注意格式一定要是UTF-8，否则在页面开头有乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>LOGIN<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;<span class="attribute">width</span>:<span class="number">500px</span>;<span class="attribute">height</span>:<span class="number">80px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.log</span>&#123;<span class="attribute">font-size</span>:<span class="number">80px</span>;<span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.dx</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;dx&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span> <span class="attr">action</span>=<span class="string">&#x27;Login.cgi&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录WIFI设置界面</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">UserName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;NAME&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> PassWord:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;PWD&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;log&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;登录&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;NAME&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;PWD&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ESP8266测试代码中，读取出FLASH里的数据，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char ch[1000];</span><br><span class="line">os_printf(<span class="string">&quot;login.page!\n&quot;</span>);</span><br><span class="line">spi_flash_read(0x6C000, (uint32 *)&amp;ch, 654);</span><br><span class="line">ch[655] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">os_printf(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">os_printf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>在串口助手中可以看到输出结果，如果文件格式不是UTF-8，则串口助手输出的中文就会是乱码。如果页面代码中有错误码，也能查出来。同时修改上面的数字大小也能测出页面包含的字节数。这个字节数会用于页面的发送。测试结果</p><p>可以看出数据没有问题，保证了在FLASH中的页面数据没有问题。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/105232494">ESP8266学习-内置网页配置（一）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP8266内置网页配置</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/tags/ESP8266/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
  </entry>
  
  <entry>
    <title>自制F1C200S demo板</title>
    <link href="https://zml3589110.github.io/posts/2989473239.html"/>
    <id>https://zml3589110.github.io/posts/2989473239.html</id>
    <published>2025-09-10T07:51:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、电路"><a href="#一、电路" class="headerlink" title="一、电路"></a>一、电路</h1><ul><li>具备FLASH下载，TF卡座，摄像头，LCD，MIC，UART等</li></ul><h2 id="一、原理图：如需PDF源文件可到资源下载。"><a href="#一、原理图：如需PDF源文件可到资源下载。" class="headerlink" title="一、原理图：如需PDF源文件可到资源下载。"></a>一、原理图：如需PDF源文件可到资源下载。</h2><p><a href="https://oshwhub.com/AI_QY/f1c100s_1">原理图资料</a></p><img src="/posts/2989473239/a5e8331f42cc6551eac8403725716d39.png" class="" title="img"><img src="/posts/2989473239/4b63a90eafd334ce1bf724bddb06b89b.png" class="" title="img"><h2 id="二、电路：如需PDF源文件可到资源下载。"><a href="#二、电路：如需PDF源文件可到资源下载。" class="headerlink" title="二、电路：如需PDF源文件可到资源下载。"></a>二、电路：如需PDF源文件可到资源下载。</h2><img src="/posts/2989473239/1cf8dfb59ba44ccc0a63ab7bb516d98a.png" class="" title="img"><img src="/posts/2989473239/f4dd572283b5db780ac8b8f2ed37cda7.png" class="" title="img"><h2 id="三、实物"><a href="#三、实物" class="headerlink" title="三、实物"></a>三、实物</h2><img src="/posts/2989473239/387da10619629c5bdc3f5e86ba60fb18.png" class="" title="img"><img src="/posts/2989473239/5868d90b3567d2b1c7df1b6916d638ae.png" class="" title="img"><h1 id="二、Win上测试"><a href="#二、Win上测试" class="headerlink" title="二、Win上测试"></a>二、Win上测试</h1><p>此次测试的目的是尝试使用USB给NorFlash烧录镜像。</p><h2 id="1、安装USB驱动。使用的操作系统是win8。"><a href="#1、安装USB驱动。使用的操作系统是win8。" class="headerlink" title="1、安装USB驱动。使用的操作系统是win8。"></a>1、安装USB驱动。使用的操作系统是win8。</h2><p>在网上下载zadig-2.3.exe。接入设备后，会产生未知设备。然后进行如图操作即可。</p><img src="/posts/2989473239/ceb654f5e3cc3026636ea6cc177cee5c.png" class="" title="img"><h2 id="2、使硬件进入fel模式。"><a href="#2、使硬件进入fel模式。" class="headerlink" title="2、使硬件进入fel模式。"></a>2、使硬件进入fel模式。</h2><p>在FLASH和TF卡都没有系统或为空时，插电即可进入fel模式。如果没有进入，则</p><p>若FLASH中有系统，需通过：短接FLASH芯片的1、4两脚，即按住开发板上boot按键，重新拔插USB或电源开关重新开关一次，即可进入fel模式。</p><h2 id="3、刷机"><a href="#3、刷机" class="headerlink" title="3、刷机"></a>3、刷机</h2><ul><li>(1)、在网上下载或我的资源包中下载，用与在windows下刷机的工具。解压到某个文件下。</li></ul><img src="/posts/2989473239/78da5325456f9e0a5952c4c5e4af00b4.png" class="" title="img"><ul><li>(2)、使用win+R或其他方式打开windows命令行窗口</li></ul><p> 首先进入到刷机工具目录：cd C:\Users\Administrator\Downloads\刷机\sunxi-tools-win32_f1_flash</p><p>  查看信息：sunxi-fel.exe ver。我是用的是F1C100S的镜像，也可以驱动F1C200S。</p><p>  查看SPIFLASH信息：sunxi-fel.exe spiflash-info。我的demo板上使用的是32MFLASH，尽管镜像使用的是16MFLASH，也可以进行驱动，理论上只会无法访问后半段FLASH。</p><p>  烧录镜像：sunxi-fel.exe -p spiflash-write 0 sysimage-nor.img 100%。这里我将sysimge-nor.img文件拷贝到sunxi-tools-win32_f1_flash文件夹内。</p><img src="/posts/2989473239/56b6f108417cbc7c297081a304e74b5d.png" class="" title="img"><h2 id="4、运行结果"><a href="#4、运行结果" class="headerlink" title="4、运行结果"></a>4、运行结果</h2><img src="/posts/2989473239/6e49e6c1f8b30c484152108a60c231b1.png" class="" title="img"><h1 id="三、Linux上测试"><a href="#三、Linux上测试" class="headerlink" title="三、Linux上测试"></a>三、Linux上测试</h1><p>原思路即是在Linux系统下，对SPIFLASH进行烧录测试，但遇到了一些问题，导致Linux虚拟机无法识别到该设备。进而产生了上一文档的windows下烧录测试。通过在Windows下烧录测试，也验证了设备烧录、测试、各个文件均没有问题。</p><p>主要导致在Linux下无法测试的问题是：Vbox无法筛选USB设备，导致Linux虚拟机加载不到开发板。</p><p>正确过程：</p><h2 id="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"><a href="#1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN" class="headerlink" title="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"></a>1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN</h2><h2 id="2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html"><a href="#2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html" class="headerlink" title="2、在Vbox里添加增强功能。按照某度经验进行https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html"></a>2、在Vbox里添加增强功能。按照某度经验进行<a href="https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html">https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html</a></h2><h2 id="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"><a href="#3、增强功能安装后，添加筛选器。我这里使用的手动添加。" class="headerlink" title="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"></a>3、增强功能安装后，添加筛选器。我这里使用的手动添加。</h2><img src="/posts/2989473239/90387ee3726d69a3b29bbe5199f51246.png" class="" title="img"><p>筛选参数按照window系统中驱动信息进行填写。</p><img src="/posts/2989473239/c9aa769a65e154ab6c169874bb7b1a87.png" class="" title="img"><img src="/posts/2989473239/3b9ea6465b78d60106599a3b835fd03d.png" class="" title="img"><h2 id="4、打开Linux虚拟机后，进入到命令行模式。"><a href="#4、打开Linux虚拟机后，进入到命令行模式。" class="headerlink" title="4、打开Linux虚拟机后，进入到命令行模式。"></a>4、打开Linux虚拟机后，进入到命令行模式。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line">sudo apt install libz libusb-1.0-0-dev</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">sudo sunxi-fel ver</span><br><span class="line">输出信息：</span><br><span class="line"><span class="string">&quot;AWUSBFEX soc=00001663(F1C100s) 00000001 ver=0001 44 08 scratchpad=00007e00 00000000 00000000&quot;</span></span><br><span class="line">sudo sunxi-fel -l</span><br><span class="line">sudo sunxi-fel -p spiflash-write 0 u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>  查看支持的芯片：sudo sunxi-fel -l。</p><p>  查看开发板信息：sudo sunxi-fel ver。</p><p>  查看SPIFLASH信息：sudo sunxi-fel spiflash-info。</p><p>  烧录镜像到SPIFLASH：sudo sunxi-fel -p spiflash-write 0 Nano_flash_800480.bin 100%。这里使用的是荔枝派的Nano的FLASH。</p><img src="/posts/2989473239/f5874d781e692131970602d2112159f9.png" class="" title="img"><img src="/posts/2989473239/703b2a3d086d8ecdbbaf9ccd795f5760.png" class="" title="img"><h2 id="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"><a href="#5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。" class="headerlink" title="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"></a>5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。</h2><img src="/posts/2989473239/3748a8399b66fad40291531b2f1c688b.png" class="" title="img"><h1 id="四、TF卡启动"><a href="#四、TF卡启动" class="headerlink" title="四、TF卡启动"></a>四、TF卡启动</h1><p>思来想去，发现使用SIPFLASH也不是百分百完美，也终于明白为何最小demo板要首推TF卡启动了。</p><p>主要是现在想学Linux驱动，但使用SPIFLASH就需要用uboot和kernel两个同时打包为一个镜像，这样编译和打包都会影响速度。使用TF卡，就可以把三个板块分开，单独操作而互不干扰。</p><p>这里操作步骤需要摸清楚：1、uboot获取，编译，烧录。2、kernel获取，编译，烧录。3、文件系统搭建。</p><p>获取uboot：git clone <a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a> -b nano-v2018.01&amp;&amp;cd u-boot</p><p>获取时出现的问题：从网上别人博客里是：git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01&amp;&amp;cd u-boot，发现获取不到。</p><p>解决方法：去掉.git后获取正常。</p><p>编译uboot：make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_defconfig</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><p>编译时出现的问题：make: arm-linux-gnueabi-gcc: Command not found。</p><p>解决方法：sudo apt install gcc-arm-linux-gnueabi。</p><p>编译时出现的问题：unable to execute ‘swig’: No such file or directory。</p><p>解决方法：sudo apt install swig。</p><p>编译时出现的问题：scripts&#x2F;dtc&#x2F;pylibfdt&#x2F;libfdt_wrap.c:149:11: fatal error: Python.h: 没有那个文件或目录。</p><p>解决方法：1、查看版本：python -V，2、获取对应文件：sudo apt install python2.7-dev。（这里的2.7要修改为和查看的版本相匹配）</p><p>烧录uboot：sudo dd if&#x3D;u-boot-tf.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</p><p>sudo cp suniv-f1c100s-licheepi-nano.dtb &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝镜像文件：sudo cp tf-zImage &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝文件系统：sudo tar -xvf rootfs-tf.tar.gz -C &#x2F;media&#x2F;one&#x2F;rootfs&#x2F;</p><p>需要将TF卡分成两个区：uboot fat16 64M 和 rootfs ext4 (TF卡剩余所有空间）。</p><p>查看磁盘：sudo fdisk -l  和 查看挂载：df|grep sd</p><p>以上烧录使用的是Lichee-pi-nano的标准文件，并未使用我编译的文件，可以正常运行，输出启动参数。</p><p>经过测试，当SPIFLASH和TF卡里都有系统时，优先运行TF卡中系统。</p><p>在2021年9月16日，终于指导了uboot和Linux等的关联和基本操作了。虽然前面都在串口调试助手上显示了启动信息，但仔细查看，始终没看到运行kernel。今天终于搞明白了，这三大板块放到TF卡中应该正确操作的流程了。</p><p>开机后，串口调试助手上会输出信息，但仅仅是输出uboot的信息，会停留在uboot的命令行。需要在这里使用命令行，配置kernel引导参数，从而执行Linux。</p><p>也可以按照<a href="http://nano.lichee.pro/build_sys/bootargs.html">uboot传递参数 — 荔枝派Nano 全流程指南 documentation</a> 生成一个boot.scr文件，复制到TF卡的第一分区，就能自动运行LINUX，无需再再串口调试助手中输入这些指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">以下是串口调试助手完整输出信息，红色部分则是要人为发送的启动信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.143] RX：</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.311] RX：</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.842] RX：MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.918] RX：*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[2021-09-16 12:03:08.942] RX： 1 </span><br><span class="line">[2021-09-16 12:03:09.943] RX： 0 </span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.006] RX：switch to partitions <span class="comment">#0, OK</span></span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.556] RX：Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.705] RX：reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.773] RX：starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue <span class="string">&#x27;usb start&#x27;</span> first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:12.310] TX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:12.313] RX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:13.539] TX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:13.544] RX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:15.421] TX：load mmc 0:1 0x80008000 zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.424] RX：load mmc 0:1 0x80008000 zImage</span><br><span class="line">reading zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.635] RX：3838016 bytes <span class="built_in">read</span> <span class="keyword">in</span> 194 ms (18.9 MiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:17.540] TX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:17.543] RX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd9e ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:18.737] RX：[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-rc8-licheepi-nano+ (one@one-VirtualBox) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) <span class="comment">#1 Tue Sep 14 17:09:09 CST 2021</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: Lichee Pi Nano</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] random: fast init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 16256</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 8192 (order: 3, 32768 bytes)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 4096 (order: 2, 16384 bytes)</span><br><span class="line">[    0.000000] Memory: 55172K/65536K available (6144K kernel code, 236K rwdata, 1388K rodata, 1024K init, 244K bss, 10364K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] Virtual kernel memory layout:</span><br><span class="line">[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class="line">[    0.000000]     fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class="line">[    0.000000]     vmalloc : 0xc4800000 - 0xff800000   ( 944 MB)</span><br><span class="line">[    0.000000]     lowmem  : 0xc0000000 - 0xc4000000   (  64 MB)</span><br><span class="line">[    0.000000]     pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)</span><br><span class="line">[    0.000000]     modules : 0xbf000000 - 0xbfe00000   (  14 MB)</span><br><span class="line">[    0.000000]       .text : 0x(ptrval) - 0x(ptrval)   (7136 kB)</span><br><span class="line">[    0.000000]       .init : 0x(ptrval) - 0x(ptrval)   (1024 kB)</span><br><span class="line">[    0.000000]       .data : 0x(ptrval) - 0x(ptrval)   ( 237 kB)</span><br><span class="line">[    0.000000]        .bss : 0x(ptrval) - 0x(ptrval)   ( 245 kB)</span><br><span class="line">[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span><br><span class="line">[    0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16</span><br><span class="line">[    0.000044] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns</span><br><span class="line">[    0.000107] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns</span><br><span class="line">[    0.000634] Console: colour dummy device 80x30</span><br><span class="line">[    0.001547] console [tty0] enabled</span><br><span class="line">[    0.001649] Calibrating delay loop... 203.16 BogoMIPS (lpj=1015808)</span><br><span class="line">[    0.070270] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.070605] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.070691] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.072128] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.073790] Setting up static identity map <span class="keyword">for</span> 0x80100000 - 0x80100058</span><br><span class="line">[    0.076353] devtmpfs: initialized</span><br><span class="line">[    0.082594] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns</span><br><span class="line">[    0.082753] futex <span class="built_in">hash</span> table entries: 256 (order: -1, 3072 bytes)</span><br><span class="line">[    0.083054] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.085012] NET: Registered protocol family 16</span><br><span class="line">[    0.086414] DMA: preallocated 256 KiB pool <span class="keyword">for</span> atomic coherent allocations</span><br><span class="line">[    0.088228] cpuidle: using governor menu</span><br><span class="line">[    0.112653] SCSI subsystem initialized</span><br><span class="line">[    0.113054] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.113256] usbcore: registered new interface driver hub</span><br><span class="line">[    0.113505] usbcore: registered new device driver usb</span><br><span class="line">[    0.113994] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.114073] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.114196] PTP clock support registered</span><br><span class="line">[    0.114675] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.116219] clocksource: Switched to clocksource timer</span><br><span class="line">[    0.141314] NET: Registered protocol family 2</span><br><span class="line">[    0.142762] TCP established <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.142912] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143002] TCP: Hash tables configured (established 1024 <span class="built_in">bind</span> 1024)</span><br><span class="line">[    0.143302] UDP <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143408] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143903] NET: Registered protocol family 1</span><br><span class="line">[    0.145154] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.145261] RPC: Registered udp transport module.</span><br><span class="line">[    0.145309] RPC: Registered tcp transport module.</span><br><span class="line">[    0.145352] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.147636] NetWinder Floating Point Emulator V0.97 (double precision)</span><br><span class="line">[    0.149450] Initialise system trusted keyrings</span><br><span class="line">[    0.150062] workingset: timestamp_bits=30 max_order=14 bucket_order=0</span><br><span class="line">[    0.167180] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.167334] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.167393] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.180354] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.180460] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.180692] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)</span><br><span class="line">[    0.180785] io scheduler noop registered</span><br><span class="line">[    0.180833] io scheduler deadline registered</span><br><span class="line">[    0.181596] io scheduler cfq registered (default)</span><br><span class="line">[    0.181690] io scheduler mq-deadline registered</span><br><span class="line">[    0.181743] io scheduler kyber registered</span><br><span class="line">[    0.182841] sun4i-usb-phy 1c13400.phy: Couldn<span class="string">&#x27;t request ID GPIO</span></span><br><span class="line"><span class="string">[    0.192424] suniv-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver</span></span><br><span class="line"><span class="string">[    0.354497] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled</span></span><br><span class="line"><span class="string">[    0.361118] console [ttyS0] disabled</span></span><br><span class="line"><span class="string">[    0.381429] 1c25000.serial: ttyS0 at MMIO 0x1c25000 (irq = 23, base_baud = 6250000) is a 16550A</span></span><br><span class="line"><span class="string">[    0.852908] console [ttyS0] enabled</span></span><br><span class="line"><span class="string">[    0.863244] panel-simple panel: panel supply power not found, using dummy regulator</span></span><br><span class="line"><span class="string">[    0.872677] SCSI Media Changer driver v0.25 </span></span><br><span class="line"><span class="string">[    0.880398] m25p80 spi0.0: found w25q256, expected w25q128</span></span><br><span class="line"><span class="string">[    0.886477] m25p80 spi0.0: w25q256 (32768 Kbytes)</span></span><br><span class="line"><span class="string">[    0.893635] ehci_hcd: USB 2.0 &#x27;</span>Enhanced<span class="string">&#x27; Host Controller (EHCI) Driver</span></span><br><span class="line"><span class="string">[    0.900355] ehci-platform: EHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.905917] ohci_hcd: USB 1.1 &#x27;</span>Open<span class="string">&#x27; Host Controller (OHCI) Driver</span></span><br><span class="line"><span class="string">[    0.912272] ohci-platform: OHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.918003] usbcore: registered new interface driver usb-storage</span></span><br><span class="line"><span class="string">[    0.924980] udc-core: couldn&#x27;</span>t find an available UDC - added [g_cdc] to list of pending drivers</span><br><span class="line">[    0.934113] i2c /dev entries driver</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.352] RX：[    0.996353] sunxi-mmc 1c0f000.mmc: base:0x0db647ea irq:19</span><br><span class="line">[    1.003836] usbcore: registered new interface driver usbhid</span><br><span class="line">[    1.009596] usbhid: USB HID core driver</span><br><span class="line">[    1.031128] NET: Registered protocol family 17</span><br><span class="line">[    1.035884] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    1.042602] Loading compiled-in X.509 certificates</span><br><span class="line">[    1.058564] sun4i-drm display-engine: bound 1e60000.display-backend (ops 0xc0739498)</span><br><span class="line">[    1.067512] sun4i-drm display-engine: bound 1c0c000.lcd-controller (ops 0xc073877c)</span><br><span class="line">[    1.075259] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013).</span><br><span class="line">[    1.082015] [drm] No driver support <span class="keyword">for</span> vblank timestamp query.</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.511] RX：[    1.138455] Console: switching to colour frame buffer device 60x34</span><br><span class="line">[    1.140705] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.142989] mmc0: new high speed SDHC card at address 59b4</span><br><span class="line">[    1.144075] mmcblk0: mmc0:59b4 SD    15.0 GiB </span><br><span class="line">[    1.146386]  mmcblk0: p1 p2</span><br><span class="line">[    1.208313] sun4i-drm display-engine: fb0:  frame buffer device</span><br><span class="line">[    1.227575] [drm] Initialized sun4i-drm 1.0.0 20150629 <span class="keyword">for</span> display-engine on minor 0</span><br><span class="line">[    1.249110] usb_phy_generic usb_phy_generic.0.auto: usb_phy_generic.0.auto supply vcc not found, using dummy regulator</span><br><span class="line">[    1.279822] musb-hdrc musb-hdrc.1.auto: MUSB HDRC host driver</span><br><span class="line">[    1.298514] musb-hdrc musb-hdrc.1.auto: new USB bus registered, assigned bus number 1</span><br><span class="line">[    1.321574] hub 1-0:1.0: USB hub found</span><br><span class="line">[    1.332130] hub 1-0:1.0: 1 port detected</span><br><span class="line">[    1.344233] using random self ethernet address</span><br><span class="line">[    1.355304] using random host ethernet address</span><br><span class="line">[    1.367912] usb0: HOST MAC 96:a7:62:ad:40:54</span><br><span class="line">[    1.378730] usb0: MAC 32:68:5e:ee:7c:4e</span><br><span class="line">[    1.389004] g_cdc gadget: CDC Composite Gadget, version: King Kamehameha Day 2008</span><br><span class="line">[    1.408933] g_cdc gadget: g_cdc ready</span><br><span class="line">[    1.419690] cfg80211: Loading compiled-in X.509 certificates <span class="keyword">for</span> regulatory database</span><br><span class="line">[    1.449709] cfg80211: Loaded X.509 cert <span class="string">&#x27;sforshee: 00b28ddf47aef9cea7&#x27;</span></span><br><span class="line">[    1.468828] ALSA device list:</span><br><span class="line">[    1.478044]   <span class="comment">#0: Loopback 1</span></span><br><span class="line">[    1.487901] platform regulatory.0: Direct firmware load <span class="keyword">for</span> regulatory.db failed with error -2</span><br><span class="line">[    1.508671] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.521906] EXT4-fs (mmcblk0p2): couldn<span class="string">&#x27;t mount as ext3 due to feature incompatibilities</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.009] RX：[    1.653047] EXT4-fs (mmcblk0p2): recovery complete</span></span><br><span class="line"><span class="string">[    1.669691] EXT4-fs (mmcblk0p2): mounted filesystem with ordered data mode. Opts: (null)</span></span><br><span class="line"><span class="string">[    1.690011] VFS: Mounted root (ext4 filesystem) on device 179:2.</span></span><br><span class="line"><span class="string">[    1.710548] devtmpfs: mounted</span></span><br><span class="line"><span class="string">[    1.724192] Freeing unused kernel memory: 1024K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.248] RX：[    1.892543] EXT4-fs (mmcblk0p2): re-mounted. Opts: data=ordered</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.361] RX：Starting logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.403] RX：OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.483] RX：Initializing random number generator... </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.591] RX：done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.710] RX：</span></span><br><span class="line"><span class="string">Welcome to Lichee Pi</span></span><br><span class="line"><span class="string">Lichee login: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.235] TX：root</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.239] RX：root</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.220] TX：licheepi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.224] RX：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.283] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.020] TX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.025] RX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.148] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.212] RX：Saving random seed... done.</span></span><br><span class="line"><span class="string">Stopping logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.275] RX：OK</span></span><br><span class="line"><span class="string">umount: devtmpfs busy - remounted read-only</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.403] RX：[   11.047017] EXT4-fs (mmcblk0p2): re-mounted. Opts: (null)</span></span><br><span class="line"><span class="string">The system is going down NOW!</span></span><br><span class="line"><span class="string">Sent SIGTERM to all processes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:30.425] RX： Sent SIGKILL to all processes</span></span><br><span class="line"><span class="string">Requesting system poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:31.428] RX：[   13.072847] reboot: System halted</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="五、Linux初学1"><a href="#五、Linux初学1" class="headerlink" title="五、Linux初学1"></a>五、Linux初学1</h1><p>1、获取源码；2、编译源码；3、烧录可执行文件；4、显示效果</p><p>一直在了解源码，但怎么都学不会，直到现在也没能在屏幕上输出个hello world。现在想要在自己的板上，一步一步学习使用。第一件事就是把别人做好的源码进行编译输出个东西，然后再去修改。</p><h2 id="一、u-boot"><a href="#一、u-boot" class="headerlink" title="一、u-boot"></a>一、u-boot</h2><p>1、获取源码<br>git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01</p><p>2、生成配置文件</p><ul><li><p>如果需要生成在sdram里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_defconfig</p></li><li><p>如果需要生成在spiflash里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_spiflash_defconfig</p></li></ul><p>3、编译</p><ul><li>make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12</li></ul><h2 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h2><p>1、获取源码：</p><p>git clone –depth&#x3D;1 -b f1c100s-480272lcd-test <a href="https://github.com/Icenowy/linux.git">https://github.com/Icenowy/linux.git</a></p><p>不知道为何我克隆时，上面.git后缀必须要去掉。</p><p>wget <a href="http://dl.sipeed.com/LICHEE/Nano/SDK/config">http://dl.sipeed.com/LICHEE/Nano/SDK/config</a></p><p>mv config .config</p><p>2、编译源码：</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><h2 id="三、烧录可执行文件："><a href="#三、烧录可执行文件：" class="headerlink" title="三、烧录可执行文件："></a>三、烧录可执行文件：</h2><p>编译完成后将linux&#x2F;arch&#x2F;arm&#x2F;boot下的“zImage”文件和linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts下的“suniv-f1c100s-licheepi-nano.dtb”文件拷贝到TF卡第一分区。</p><p>在第一分区中放入boot.scr文件。其他按照前面文章进行即可运行。</p><h2 id="四、显示效果："><a href="#四、显示效果：" class="headerlink" title="四、显示效果："></a>四、显示效果：</h2><p>串口调试助手会输出运行信息，界面也会显示信息。在串口调试助手上可以使用Linux命令进行基本操作。</p><p>使用的是800x480的屏，但Linux配置的是480x272的显示，因此显示不是全屏。这也变成了后期学习的一点。</p><img src="/posts/2989473239/30e2c79f8392e1c8392cade7396bee20.png" class="" title="img"><h1 id="六、裸机寄存器点灯"><a href="#六、裸机寄存器点灯" class="headerlink" title="六、裸机寄存器点灯"></a>六、裸机寄存器点灯</h1><p>按照《嵌入式Linux应用开发 完全手册》，了解寄存器的操作，编译流程，硬件执行流程。</p><h2 id="1、修改LED源码"><a href="#1、修改LED源码" class="headerlink" title="1、修改LED源码"></a>1、修改LED源码</h2><p>按照书上编辑修改LED源代码：其中寄存器地址与IO偏移按照芯片手册和电路实际IO进行修改。我的电路使用PA0、PA1作为按键输入，PA2、PA3作为LED输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File led_on_c.c</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_CFG0(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x00)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_DAT(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x10)))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT33</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT0));<span class="comment">//PA0 in</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT1));<span class="comment">//PA1 in</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT2));<span class="comment">//PA2 clear</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT3));<span class="comment">//PA3 clear</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT2);<span class="comment">//PA2 out</span></span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT3);<span class="comment">//PA3 out</span></span><br><span class="line"> </span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT2);<span class="comment">//PA2 reset</span></span><br><span class="line">delay();</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">delay();</span><br><span class="line"><span class="keyword">if</span>((PA_DAT &amp; (<span class="number">0x1</span> &lt;&lt; BIT0)) != <span class="number">0x0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT3);<span class="comment">//PA3 reset</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// about 408ms when CPU_CLK_SRC uses OSC24M</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">__asm <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; ldr r0, =76480\n&quot;</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; loop:cmp r0,#0\n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; beq exit \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; sub r0,r0,#1 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; b loop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot;exit:nop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、编写start-s文件，makefile文件"><a href="#2、编写start-s文件，makefile文件" class="headerlink" title="2、编写start.s文件，makefile文件"></a>2、编写start.s文件，makefile文件</h2><p>原本按照书上编写了start.s文件，makefile文件，但经过多次尝试后发现书上的不能照抄。在网上查资料，发现全志的芯片需要一个tools工具，能够将代码端放到指定位置，以及各种初始化。从网上下载源码后，发现其中有F1C100.s对应了书上的start.s。但并不能按照书上简单组合，还需要各种辅助文件。文件已上传在我的资源中。</p><img src="/posts/2989473239/4cbeacf8920f070734f393a22043e28f.png" class="" title="img"><h2 id="3、编译后，烧写到SD卡，运行效果"><a href="#3、编译后，烧写到SD卡，运行效果" class="headerlink" title="3、编译后，烧写到SD卡，运行效果"></a>3、编译后，烧写到SD卡，运行效果</h2><img src="/posts/2989473239/5c768d84974c935a5e386ffc5c94ea0f.png" class="" title="img"><p>这个灯在500ms闪烁。按住PA0，会使PA3点亮。</p><p>参考：<a href="https://www.bilibili.com/read/cv9477324">【荔枝派Nano】F1C100S的boothead和BROM - 哔哩哔哩</a></p><h1 id="七、Linux初学2"><a href="#七、Linux初学2" class="headerlink" title="七、Linux初学2"></a>七、Linux初学2</h1><p>1、uboot移植、修改LED灯；2、学习uboot代码；3、阅读代码的取巧方法</p><h2 id="1、uboot移植"><a href="#1、uboot移植" class="headerlink" title="1、uboot移植"></a>1、uboot移植</h2><p>认知：使用uboot指令控制LED灯，在uboot&#x2F;cmd文件中找到led指令文件，在uboot&#x2F;cmd&#x2F;makefile文件中查看是否链接led指令文件，如果未链接则需要添加。原有添加方式中需要判断UBOOT_CMD_LED的值，需要在uboot&#x2F;.config中设置UBOOT_CMD_LED&#x3D;y，将led指令文件编译连接到指令中。</p><p>编译后，下载到demo板，打开串口调试工具，输入help指令，可以看到有led指令，在输入了的指令，可以看到介绍，对比介绍与led指令文件中一致，表示指令过程正确。</p><p>但现在的指令不能执行硬件动作，猜测需要修改驱动和设备树，以支持led设备。</p><h2 id="2、学习uboot代码"><a href="#2、学习uboot代码" class="headerlink" title="2、学习uboot代码"></a>2、学习uboot代码</h2><p>利用正确的Uboot代码，输出信息到串口调试助手：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[20:57:46.566]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[20:57:46.926]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)preloader_console_init\spl.c</span><br><span class="line">DRAM: 64 MiBsunxi_board_init\board.c</span><br><span class="line">Trying to boot from MMC1boot_from_devices\spl.c</span><br><span class="line"></span><br><span class="line">[20:57:47.096]收←◆</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner TechnologyU_BOOT_VERSION_STRING\version.h  display_options_get_banner_priv\display_options.c</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)print_cpuinfo\cpu_info.c</span><br><span class="line">Model: Lichee Pi Nanoshow_board_info\board_info.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DRAM:  64 MiBannounce_dram_init+show_dram_config\board_f.c+display_options.c</span><br><span class="line"></span><br><span class="line">[20:57:47.628]收←◆MMC:   SUNXI SD/MMC: 0initr_mmc+mmc_initialize+print_mmc_devices\board_r.c+mmc.c+mmc_legasy.c</span><br><span class="line"></span><br><span class="line">[20:57:47.706]收←◆*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">__led_init: failed requesting GPIO0!</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[20:57:48.734]收←◆ 1 </span><br><span class="line">[20:57:49.735]收←◆ 0 </span><br><span class="line"></span><br><span class="line">[20:57:49.798]收←◆switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[20:57:50.345]收←◆Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[20:57:50.489]收←◆reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"><span class="symbol">4393 </span>bytes <span class="keyword">read</span> in <span class="number">25</span> ms (<span class="number">170.9</span> KiB/s)</span><br><span class="line"></span><br><span class="line">[20:57:50.561]收←◆starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue &#x27;usb start&#x27; first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure><p>然后按照这个输出信息，一条一条找到执行位置，上面标红为函数接口，蓝色为接口所在源文件。</p><img src="/posts/2989473239/10cdaf8614a42f1d79e87f6a0000ba29.png" class="" title="img"><p>屏蔽以上代码后，下面的输出信息依旧存在，表示下面的输出信息位于执行borad_init_f()之前。</p><img src="/posts/2989473239/0f737d68dc200a9f2776188a7cd996d1.png" class="" title="img"><p>在指定位置添加调试信息，发现以下部分信息属于borad_init_f()内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">++++++++</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br></pre></td></tr></table></figure><p>这之后的信息属于board_init_r()内。</p><p><strong>前几天不是纠结uboot中函数在何处调用问题吗，今天找到一个笨办法了，就是把函数本身名修改成另一个，然后再编译，就会提示哪个位置有错误或警告，那就是被调用位置呐。****阅读代码的取巧方法。</strong></p><p>使用上述方法后终于找到了所有输出信息对应的位置。</p><img src="/posts/2989473239/3d5bb221c3db83abc167c2220fc285b1.png" class="" title="img"><p>时发现了这个BUG，就是代码是灰色的，但是却是会执行的。下一步是想办法控制LED亮灭。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119389552">自制F1C200S demo板（一、电路）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119393266">自制F1C200S demo板（二、Win上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119460667">自制F1C200S demo板（三、Linux上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120074618">自制F1C200S demo板（四、TF卡启动）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120291080">自制F1C200S demo板（五、Linux初学1）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/121530962">自制F1C200S demo板（六、裸机寄存器点灯）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120330444">自制F1C200S demo板（七、Linux初学2）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C200S demo板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="demo板" scheme="https://zml3589110.github.io/tags/demo%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>f1c100sf1c200s 裸机程序</title>
    <link href="https://zml3589110.github.io/posts/931990122.html"/>
    <id>https://zml3589110.github.io/posts/931990122.html</id>
    <published>2025-09-10T07:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.277Z</updated>
    
    <content type="html"><![CDATA[<p>整理了F1C200S的裸机学习过程，只实现了一些基础的应用。<br>直接上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/F1C200S.git</span><br></pre></td></tr></table></figure><p>使用make构建工程，编译工具 arm-none-eab-gcc 10.3 下载使用XBOOT 大神的 xfel<br>详细编译说明readme.md ：<a href="https://gitee.com/dmcus/F1C200S/blob/master/README.md">https://gitee.com/dmcus/F1C200S/blob/master/README.md</a></p><p>没接触过make构建的参考学习例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/makefile-notes</span><br></pre></td></tr></table></figure><p>开发板使用：LC-PI-200S Board CherryPi ,其他开发板未测试，请根据实际情况调整代码。</p><p>已实现功能：<br>外设：        GPIO I2C SPI UART USB-CDC DISPLAY SD<br>移植其他开源库： SFUD LVGL8 LVGL9 FatFs infoNes VNes CherryUSB-CDC<br>外围设备：     GT911 24C02 W25Q128<br>RTOS:        RT-Thread 4.1 原版本使用scons构建，主要添加Makfe构建，移植RT-Thread Studio自动生成的代码。</p><p>暂未实现：音频、视频编解码、摄像头、麦克。</p><p>bootloader下载到flash 地址0，例子下载到 0x10000地址，运行后会拷贝到 DRAM 中运行，串口打印使用UART1。</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">doc  ------文档和原理图 使用LCPI F1C200S 开发板 集成CH340E -&gt; UART1</span><br><span class="line">sources ---源码</span><br><span class="line">    |bootloader -----SPL 烧录FLASH 0,log 使用 UART1</span><br><span class="line">    |drivers---------f1c200s驱动</span><br><span class="line">    |fc200s_brom ----sram运行的独立程序 烧录FLASH 0 支持串口</span><br><span class="line">    |examples--------peripherals examples 外设样例，裸机程序 使用LCPI F1C200S 开发板</span><br><span class="line">    |mksunxi --------.bin文件添加校验头工具</span><br><span class="line">    |rtt-------------rt-thread 烧录到FLASH 0X10000 log 使用 UART1</span><br><span class="line">tools -----make 工具 添加到环境变量</span><br><span class="line">1.bootload下载</span><br><span class="line"> cd sources&#x2F;bootloader</span><br><span class="line">   make all</span><br><span class="line">   make download</span><br><span class="line"> </span><br><span class="line">2.i2c uart gpio 等例子编译下载</span><br><span class="line">  cd sources&#x2F;examples&#x2F;uart</span><br><span class="line">  make all</span><br><span class="line">  make download</span><br></pre></td></tr></table></figure><p>感谢大神们的无私奉献，主要参考以下开源工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nminaylov&#x2F;F1C100s_projects.git</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;lhdjply&#x2F;f1c200s_library</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;VeiLiang&#x2F;BoloRTT.git</span><br></pre></td></tr></table></figure><hr><p>这个包里有个make download，因为我没有编译成功linux下的sunsi，所以我用windows的sunxi-fel下载到芯片，但串口没有任何响应，请问我的操作是否有误？</p><p>window 下操作，linux没测试过。需要先编译下载bootloader到 flash 0 ，然后下载例子到 flash 0x10000。串口使用的是 UART1输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download:$(BIN)</span><br><span class="line">    ifeq ($(TARGET),bootloader)</span><br><span class="line">xfel spinor write 0 $(BIN)</span><br><span class="line">    else</span><br><span class="line">xfel spinor write 0x10000 $(BIN)</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11525.html">f1c100s&#x2F;f1c200s 裸机程序。</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</title>
    <link href="https://zml3589110.github.io/posts/246263880.html"/>
    <id>https://zml3589110.github.io/posts/246263880.html</id>
    <published>2025-09-10T07:41:20.000Z</published>
    <updated>2025-09-10T13:10:14.184Z</updated>
    
    <content type="html"><![CDATA[<p>原始工程使用f1c100s&#x2F;f1c200s 裸机程序，参见 <a href="https://whycan.com/t_11525.html">https://whycan.com/t_11525.html</a></p><p>工程构建：make<br>操作系统：windows</p><p>FreeRTOS没有ARM9的例子，ARM7和ARM9内核很相似，主要参考ARM7_LPC2000 移植。</p><p>FreeRTOS源码下载：<br>哇酷下载：<a href="https://whycan.com/files/members/15085/RTOS-KernelV11.1.0.zip">RTOS-KernelV11.1.0.zip</a><br>github下载：<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/releases">https://github.com/FreeRTOS/FreeRTOS-Kernel/releases</a></p><p>一、文件目录结构搭建</p><p>1.解压重命名为FreeRTOS ，新建文件夹port</p><p>2.复制 FreeRTOS&#x2F;portable&#x2F;GCC&#x2F;ARM7_LPC2000 下 port.c portISR.c portmacro.h 到 port目录下</p><p>3.复制FreeRTOS&#x2F;portable&#x2F;MemMang 到FreeRTOS&#x2F;MemMang</p><p>4.复制 FreeRTOS&#x2F;examples&#x2F;template_configuration&#x2F;FreeRTOSConfig.h 到 include目录下</p><p>\5. 删除examples portable 文件夹。完成后的目录结构如下</p><img src="/posts/246263880/rtpng.png" class="" title="目录结构"><p>移植过程：</p><p>添加FreeRTOS 中断，修改工程文件 vectors.S，定义宏 <strong>USE_FREERTOS</strong> ， 修改 _software_interrupt 和 _irq 两个中断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*任务切换*&#x2F; </span><br><span class="line">_software_interrupt: </span><br><span class="line">#if defined (USE_FREERTOS)</span><br><span class="line">    .word vPortYieldProcessor</span><br><span class="line">#else</span><br><span class="line">    .word software_interrupt</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*系统嘀嗒心跳*&#x2F; </span><br><span class="line">_irq:</span><br><span class="line">#if defined (USE_FREERTOS) </span><br><span class="line">    .word vFreeRTOS_ISR</span><br><span class="line">#else</span><br><span class="line">    .word irq</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>port.c 和 portISR.c ，添加定时器初始化和定时器中断切换任务功能</p><p>port.c 添加头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;f1c100s_timer.h&quot;</span><br><span class="line">#include &quot;f1c100s_intc.h&quot;</span><br></pre></td></tr></table></figure><p>定时器time0初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Setup the timer 0 to generate the tick interrupts at the required frequency.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void prvSetupTimerInterrupt(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void vTickISR(void); </span><br><span class="line"> </span><br><span class="line">    tim_init(TIM0, TIM_MODE_CONT, TIM_SRC_HOSC, TIM_PSC_1);</span><br><span class="line">    tim_set_period(TIM0, 24000000UL&#x2F;1000UL);&#x2F;&#x2F;1ms中断</span><br><span class="line">    tim_int_enable(TIM0); </span><br><span class="line">    intc_set_irq_handler(IRQ_TIMER0, vTickISR); </span><br><span class="line">    intc_enable_irq(IRQ_TIMER0); </span><br><span class="line">    tim_start(TIM0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 接管所有的中断，添加上下文切换保存和恢复，添加naked属性，禁用编译器上下文管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*__attribute__((naked)) 很关键 不加调度</span><br><span class="line"> *使用naked属性可以告诉编译器不生成函数的prologue和epilogue代码，</span><br><span class="line"> *这样任务切换函数可以自行管理寄存器的入栈和恢复，从而简化上下文管理*&#x2F;</span><br><span class="line">void vFreeRTOS_ISR(void) __attribute__((naked));</span><br><span class="line">void vFreeRTOS_ISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void irq_handler(void);</span><br><span class="line">    &#x2F;* Save the context of the interrupted task. *&#x2F;</span><br><span class="line">    portSAVE_CONTEXT();</span><br><span class="line">    &#x2F;* irq all*&#x2F;</span><br><span class="line">    irq_handler();</span><br><span class="line">    &#x2F;* Restore the context of the new task. *&#x2F;</span><br><span class="line">    portRESTORE_CONTEXT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 系统嘀嗒中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef write32</span><br><span class="line">#define write32(x, y) (*((volatile uint32_t *)(x)) &#x3D; y)</span><br><span class="line">#endif</span><br><span class="line">#include &quot;task.h&quot;</span><br><span class="line">void vTickISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* Increment the RTOS tick count, then look for the highest priority</span><br><span class="line">     * task that is ready to run. *&#x2F;</span><br><span class="line">    if (xTaskIncrementTick() !&#x3D; pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskSwitchContext();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Ready for the next interrupt. *&#x2F;</span><br><span class="line">    write32((0x01C20C00) + 0x04, (1 &lt;&lt; 0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 添加 堆栈溢出 回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void vApplicationStackOverflowHook(TaskHandle_t xTask,</span><br><span class="line">                                   char *pcTaskName)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;statck over flow:%s&quot;,pcTaskName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeRTOSConfig.h 修改heap大小 和 位宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define configTOTAL_HEAP_SIZE                        512*1024</span><br><span class="line">#define configTICK_TYPE_WIDTH_IN_BITS              TICK_TYPE_WIDTH_32_BITS</span><br></pre></td></tr></table></figure><p>makefile 添加 <strong>CFLAGS+&#x3D;-DUSE_FREERTOS</strong><br>至此移植完成。</p><p>gcc和xfel：<br>usb下载工具 xfel 和USB驱动下载： <a href="https://github.com/xboot/xfel/releases/download/v1.3.2/xfel-windows-v1.3.2.7z">xfel-v1.3.2</a><br>gcc：<a href="https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C">arm-none-eab-gcc-10.3</a><br>make rm工具在工程目录下</p><p>完整移植好的FreeRTOS 11.1工程下载：<a href="https://whycan.com/files/members/15085/F1C200S_FreeRTOS.zip">F1C200S_FreeRTOS.zip</a></p><p>编译: arm-none-eabi-gcc 和xfel添加到环境变量 ，打开cmd命令行 ，进入 F1C200S_FreeRTOS 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br><span class="line">make download</span><br></pre></td></tr></table></figure><hr><p>花了五块验证程序可以用，只是FreeRTOS部分移到自己工程后，切换上下文有点问题。<br>修改汇编里面的中断后成功启动，感谢楼主</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11538.html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</summary>
    
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/categories/FreeRtos/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/tags/FreeRtos/"/>
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>USB转串口芯片</title>
    <link href="https://zml3589110.github.io/posts/4211420882.html"/>
    <id>https://zml3589110.github.io/posts/4211420882.html</id>
    <published>2025-09-10T03:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沁恒"><a href="#沁恒" class="headerlink" title="沁恒"></a>沁恒</h1><h2 id="CH9102X"><a href="#CH9102X" class="headerlink" title="CH9102X"></a>CH9102X</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="CP2102-GMR替换为CH9102X后无法识别USB设备"><a href="#CP2102-GMR替换为CH9102X后无法识别USB设备" class="headerlink" title="CP2102-GMR替换为CH9102X后无法识别USB设备"></a>CP2102-GMR替换为CH9102X后无法识别USB设备</h4><p>我做了两块板子，一块是用CP2102-GMR的，另一块以为货期问题，使用CH9102X作为替换，百度上很多都说<a href="https://bbs.elecfans.com/zhuti_dianlu_1.html">电路</a>不用修改就可以直接替换的，但是使用CP2102的板子能正常被电脑识别，使用CH9102X的板子连接上USB后，系统提示无法识别USB设备描述，安装官方的VCP也是无法识别，下附电路图为CP2102的，CH9102X为直接替换，是需要修改什么电路吗？</p><img src="/posts/4211420882/pYYBAGK1MI6AOJkUAAIpE9sw_p0850.png" class="" title="img"><p>解答:</p><p>如上提示代表USB设备枚举不成功。原理图影响USB识别的原因应该为芯片#6脚在5V供电模式下没有外接退耦电容所致（建议容值104）。手册说明如下所示：</p><img src="/posts/4211420882/1652858167945200.png" class="" title="img"><p>加了电容之后可以识别到了，但是DTR的引脚可以正常控制，RTS引脚控制不了，一直是高电平状态，用调试助手打开关闭也没有效果</p><p>CH9102等第三代USB转串口芯片同时支持VCP和CDC两种驱动模式，如上现象应该是您使用的是CDC串口驱动导致，请更新使用如下VCP驱动即可，驱动链接：<a href="http://www.wch.cn/downloads/CH343SER_EXE.html">http://www.wch.cn/downloads/CH343SER_EXE.html</a>?<br>关于CDC串口和VCP串口等区别，也看下方案中相关说明：<a href="http://www.wch.cn/application/357.html">http://www.wch.cn/application/357.html</a>?</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://bbs.elecfans.com/jishu_2289360_1_1.html">CP2102-GMR替换为CH9102X后无法识别USB设备是为什么？</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">CH9102X沁恒USB转串口芯片</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/categories/CH9102X/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="沁恒" scheme="https://zml3589110.github.io/tags/%E6%B2%81%E6%81%92/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/tags/CH9102X/"/>
    
    <category term="CP2102" scheme="https://zml3589110.github.io/tags/CP2102/"/>
    
  </entry>
  
  <entry>
    <title>DNS自动选择最佳服务器的实战指南</title>
    <link href="https://zml3589110.github.io/posts/2322562202.html"/>
    <id>https://zml3589110.github.io/posts/2322562202.html</id>
    <published>2025-09-09T08:25:20.000Z</published>
    <updated>2025-09-10T13:10:14.372Z</updated>
    
    <content type="html"><![CDATA[<p>简介：DNS，作为互联网的关键服务，负责将域名转换为IP地址以优化网络连接。DNS自动选取功能使系统能根据网络条件选择响应最快的服务器。DNS跳跃（DnsJumper）工具可帮助用户测试和切换到最佳DNS服务器。文章概述了DNS解析过程、服务器选择、缓存机制、优选技术和DnsJumper的使用方法，还讨论了安全性和网络性能改善等实用知识点。</p><img src="/posts/2322562202/350a1c87c7b83de0dc9e8ba252434266.png" class="" title="dns自动选取"><h2 id="1-DNS作用及解析过程"><a href="#1-DNS作用及解析过程" class="headerlink" title="1. DNS作用及解析过程"></a>1. DNS作用及解析过程</h2><h3 id="1-1-DNS定义与作用"><a href="#1-1-DNS定义与作用" class="headerlink" title="1.1 DNS定义与作用"></a>1.1 DNS定义与作用</h3><p>域名系统（Domain Name System, DNS）是互联网的一项核心服务，它负责将人类可读的域名转换为机器可识别的IP地址。DNS的存在使得用户无需记忆复杂的数字序列，而只需要输入易于理解的域名即可访问网站，极大地提高了互联网的易用性。</p><h3 id="1-2-DNS解析过程"><a href="#1-2-DNS解析过程" class="headerlink" title="1.2 DNS解析过程"></a>1.2 DNS解析过程</h3><p>DNS解析过程涉及用户请求域名到获得IP地址的转换，主要步骤如下：</p><ol><li>用户输入域名后，设备首先查询本地缓存是否有对应的域名解析记录。</li><li>若本地缓存未命中，则请求会到达配置的递归DNS服务器。</li><li>递归DNS服务器会启动迭代解析流程，依次查询根域名服务器、顶级域名服务器及权威域名服务器，最终返回目标域名对应的IP地址给用户。</li></ol><p>在整个解析过程中，可能涉及多种缓存机制，以优化响应时间并减轻根服务器的负载</p><h2 id="2-DNS服务器选择与缓存机制"><a href="#2-DNS服务器选择与缓存机制" class="headerlink" title="2. DNS服务器选择与缓存机制"></a>2. DNS服务器选择与缓存机制</h2><h3 id="2-1-DNS服务器的工作原理"><a href="#2-1-DNS服务器的工作原理" class="headerlink" title="2.1 DNS服务器的工作原理"></a>2.1 DNS服务器的工作原理</h3><p>DNS服务器在处理查询请求时主要采用两种方法：递归解析和迭代解析。</p><ul><li><strong>递归解析</strong> ：在这种方式中，当一个DNS解析器（比如，用户的电脑）向DNS服务器发起请求时，如果该服务器没有所请求域名的记录，则会代替请求者去别的DNS服务器查询，直至找到记录并返回给请求者。递归查询对于客户端来说比较简单，因为客户端只需要向一个服务器发出请求，就可以得到最终结果。</li><li><strong>迭代解析</strong> ：这种方式中，DNS服务器不会代替请求者查询，而是返回一个更靠近所查询域名记录的DNS服务器的地址，请求者需要向这个新的地址发出请求。如果新的服务器也无记录，则再次返回另一个地址，如此迭代，直到找到记录为止，或者返回错误信息表示未找到。</li></ul><p>递归解析和迭代解析的对比：</p><ul><li><strong>性能影响</strong> ：递归解析可能导致服务器过载，因为需要为大量请求进行多次查询；而迭代解析将查询工作分散到多个服务器，减轻单个服务器的压力。</li><li><strong>效率</strong> ：递归解析通常更快，因为它为请求者隐藏了查询过程；迭代解析则对客户端的智能程度要求更高。</li><li><strong>实现复杂性</strong> ：递归解析对DNS服务器来说更复杂，因为它需要管理查询状态并可能与多个服务器通信；迭代解析的逻辑相对简单。</li></ul><h4 id="2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色"><a href="#2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色" class="headerlink" title="2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色"></a>2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色</h4><p>DNS系统由多个层级的服务器组成，每个层级的服务器都有其特定的角色和职责：</p><ul><li><strong>根域名服务器</strong> ：它们是DNS层级结构的最顶层，负责解析顶级域名（如.com、.org、.net等）的地址。当本地DNS服务器没有相关记录时，它会首先联系根域名服务器来获取顶级域名服务器的地址。</li><li><strong>顶级域名服务器（TLD）</strong> ：管理着所有二级域名的DNS记录。例如，在请求 <code>google.com </code>时，根域名服务器会提供 <code>.com </code>顶级域名服务器的地址，之后本地DNS服务器将查询发送至 <code>.com </code>顶级域名服务器。</li><li><strong>权威域名服务器</strong> ：这些服务器拥有特定域名的完整数据记录。它们要么是域名注册商提供的，要么是自行管理的。当顶级域名服务器指向了相应的权威服务器后，解析过程便会在这里完成，返回给查询者IP地址或其他相关信息。</li></ul><p>DNS层级结构保证了域名查询的高效和分摊管理责任，通过逐级查询，最终获得准确的IP地址映射信息。</p><h3 id="2-2-DNS缓存机制的原理与作用"><a href="#2-2-DNS缓存机制的原理与作用" class="headerlink" title="2.2 DNS缓存机制的原理与作用"></a>2.2 DNS缓存机制的原理与作用</h3><h4 id="2-2-1-缓存的作用与优势"><a href="#2-2-1-缓存的作用与优势" class="headerlink" title="2.2.1 缓存的作用与优势"></a>2.2.1 缓存的作用与优势</h4><p>DNS缓存是在本地存储域名到IP地址映射记录的过程，这样可以加快后续相同域名查询的速度，并减轻上游DNS服务器的负担。</p><ul><li><strong>减少查询延迟</strong> ：由于缓存记录了之前解析过的域名信息，因此在本地进行快速查询，避免了重复查询整个DNS层级结构的时间损耗。</li><li><strong>降低网络负载</strong> ：缓存减少了对上游服务器的请求，从而减少了网络流量。</li><li><strong>提高系统可靠性</strong> ：在本地有缓存的情况下，即使上游服务器不可用，部分查询也可能得到快速响应。</li></ul><h4 id="2-2-2-缓存过程中的常见问题及解决方案"><a href="#2-2-2-缓存过程中的常见问题及解决方案" class="headerlink" title="2.2.2 缓存过程中的常见问题及解决方案"></a>2.2.2 缓存过程中的常见问题及解决方案</h4><p>尽管缓存机制有很多优点，但也存在一些问题：</p><ul><li><strong>缓存过时问题</strong> ：如果域名记录发生变化，而本地缓存尚未更新，就可能出现解析错误的情况。解决这个问题的一种方法是设置一个合理的缓存超时时间，这样记录在一定时间后会过期，迫使DNS服务器重新从权威服务器获取最新信息。</li><li><strong>缓存污染问题</strong> ：恶意的DNS服务器可能会发送错误的记录到缓存中，导致解析错误。对于这个问题，可以通过验证记录的来源和配置安全的DNS解析器来加强防护。</li><li><strong>缓存策略优化</strong> ：需要针对不同的应用场景和记录类型，制定合理、灵活的缓存策略，以平衡速度与准确性。例如，对于经常变动的网站，可以设置较短的缓存时间，而对于相对稳定的域名，则可以设置较长的缓存时间。</li></ul><p>缓存机制是DNS系统高效运行的关键组成部分，但必须合理管理和优化，以保证其长期稳定提供服务。接下来的章节将进一步探讨与DNS缓存相关的技术细节，包括缓存策略的优化和实际应用中的最佳实践。</p><p>为了更好地理解DNS缓存策略和常见的DNS问题，下文将展示一个具体的DNS服务器配置缓存的代码示例，并进行详细分析。</p><h2 id="3-DNS优选技术与自动选取原理"><a href="#3-DNS优选技术与自动选取原理" class="headerlink" title="3. DNS优选技术与自动选取原理"></a>3. DNS优选技术与自动选取原理</h2><h3 id="3-1-DNS优选技术概述"><a href="#3-1-DNS优选技术概述" class="headerlink" title="3.1 DNS优选技术概述"></a>3.1 DNS优选技术概述</h3><h4 id="3-1-1-测速技术"><a href="#3-1-1-测速技术" class="headerlink" title="3.1.1 测速技术"></a>3.1.1 测速技术</h4><p>DNS优选技术的核心是能够快速准确地为用户选择出响应速度最快、服务质量最佳的DNS服务器。为了实现这一目标，必须先对DNS服务器的响应时间进行准确的测量。</p><p>测速技术可以通过发送查询请求到不同的DNS服务器并记录它们响应的时间来实现。这些时间测量包括但不限于：</p><ul><li><strong>请求时间（RTT）</strong> ：从发出查询请求到收到响应的时间。RTT越低，说明距离客户端越近或处理速度越快。</li><li><strong>丢包率</strong> ：在测试过程中数据包丢失的比例。一个稳定的DNS服务器应具备低丢包率。</li><li><strong>服务质量（QoS）</strong> ：对响应速度和丢包率之外的其他因素的综合评估，如服务器的负载状况。</li></ul><p>现代网络工具如 <code>dig </code>, <code>nslookup </code>, 或专用的DNS测速工具可以用来进行这些测量。实践中，通过编写脚本或使用现成的网络管理工具，可以自动化这一过程并持续监测DNS服务器的性能。</p><h4 id="3-1-2-智能决策算法"><a href="#3-1-2-智能决策算法" class="headerlink" title="3.1.2 智能决策算法"></a>3.1.2 智能决策算法</h4><p>优选技术不仅依赖于准确的测速，还需要智能决策算法来分析测速结果，并据此做出最优的DNS选择。这些算法可以采用不同的策略和参数进行决策，例如：</p><ul><li><strong>加权轮询</strong> ：为每个DNS服务器基于其性能表现赋予不同的权重，然后按照权重进行轮询。</li><li><strong>最快响应优先</strong> ：简单选择最近一次测量中响应最快的服务器。</li><li><strong>自适应算法</strong> ：依据网络状况和历史数据动态调整决策策略。</li></ul><p>智能算法的设计必须考虑各种可能影响DNS查询性能的因素，并且能够适应网络环境的变化。例如，当某个服务器突然变得不可用或响应变慢时，算法需要能够迅速调整，将流量转移到表现更好的服务器上。</p><h3 id="3-2-DNS自动选取机制"><a href="#3-2-DNS自动选取机制" class="headerlink" title="3.2 DNS自动选取机制"></a>3.2 DNS自动选取机制</h3><h4 id="3-2-1-自动选取的实现方式"><a href="#3-2-1-自动选取的实现方式" class="headerlink" title="3.2.1 自动选取的实现方式"></a>3.2.1 自动选取的实现方式</h4><p>DNS自动选取机制主要通过在设备或系统级别实现智能DNS客户端来达成。智能DNS客户端会监听系统的DNS查询请求，并根据优选技术的结果动态地选择最佳DNS服务器进行响应。实现这一机制的基本步骤如下：</p><ol><li><strong>初始化</strong> ：客户端启动时，向多个DNS服务器发送查询请求，收集初步的性能数据。</li><li><strong>监控</strong> ：在正常运行过程中，持续监控所有已知DNS服务器的性能状态。</li><li><strong>决策</strong> ：根据实时或准实时的性能数据，利用决策算法动态选择最优DNS服务器。</li><li><strong>更新</strong> ：当网络条件或性能数据发生变化时，更新DNS选择决策，并通知系统的其余部分。</li></ol><h4 id="3-2-2-自动选取的算法分析"><a href="#3-2-2-自动选取的算法分析" class="headerlink" title="3.2.2 自动选取的算法分析"></a>3.2.2 自动选取的算法分析</h4><p>自动选取算法的效率和效果直接关系到DNS优选技术的成功与否。我们以一个简化的伪代码例子来说明这一算法过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码展示DNS自动选取算法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化权重字典</span></span><br><span class="line">server_weights = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_weights</span>(<span class="params">server_performance</span>):</span></span><br><span class="line">    <span class="comment"># 更新服务器权重</span></span><br><span class="line">    <span class="comment"># 此处省略权重计算的具体逻辑</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> server_performance:</span><br><span class="line">        server_weights[server] = calculate_weight(server_performance[server])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_dns</span>():</span></span><br><span class="line">    <span class="comment"># 根据权重选择DNS服务器</span></span><br><span class="line">    selected_dns = <span class="built_in">max</span>(server_weights, key=server_weights.get)</span><br><span class="line">    <span class="keyword">return</span> selected_dns</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 模拟性能监控更新</span></span><br><span class="line">server_performance = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.4</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.45</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.15</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更新权重</span></span><br><span class="line">update_weights(server_performance)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择最佳DNS</span></span><br><span class="line">best_dns = select_dns()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前最佳DNS服务器为:&quot;</span>, best_dns)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个权重字典 server_weights ，用于存储每个DNS服务器当前的权重。 update_weights 函数根据每个服务器的性能表现来更新权重，而 select_dns 函数则根据当前的权重来选择最佳的DNS服务器。实际应用中， calculate_weight 函数会非常复杂，它需要综合考虑多个性能参数并最终输出权重值。</p><p>值得注意的是，实际的自动选取算法可能还会包含容错逻辑，例如在选择过程中剔除掉响应异常的DNS服务器，或者在所有DNS服务器都表现不佳时提供默认备选方案。</p><p>本章节介绍了DNS优选技术及其背后的测速技术和智能决策算法。同时，深入探讨了DNS自动选取机制的实现方式和关键算法，为下一章节深入分析DnsJumper等软件提供了理论基础。</p><h2 id="4-DnsJumper功能与使用场景"><a href="#4-DnsJumper功能与使用场景" class="headerlink" title="4. DnsJumper功能与使用场景"></a>4. DnsJumper功能与使用场景</h2><p>DnsJumper 是一款小巧的网络工具软件，旨在帮助用户轻松管理和优化 DNS 设置。它不仅支持多种操作系统，还具有友好的用户界面，使得普通用户也能进行专业级别的 DNS 设置。本章节将对 DnsJumper 的功能特性进行深入解析，并分享其在不同使用场景中的实际应用案例。</p><h3 id="4-1-DnsJumper软件介绍"><a href="#4-1-DnsJumper软件介绍" class="headerlink" title="4.1 DnsJumper软件介绍"></a>4.1 DnsJumper软件介绍</h3><h4 id="4-1-1-DnsJumper的功能特性"><a href="#4-1-1-DnsJumper的功能特性" class="headerlink" title="4.1.1 DnsJumper的功能特性"></a>4.1.1 DnsJumper的功能特性</h4><p>DnsJumper 以其轻量级和多功能性著称，它集成了 DNS 测速、切换、备份和恢复等多种功能。这些功能可以在不需要深入了解网络技术的情况下，简单快捷地帮助用户优化网络连接。</p><ul><li><strong>DNS 测速功能</strong> ：通过内置的测速功能，DnsJumper 能够测试多个 DNS 服务器的响应时间，帮助用户找出速度最快的 DNS 服务器进行连接。</li><li><strong>智能 DNS 切换</strong> ：DnsJumper 支持自动选择最佳的 DNS 服务器，采用智能算法根据响应时间进行优化。</li><li><strong>一键备份和恢复</strong> ：软件提供了简单快捷的 DNS 设置备份和恢复功能，确保在出现问题时能快速恢复到稳定状态。</li></ul><h4 id="4-1-2-软件界面与操作流程"><a href="#4-1-2-软件界面与操作流程" class="headerlink" title="4.1.2 软件界面与操作流程"></a>4.1.2 软件界面与操作流程</h4><p>DnsJumper 的用户界面直观明了，即使没有专业知识背景的用户也能快速上手。</p><ol><li><strong>打开 DnsJumper 软件</strong> ：用户可以双击桌面快捷方式或在程序文件夹中找到软件图标来启动 DnsJumper。</li><li><strong>使用测速功能</strong> ：在主界面中，用户可以看到“测试 DNS”按钮，点击之后软件会自动测试网络环境中的 DNS 服务器速度，并将结果以列表形式展示出来。</li><li><strong>切换 DNS</strong> ：用户可以根据测速结果，选择其中响应时间最短的 DNS 服务器，点击“应用”按钮来更改当前系统配置。</li><li><strong>备份与恢复</strong> ：如果用户想要备份当前的 DNS 设置，可以在菜单选项中选择“备份 DNS 设置”，并在需要时通过“恢复 DNS 设置”来还原。</li></ol><h3 id="4-2-DnsJumper的实际应用"><a href="#4-2-DnsJumper的实际应用" class="headerlink" title="4.2 DnsJumper的实际应用"></a>4.2 DnsJumper的实际应用</h3><h4 id="4-2-1-常见使用场景分析"><a href="#4-2-1-常见使用场景分析" class="headerlink" title="4.2.1 常见使用场景分析"></a>4.2.1 常见使用场景分析</h4><p>DnsJumper 的应用非常广泛，下面是几个常见使用场景的详细分析：</p><ul><li><strong>家庭网络优化</strong> ：对于家庭用户来说，使用 DnsJumper 可以有效地解决网络慢、打开网页卡顿等问题。通过简单几步操作，用户就可以找到最适合本地网络环境的 DNS 服务器，从而提高上网速度和稳定性。</li><li><strong>网吧或公共热点</strong> ：在网吧或咖啡厅等公共 Wi-Fi 环境，由于用户量大，DNS 服务器的响应时间可能会延长。使用 DnsJumper 可以帮助管理员快速找到并切换到响应速度更快的 DNS 服务器，改善上网体验。</li><li><strong>跨国办公网络</strong> ：对于跨国公司而言，不同国家和地区的网络环境差异较大。DnsJumper 可以帮助 IT 管理员快速评估和优化各个分支的 DNS 设置，提高办公效率。</li></ul><h4 id="4-2-2-使用DnsJumper进行DNS切换的实际案例"><a href="#4-2-2-使用DnsJumper进行DNS切换的实际案例" class="headerlink" title="4.2.2 使用DnsJumper进行DNS切换的实际案例"></a>4.2.2 使用DnsJumper进行DNS切换的实际案例</h4><p>让我们通过一个案例来看一下如何使用 DnsJumper 来进行 DNS 切换：</p><p>假设你是一名 IT 管理员，在一家拥有多个办公地点的跨国公司工作。某天，你接到报告称，位于纽约的办公室的网络访问速度很慢。为了诊断并解决问题，你决定使用 DnsJumper 进行以下步骤：</p><ol><li><strong>下载并安装 DnsJumper</strong> ：首先，你需要在受影响的办公室的电脑上下载并安装 DnsJumper。</li><li><strong>运行软件并测试 DNS</strong> ：打开 DnsJumper，使用其内置的测速功能来测试当前纽约办公室连接的 DNS 服务器速度。</li><li><strong>分析测试结果</strong> ：将测试结果与全球各大 DNS 服务器的平均响应时间进行比较，寻找是否存在明显的延迟。</li><li><strong>选择最佳 DNS 服务器</strong> ：根据测试数据，选择一个响应时间更短的 DNS 服务器。</li><li><strong>应用更改并监控效果</strong> ：使用 DnsJumper 应用新选的 DNS 服务器，并监控网络速度的提升情况。如果效果良好，则进行长期设置；如果效果不明显，可以尝试测试其他的 DNS 服务器。</li></ol><p>通过本案例可以清晰看到 DnsJumper 如何帮助解决网络性能问题，通过几步简单的操作，便可以大大改善网络访问质量。</p><h2 id="5-网络安全与设置方法"><a href="#5-网络安全与设置方法" class="headerlink" title="5. 网络安全与设置方法"></a>5. 网络安全与设置方法</h2><h3 id="5-1-DNS与网络安全的关系"><a href="#5-1-DNS与网络安全的关系" class="headerlink" title="5.1 DNS与网络安全的关系"></a>5.1 DNS与网络安全的关系</h3><h4 id="5-1-1-DNS劫持与防护措施"><a href="#5-1-1-DNS劫持与防护措施" class="headerlink" title="5.1.1 DNS劫持与防护措施"></a>5.1.1 DNS劫持与防护措施</h4><p>DNS劫持是一种常见的网络安全威胁，攻击者通过篡改DNS服务器的记录，使用户在访问网站时被重定向到恶意网站。这种攻击通常发生在用户访问不安全的网站，或者在用户设备被植入恶意软件的情况下。</p><p>为了防范DNS劫持，用户可以采取以下几种措施： - 使用安全的DNS服务，例如Google Public DNS（8.8.8.8和8.8.4.4）和Cloudflare（1.1.1.1）。 - 启用DNSSEC（域名系统安全扩展），通过加密DNS查询和响应来确保数据的完整性。 - 使用HTTPS来访问网站，而不是HTTP，因为HTTPS为数据传输提供加密保护。 - 维护操作系统和浏览器的最新安全补丁，防止恶意软件的入侵。</p><h4 id="5-1-2-安全的DNS设置指南"><a href="#5-1-2-安全的DNS设置指南" class="headerlink" title="5.1.2 安全的DNS设置指南"></a>5.1.2 安全的DNS设置指南</h4><p>设置一个安全的DNS环境是保护网络不受DNS劫持影响的关键步骤。以下是设置安全DNS的指南：- 首先，选择一个可靠的DNS提供商，并获取他们的DNS服务器地址。 - 在本地网络设备（如路由器）或操作系统中配置这些地址。如果设备支持，启用DNSSEC选项。 - 对于高级用户，可以配置防火墙规则，限制非授权的DNS查询。 - 定期检查DNS服务器的健康状态和响应时间，确保服务的可靠性。 - 对于企业用户，可以实施内部DNS系统，利用内部DNS服务器提供保护，同时减少对外部DNS服务的依赖。</p><h3 id="5-2-DNS切换对网络的影响"><a href="#5-2-DNS切换对网络的影响" class="headerlink" title="5.2 DNS切换对网络的影响"></a>5.2 DNS切换对网络的影响</h3><h4 id="5-2-1-正面与负面影响分析"><a href="#5-2-1-正面与负面影响分析" class="headerlink" title="5.2.1 正面与负面影响分析"></a>5.2.1 正面与负面影响分析</h4><p>DNS切换可以带来正面与负面影响。正面影响包括： - 提高网络速度：切换到更快的DNS服务器可以加快域名解析速度，从而提高整个网络的加载速度。 - 避免网络中断：在原DNS服务器出现问题时，切换到备用DNS可以减少或避免服务中断。 - 提升安全性：如前所述，切换到安全的DNS设置可以提升网络整体的安全性。</p><p>然而，DNS切换也可能带来一些负面影响： - 增加延迟：如果新DNS服务器响应较慢，那么可能会在短时间内增加DNS解析的延迟。 - 网络不稳定：频繁的DNS切换可能会导致网络连接不稳定。 - 配置错误风险：错误配置DNS设置可能会导致访问控制问题和网络服务中断。</p><h4 id="5-2-2-DNS切换的监控与调整策略"><a href="#5-2-2-DNS切换的监控与调整策略" class="headerlink" title="5.2.2 DNS切换的监控与调整策略"></a>5.2.2 DNS切换的监控与调整策略</h4><p>为了监控DNS切换带来的影响并及时调整策略，可以采取以下措施： - 使用网络监控工具（如Nagios或Zabbix）来跟踪DNS解析时间和网络性能指标。 - 制定监控阈值，一旦DNS解析时间超过设定阈值，系统就会发出警报。 - 定期检查DNS查询日志，以确定是否有异常的查询模式或频繁的失败。 - 实施DNS故障转移计划，确保在发现DNS问题时可以迅速切换到备用服务器。 - 根据监控结果和用户反馈调整DNS设置，并对策略进行优化。</p><p>通过上述方法，可以确保DNS切换既能够提升网络性能和安全性，又能够最小化可能产生的负面影响。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_42510243/article/details/147699615">DNS自动选择最佳服务器的实战指南</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">DNS</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="网络编程" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/categories/DnsJumper/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/categories/DNS/"/>
    
    
    <category term="网络协议" scheme="https://zml3589110.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="WIFI" scheme="https://zml3589110.github.io/tags/WIFI/"/>
    
    <category term="TCP/IP" scheme="https://zml3589110.github.io/tags/TCP-IP/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/tags/DNS/"/>
    
    <category term="域名" scheme="https://zml3589110.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/tags/DnsJumper/"/>
    
  </entry>
  
  <entry>
    <title>ESP01S基础资料</title>
    <link href="https://zml3589110.github.io/posts/1451356382.html"/>
    <id>https://zml3589110.github.io/posts/1451356382.html</id>
    <published>2025-09-09T03:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp01和esp01s的区别"><a href="#esp01和esp01s的区别" class="headerlink" title="esp01和esp01s的区别"></a>esp01和esp01s的区别</h1><p>其实，两者都是安信可公司出的两款物联网模块。ESP-01S其实是ESP-01的升级版，具体修改了哪些地方，我们详细看下。</p><p><strong>首先</strong>，安信可目前在售的模块如下（图片转自安信可官网）：</p><img src="/posts/1451356382/word-image-22.png" class="" title="img"><p>你会发现目前ESP-01S在售，而ESP-01已经不卖了。所以，网上有些店铺依然在卖ESP-01的，个人推测有两种可能：1、清库存；2、个别用户专门用这个。</p><p><strong>其次</strong>，管脚定义如下：</p><img src="/posts/1451356382/word-image-23.png" class="" title="img"><img src="/posts/1451356382/word-image-24.png" class="" title="img"><p>你会发现，两者都是8个管脚，而且管脚定义一样。不光管脚定义一样，模块尺寸也一样：</p><img src="/posts/1451356382/word-image-25.png" class="" title="img"><p><strong>第三</strong>，指示灯与上拉电阻。根据官方提供的模组选型表，我们可以知道：</p><img src="/posts/1451356382/word-image-26.png" class="" title="img"><p>指示灯的管脚，由ESP-01的TXD0变成了ESP-01S的GPIO2。然后ESP-01S模块的IO0、RST、EN管脚上增加了上拉电阻。</p><p>增加这些电阻有什么用？看下一条！</p><p><strong>第四</strong>，典型应用电路。第三点提到了ESP-01S模块中增加了上拉电阻，而增加上拉电阻的意义在于，对典型应用电路进行优化。效果如下：</p><img src="/posts/1451356382/word-image-27.png" class="" title="img"><p>ESP-01</p><img src="/posts/1451356382/word-image-28.png" class="" title="img"><p>ESP-01S</p><p>对比两者，你会发现ESP-01S的应用电路简化了，省掉了两个上拉电阻。</p><p>其实，综上所述，你会发现ESP-01S是官方用来替换ESP-01的。毕竟在选型表里已经给出了建议。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="http://www.mcublog.cn/esp8266/2020_03/esp01-esp01s/">esp01和esp01s的区别</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP01S基础资料收集</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
    <category term="ESP8266-12E/F" scheme="https://zml3589110.github.io/tags/ESP8266-12E-F/"/>
    
  </entry>
  
  <entry>
    <title>小白自制Linux开发板</title>
    <link href="https://zml3589110.github.io/posts/3433483963.html"/>
    <id>https://zml3589110.github.io/posts/3433483963.html</id>
    <published>2025-09-05T12:43:20.000Z</published>
    <updated>2025-09-10T13:10:14.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-瞎抄原理图与乱画PCB"><a href="#一-瞎抄原理图与乱画PCB" class="headerlink" title="一. 瞎抄原理图与乱画PCB"></a>一. 瞎抄原理图与乱画PCB</h1><p>因为墨云是基于高中物理水平的电路知识来学习、而且此前也就玩过树莓派、Esp8266之类的开发板，水平基础趋近于零，所以在写这个系列的时候抱着记录的心态、还望不足之处还望大佬们指正。</p><p>《论语》说：见贤思齐焉。所以现在墨云又开始瞎折腾了</p><p>为啥突然想做嵌入式开发呢，因为看见了下面两位牛人</p><p>【稚晖君】</p><p><a href="https://www.bilibili.com/video/av65365123/">https://www.bilibili.com/video/av65365123/</a></p><p>【在名片上运行的Business Card Linux】</p><p><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/"> https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a></p><p>于是躁动的心开始蠢蠢欲动。</p><p>先定个小目标：</p><p>　　<em>设计一个没啥作用，但是可以运行Linux的小板。</em></p><p>样子大概长这样：</p><p>　　<a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210609081210227-1578860150.png"><img src="/posts/3433483963/483434-20210609081210227-1578860150.png" class="" title="img"></a></p><p> 所以有了初步想法，那开始吧</p><h2 id="1-工具与芯片说明"><a href="#1-工具与芯片说明" class="headerlink" title="1. 工具与芯片说明#"></a>1. 工具与芯片说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#1.-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%8A%AF%E7%89%87%E8%AF%B4%E6%98%8E">#</a></h2><p><strong>立创EDA</strong>：电路图与PCB设计工具，本次硬件部分设计全部使用立创EDA完成</p><p><strong>F1C100s</strong> ：全志的一款基于Arm的小型Soc，自带32MB的内存，其升级版F1C200s为64MB内存，因为其极其便宜(当然最近因为芯片涨价影响)，可以运行Linux，最典型的基于该芯片的荔枝派开发板。</p><p><strong>CH340E</strong>：USB转串口通信芯片，是作为与外界通信的唯一接口 、CH340E个头小、外围电路少，使用简单。</p><p><strong>原理图</strong>：先后参考了(baipiao)了Licheepi Nano、Business LinuxCard、LiShanwenGit(<a href="https://www.oshwhub.com/LSW12315)%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%E5%B9%BF%E5%9C%BA%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%A1%B9%E7%9B%AE">https://www.oshwhub.com/LSW12315)立创开源广场的一系列项目</a></p><h2 id="2-原理图说明"><a href="#2-原理图说明" class="headerlink" title="2.原理图说明#"></a>2.原理图说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#2.%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E">#</a></h2><p> <strong>电源管理</strong></p><p> 电源部分使用USB方式供电，输入电压为5V，这里供电部分和串口电路共用相同USB端口。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100226272-904592004.png"><img src="/posts/3433483963/483434-20210607100226272-904592004.png" class="" title="img"></a></p><p>  通过查询F1c100s数据手册：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100558506-389190797.png"><img src="/posts/3433483963/483434-20210607100558506-389190797.png" class="" title="img"></a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100617030-1539276821.png"><img src="/posts/3433483963/483434-20210607100617030-1539276821.png" class="" title="img"></a></p><p> 通过综合分析，我们可以大概把电源分为4类</p><p>  Vdd-Core：1.1V</p><p>  Vcc-Dram：2.5V</p><p>  AVCC : 3.0V</p><p>  UVCC&#x2F;VCC-IO&#x2F;TV-AVCC&#x2F;TTL：3.3</p><p>  这里主要使用 SY8088AAC 同步降压DC-DC稳压器，为SOT32-5的封装方式，通过使用外围电阻调整输出电压。</p><p>  公式为：</p><p>​      <strong>Vout &#x3D; 0.6 * (&#96;1+Ra&#x2F;Rb)</strong> </p><p>而AVCC使用XC6206P302MR-SOT23的封装方式，输入5V 输出为3.0V</p><p>因为 AVCC为模拟电源电压，为了避免引入电源干扰，通常需要把把模拟电路与数字电路分开隔离开(这个地方解释可能不对，欢迎指正)。</p><p>电源部分的原理图如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075511811-1722536141.png"><img src="/posts/3433483963/483434-20210518075511811-1722536141.png" class="" title="img"></a></p><p>电压输入输出端都使用滤波电容进行处理，使用还要接入2.2uH的功率电感，注意一定要用功率电感，电流要求可以达到1A以及以上的才行</p><p>这个板子使用0805的功率电感，建议最好使用CD32类型的绕线功率电感。</p><p><strong>核心原理图</strong></p><p>对于核心部分的原理图如下，因为本次电路设计主要以验证为主，所以并没有做太多的外设电路。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075644565-3556161.png"><img src="/posts/3433483963/483434-20210518075644565-3556161.png" class="" title="img"></a></p><p>除了常规的核心、外围、DRAM工单引脚，核心部分还引出了</p><p> \1. TF卡引脚，作为本板子唯一的系统加载电路，这是必须的</p><p> 2.晶振，使用规格为24Mhz的有源晶振、加两个15pf的负载电容</p><p> 3.串口调试 作为板子与外界唯一交互的通道，这个也是必须的，然而在做这个成功的给自己挖坑了。</p><p> 4.LED灯，这是这个板子唯一的外设，也是用来学习驱动开发的第一步。</p><p> 5.dram_vref、Var1、Var2 这是必须要接的、外围电路，我也不知道的干啥的 <del>_</del>…</p><p> 6.USB OTG 也是作为一个通信接口来使用，通过这个接口可以为板载Flash下载程序，但是因为本板没有做Flash，所以目前唯一的作用就是放到验证fel是否可以调通。</p><p> 7.复位按钮</p><p><strong>挖坑点</strong></p><p>一直以来认为发光二极管也是二极管，所以就有下面的设计(乱画)，于是后来感觉板子没问题，但是就是串口死活不显示数据、在众多大佬的帮助下，才发现了这个其妙(naocan)</p><p>的接线方法，于是将两个发光二极管位置放了两个0欧的电阻，一下子就成功调通了。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518081301718-1938463553.png"><img src="/posts/3433483963/483434-20210518081301718-1938463553.png" class="" title="img"></a></p><p>对于芯片电源输入端的滤波电容与Dram_vref接线如下：</p><p>对于滤波电容简单的说法就是，对于供电端的电压，因为电路设计或者外界干扰等等，其实不是完美的电压，总会存在高频或是低频的噪声，而用小容量的电容就可以降低这些干扰。</p><p>常规的容值就是 10uf 、1uf、100nf</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075706884-1416748722.png"><img src="/posts/3433483963/483434-20210518075706884-1416748722.png" class="" title="img"></a></p><p><strong>通信电路</strong></p><p>我们在核心原理图中看到了引出的串口线路，而串口的接口如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608075946061-1759039430.png"><img src="/posts/3433483963/483434-20210608075946061-1759039430.png" class="" title="img"></a> <a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608080015029-894589865.png"><img src="/posts/3433483963/483434-20210608080015029-894589865.png" class="" title="img"></a></p><p>显然在你看看你超博的笔记本机身，并没有发现这个接口，偶尔还有一些老的笔记本上面可以看到类似的接口，对不起——那是显示屏的VGA接口。</p><p>那我们如何使用串口传输的信息呢，我们需要一个USB转串口的芯片，usb转串口的芯片很多，这里选择 CH340E 这个型号，因为其很小，接线也方便。</p><p>原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075726899-441537012.png"><img src="/posts/3433483963/483434-20210518075726899-441537012.png" class="" title="img"></a></p><p>前面提到，这个板子共用了电源与TTL共用了一套设计，也就是是说USB线插上就可以启动小板，并且开始进入串口调试。</p><p>原理图中的U5是一个自恢复保险丝。</p><p><em>这里需要注意一下：</em></p><p> 根据CH340E官方的原理图，当VCC接入5V的时候，V3 需要接一个100nf的电容，但是此处在V3直接接入5V，也可以工作。</p><p> 实际使用的时候最好不要这样做。</p><p><strong>TF卡接口</strong></p><p>和电脑主机在BIOS选择启动方式一样， F1C100s 支持多种方式的系统加载机制比如通过SPI接口加载Flash芯片中的镜像，或者通过TF卡接口加载镜像。</p><p>这里使用TF卡作为启动源，这样做是因为</p><p> 1.TF卡容量可以自己控制。</p><p> 2.系统烧写调试方便</p><p>这部分电路相对简单，原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075745633-24558076.png"><img src="/posts/3433483963/483434-20210518075745633-24558076.png" class="" title="img"></a></p><p><strong>OTG 与唯一的外设LED灯</strong></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075809957-1231071962.png"><img src="/posts/3433483963/483434-20210518075809957-1231071962.png" class="" title="img"></a></p><h2 id="3-PCB绘制"><a href="#3-PCB绘制" class="headerlink" title="3.PCB绘制#"></a>3.PCB绘制<a href="https://www.cnblogs.com/twzy/p/14714651.html#3.pcb%E7%BB%98%E5%88%B6">#</a></h2><p> PCB尺寸为42mm*29mm ，可以说非常小了，为了便于焊接，所有容阻都是用0805的封装方式</p><p> 电源走线为14mil ，信号线为8mil</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075900597-2044589685.png"><img src="/posts/3433483963/483434-20210518075900597-2044589685.png" class="" title="img"></a></p><h2 id="4-PCB焊接"><a href="#4-PCB焊接" class="headerlink" title="4.PCB焊接#"></a>4.PCB焊接<a href="https://www.cnblogs.com/twzy/p/14714651.html#4.pcb%E7%84%8A%E6%8E%A5">#</a></h2><p> 焊接PCB是一项手艺活，尤其是QFN方式封装的F1C100s 更是难到发指，还好借助焊台和热风枪，完美的完成了焊接，当然放大镜、洗板水是不可缺少的。</p><p> 并且因为板子时长需要在手上把玩（盘PCB）。所以选择了无铅稀浆进行焊接。</p><p>效果如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080628282-1076112978.png"><img src="/posts/3433483963/483434-20210518080628282-1076112978.png" class="" title="img"></a><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080325298-910819870.png"><img src="/posts/3433483963/483434-20210518080325298-910819870.png" class="" title="img"></a></p><p>成功运行Linux，</p><p>因为还没开始着手做Linux移植，暂时使用LicheePi 的镜像，下一节开始做Linux的移植。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080244837-276955395.png"><img src="/posts/3433483963/483434-20210518080244837-276955395.png" class="" title="img"></a></p><h2 id="5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记"><a href="#5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记" class="headerlink" title="5. 后记[#](https://www.cnblogs.com/twzy/p/14714651.html# 5.-后记)"></a>5. 后记[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 5.-后记)</h2><p>事实上世界上从来没有所谓轻易的成功，对于初次玩PCB的小白更是如此，现在这个小板能成功也是经历三四个月，五六次打板才成功的。以下是早期的趟雷PCB场景与先烈。 (右下角为成功的小板)</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080712817-696267996.png"><img src="/posts/3433483963/483434-20210518080712817-696267996.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080742813-715067385.png"><img src="/posts/3433483963/483434-20210518080742813-715067385.png" class="" title="img"></a></p><h3 id="硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包："><a href="#硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包：" class="headerlink" title="硬件资料包：[#](https://www.cnblogs.com/twzy/p/14714651.html# 硬件资料包：)"></a>硬件资料包：[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 硬件资料包：)</h3><p><a href="https://files.cnblogs.com/files/twzy/LinuxNano%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E5%9B%BE-%E5%A2%A8%E4%BA%91.zip"> 下载</a></p><h1 id="二-u-boot移植"><a href="#二-u-boot移植" class="headerlink" title="二. u-boot移植"></a>二. u-boot移植</h1><p>我们都知道，PC在启动的时候，首先是进入BIOS，再根据BIOS中配置信息引导后续的启动操作系统，比如配置Windows启动。</p><p>而对于嵌入式linux中，并没有BIOS，这时候就需要一种类似引导程序来处理。于是就有了BootLoader。</p><p>BootLoader是一段小程序，可以把它想象成PC机linux上的GRUB&#x2F;LILO引导程序，可以直接从flash或TF卡中运行，来装载内核。它可以初始化硬件设备，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统做好准备。</p><h2 id="1-嵌入式开发板的启动过程"><a href="#1-嵌入式开发板的启动过程" class="headerlink" title="1. 嵌入式开发板的启动过程#"></a>1. 嵌入式开发板的启动过程<a href="https://www.cnblogs.com/twzy/p/14865952.html#1.-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">#</a></h2><p>一个嵌入式系统从软件角度来看分为三个层次：</p><ul><li>引导加载程序</li></ul><p>​      包括固化在芯片中的boot程序（可选）和BootLoader两大部分，对于固化的boot程序。主要是芯片通过外围电路连接的实际情况选择读入程序的位置，比如：通过TF卡或是SPI以及其他方式启动，至于优先顺序这就要具体看芯片的数据手册，个人没做过具体测试。</p><ul><li>linux内核</li></ul><p>​     特定于嵌入式平台的定制内核</p><ul><li>文件系统</li></ul><p>​     包括了系统命令和应用程序</p><table><thead><tr><th>BootLoader</th><th>Boot Parameters</th><th>Kernel</th><th>Root Filesystem</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>BootLoader</strong>启动过程可分为单阶段和多阶段(stage1、stage2),其中stage1完成初始化硬件，如CPU寄存器、内存控制器，为stage2准备内存空间。一般stage1是可以直接在nor flash中运行的，并将stage2复制到内存RAM中，设置堆栈，然后跳转到stage2(从这也可以看出stage2是在RAM中运行的，与stage1不同)</p><p><strong>Boot Parameters</strong> 顾名思义，就是配置了要启动内核的参数，包含要加载系统内核相关文件的位置，要加载到内存中的位置，定位到文件系统的位置，相关输入输出的呈现等一系列参数。</p><p><strong>kernel</strong> 在存放在bootloader之后，对于SoC来说，代码都需要在RAM中运行，这里与MCU不一样的地方就是引入了MMU（内存管理单元）。对于MCU而言，由于其执行速度低，因此运行代码都在ROM中直接运行，而对于Flash而言，其读取速度远不及RAM的速度，因此对于运行速度非常快的SoC而言，所有的代码都需要在RAM中运行。但是这里有一个问题，RAM掉电数据将会丢失，故代码保存不可能放在RAM中，当前所有的嵌入式设备而言，代码保存都是放在ROM中，因此在SoC中运行代码需要将代码搬运到RAM中然后再执行。</p><p><strong>Root Filesystem</strong> 由于其执行过程需要对ROM进行读写操作，因此可以不用搬运到RAM中，但是实际过程中内核启动后会产生一个虚拟的文件系统，该文件系统是挂在根文件系统的关键所在，这里不详细讲解。整体来说，大致的过程为，嵌入式设备上电后将执行bootloader，对硬件进行硬件和堆栈初始化，然后搬运内核到RAM中并启动内核，紧接着挂载根文件系统。</p><h2 id="2-环境配置与参考项目"><a href="#2-环境配置与参考项目" class="headerlink" title="2. 环境配置与参考项目#"></a>2. 环境配置与参考项目<a href="https://www.cnblogs.com/twzy/p/14865952.html#2.-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%8F%82%E8%80%83%E9%A1%B9%E7%9B%AE">#</a></h2><p>系统：Ubuntu 16</p><p>编辑器：VSCode</p><p>参考项目：Lichee-Pi Nano </p><p>地址：<a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080525817-1455821238.png"><img src="/posts/3433483963/483434-20210826080525817-1455821238.png" class="" title="img"></a></p><p>Lichee-Pi Nano</p><p>需要注意的是一定要选择Nano版本，因为我们开发板使用的主控芯片和Nano的主控是一致的，所以后续我们要编译U-boot，内核都可以参考(bai piao)这里面的配置。</p><p>主控芯片：F1c100s&#x2F;F1c200s，100s内置32MB DDR1内存，200s内置64MB DDR1内存，200s贵一点，他们都是QFN88封装。</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右。</p><p>带有100M的SPI接口2个，SDIO接口1个，USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口，I2C I2S UART PWM等等。</p><p>还有就是他们不支持硬件浮点，所以浮点运算使用软浮点方式。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080450826-950498006.png"><img src="/posts/3433483963/483434-20210826080450826-950498006.png" class="" title="img"></a></p><p> F1c100s&#x2F;F1c200s芯片功能</p><h2 id="3-交叉编译器"><a href="#3-交叉编译器" class="headerlink" title="3.交叉编译器#"></a>3.交叉编译器<a href="https://www.cnblogs.com/twzy/p/14865952.html#3.%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8">#</a></h2><p>  我们通过PC版的Linux自带的gcc编译的程序只能在当前系统架构下的cpu架构(x86)下运行，如果我们想要编写的程序在嵌入式Linux下运行，那么就需要用到对应的编译器。</p><p>  我们做的开发板主控芯片F1C200S，内核为ARM9，其架构使用的是ARMv5架构，所以我们也要选用对应的编译器，同样，这样的编译器很多，这里我们使用最常用的arm-linux-gnueabi- ，因为交叉编译器F1C200S必须高于6.0版本，这里我们使用7.2版本</p><p>  <a href="https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz"> 点击下载</a></p><p>  <em>下载较慢时使用下载工具</em></p><p>下载完成后解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><p>然后在&#x2F;usr&#x2F;local目录下新建arm-linux-gcc目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc</span><br></pre></td></tr></table></figure><p>进入解压目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;</span><br></pre></td></tr></table></figure><p>将该目录下的所有文件复制到新建的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rd * &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;</span><br></pre></td></tr></table></figure><p>最后需要添加该工具链的环境变量使其可以在任何目录下执行，打开&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>在文件末尾添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;bin</span><br></pre></td></tr></table></figure><p>添加完毕，使路径生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>接下来在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-</span><br></pre></td></tr></table></figure><p>然后连按两次Tab键，如图在表示成功：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210823161114895-675144161.png"><img src="/posts/3433483963/483434-20210823161114895-675144161.png" class="" title="img"></a></p><p>如果没有出现，则进行下面操作，安装必要的动态链接库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure><p>至此，我们完成了编译工具的配置。</p><h2 id="4-编译U-boot"><a href="#4-编译U-boot" class="headerlink" title="4. 编译U-boot#"></a>4. 编译U-boot<a href="https://www.cnblogs.com/twzy/p/14865952.html#4.-%E7%BC%96%E8%AF%91u-boot">#</a></h2><p> 当Arm开发板上电以后第一个要加载到内存并运行的程序就是**BootLoader，**BootLoader****的同类型程序很多，如U-boot、X-boot、Rt-Thread，这里我们依然选中最常用的U-boot作为目标(因为其他的我也不会呀)，</p><p> 最新版本的uboot几乎包含当前主流的SoC芯片，前面提到本开发板使用的芯片和licheePI nano相同，大部分硬件也是兼容的，为了快速移植该部分，这里采用licheePI nano的u-boot来进行移植。在终端输入如下命令克隆u-boot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Lichee-Pi&#x2F;u-boot.git -b nano-v2018.01</span><br></pre></td></tr></table></figure><p>克隆完毕文件会保存在当前目录下，进入该目录，*<br>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd u-boot</span><br></pre></td></tr></table></figure><p>在该文件夹下有很多分支，我们可以查看所有分支，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>现在我们使用的是nano开发板，所以将当前分支切换到nano分支，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01u-boot</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928150820570-1873390261.png"><img src="/posts/3433483963/483434-20210928150820570-1873390261.png" class="" title="img"></a></p><p> 切换到Nano分支</p><p>默认的没有指定交叉工具链和架构，因此在编译之前需要指定交叉工具链和芯片架构，u-boot的交叉编译器在u-boot 的根目录下中的<strong>Makefile</strong>文件中定义了。打开文件找到<strong>CROSS_COMPILE</strong>变量，修改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH&#x3D;arm</span><br><span class="line">CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151000818-1228538185.png"><img src="/posts/3433483963/483434-20210928151000818-1228538185.png" class="" title="img"></a></p><p> 配制交叉编译环境</p><p>这样我们就能使用我们指定的编译器来编译u-boot了。</p><p>在u-boot项目的config目录下存在对多种板子的配置描述文件，由于每个板子的外设不同，因此编译之前必须要对u-boot进行配置。然而配置是一件比较繁琐的事情，特别是像u-boot这种比较复杂的项目而言，初学者几乎无法完成。幸运的是对于大部分开发板而言，config目录下有其配置好的默认配置文件。进入config目录中，然后执行ls查看当前所有的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151205314-374311839.png"><img src="/posts/3433483963/483434-20210928151205314-374311839.png" class="" title="img"></a></p><p> 查看配制文件</p><p>找到<strong>licheepi_nano_defconfig</strong> 和 <strong>licheepi_nano_spiflash_defconfig</strong>，前者表示为TF卡启动，后者表示从SPI 设备启动，因为我们做的小板只有从TF卡启动，所以我们需要使用 <strong>licheepi_nano_defconfig</strong> 。</p><p>现在回到上级目录，然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>这样我们把<strong>licheepi_nano_defconfig</strong> 作为默认配置项。</p><p>接下来我们就可以用图形界面进行配置了，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时出现图形配置选项，如下图所示</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151406633-1920865408.png"><img src="/posts/3433483963/483434-20210928151406633-1920865408.png" class="" title="img"></a></p><p> u-boot Menuconfig配制，注意红框中的配置，我们后续要用到。</p><p>至此我们的u-boot环境配置就完成了，但是我们还有个问题要解决：<strong>如何让u-boot引导系统</strong></p><p>我们在PC端安装Windows系统的时候往往需要选择启动顺序，比如需要优先通过光驱或u盘启动等。</p><p>同样在u-boot中也需要这样的配置，当然u-boot比PC配置稍微复杂一丢丢。我们前面提到Linux嵌入式系统结构分布中有个Boot Parameters 部分，这部分就是做引导配置的，那怎么配置呢，总体来说可以分为两部分：</p><ol><li>bootcmd，主要用于描述控制Linux内核文件以及其他描述文件加载到内存中位置以及启动Linux内核系统等</li><li>bootargs，用于配制文件系统、串口信息等。</li></ol><p><strong>bootcmd</strong></p><p>在最开始提到过，内核一般不在flash中运行，这样就需要将内核搬运到内存中，这个过程需要u-boot来完成。对于mmc (TF卡)而言，在u-boot有专门的命令<strong>load mmc</strong>，该命令可以将mmc中的代码从flash搬运到指定的地址处。</p><p>当u-boot中环境变量bootdelay计数到0时，此时uboot就会开始执行bootcmd中的命令。</p><p>bootdelay这个环境变量是一个计数器，当u-boot主体运行完毕后，此时bootdelay该变量的值将会开始递减，递减时间为1s，当递减到0时，此时u-boot将会跳转到bootcmd处开始执行bootcmd命令，（你可以简单理解为PC启动后有一两秒时间等待，你可以可以通过F8或Enter键打断进入Bios设置的过程，这个等待时间就由u-boot中的bootdelay来控制）。</p><p>下面我们需要记住这句指令，这就是我们当前制作的开发板需要用到的bootcmd全部内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>如果你需要详细了解这句话那就接着往下看，如果不需要则可以跳到 下面的u-boot参数配置环节</p><p>对于上面命令，我们根据分号拆分为3部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt; load mmc 0:1 0x80008000 zImage;</span><br><span class="line">2&gt; load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;</span><br><span class="line">3&gt; bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>其中两个 load mmc 命令、一个bootz 命令。</p><p>先看第一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage</span><br></pre></td></tr></table></figure><p>load mmc有三个参数：第一个参数是mmc(TF卡)分区，第二个参数是内存中目标地址，第三个参数是源文件。</p><p>即上面的命令意思是<strong>将mmc的0:1 分区中的zImage复制到内存中的0x80008000地址处。</strong>这里的zimage就是Linux内核，后续会提到该文件编译，0:1这个可以这样理解0表示TF卡(TF卡属于mmc存储器的一种)，1这表示TF卡的第一个分区(boot分区)后面会提到。</p><p>而对于内存位置 <strong>0x80008000</strong> 地址位置，将其理解为默认值就行了。这样完成了zImage的加载。</p><p>下面分析第二条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb</span><br></pre></td></tr></table></figure><p>有了上面的加载zImage的说明，可以很轻松的理解上面的命令意思是将mmc的0:1分区中的suniv-f1c100s-licheepi-nano.dtb文件加载到内存中的0x80c08000地址处。对于<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 这个文件，叫做设备树文件，简单来说就是当前开发板上面所有外设备描述文件，这部分将会在后续内核编译部分进行详细说明。</p><p>对于第三条命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz 0x80008000 - 0x80c08000</span><br></pre></td></tr></table></figure><p>的意思是告诉内核镜像的起始地址为0x80008000，加载的设备树地址为0x80c08000。这里是告诉cpu从这里开始启动Linux， bootz命令的格式是：bootz空格0x80008000空格-空格0x80c08000,注意-左右有空格。</p><p>除了bootz 命令外，有些系统里面还可能存在一个叫做bootm命令，这是是对没有使用设备树内核的镜像启动命令，早期版本的内核没有引入设备树，因此对于早期的内核一般使用的是bootm，其命令格式为bootm内核地址，比如bootm x0x30008000，意思是从0x30008000开始启动内核，启动内核的过程其实是将pc指针指向该地址，这样处理器就会从该地址处运行代码。</p><p> 这里我们就完成了bootcmd的说明，接下来我们看另外一个参数。</p><p><strong>bootargs</strong></p><p>bootargs也是u-boot环境变量中一个非常重要的变量，上面已经讲解了内核的启动可以通过bootcmd来完成，那接下来内核启动完毕后必须挂在根文件系统(rootfs)。但是内核并不知道根文件系统的具体位置，我们必须要告诉根文件的位置后内核才能将其挂载，这时就需要有bootargs变量。该变量的作用是告诉内核根文件系统的位置和属性以及必要的配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p>同上面分析的方法一样，我们依然将这部分命令拆成几部分来说明。这里需要说明的是，这部分配置信息是由u-boot 直接按照参数字符串方式提供给Linux内核，然后由Linux内核进行执行的，这也说明里为什么格式与bootcmd配置方式不一致。</p><p><strong>console&#x3D;ttyS0,115200</strong> 表示终端为ttyS0即串口0,波特率为115200；</p><p><strong>panic&#x3D;5</strong> 字面意思是恐慌，即linux内核恐慌，其实就是linux不知道怎么执行了，此时内核就需要做一些相关的处理，这里的5表示超时时间，当Linux卡住5秒后仍未成功就会执行Linux恐慌异常的一些操作。</p><p><strong>rootwait</strong> 该参数是告诉内核挂在文件系统之前需要先加载相关驱动，这样做的目的是防止因mmc驱动还未加载就开始挂载驱动而导致文件系统挂载失败，所以一般bootargs中都要加上这个参数。</p><p><strong>root&#x3D;&#x2F;dev&#x2F;mmcblk0p2</strong> 表示根文件系统的位置在mmc的0:2分区处，**&#x2F;dev<strong>是设备文件夹，内核在加载mmc中的时候就会在根文件系统中生成</strong>mmcblk0p2**设备文件，这个设备文件其实就是mmc的0:2分区(这里对应TF卡的第二个分区：rootfs)，这样内核对文件系统的读写操作方式本质上就是读写&#x2F;dev&#x2F;mmcblk0p2该设备文件。</p><p><strong>earlyprintk</strong> 参数是指在内核加载的过程中打印输出信息，这样内核在加载的时候终端就会输出相应的启动信息。rw表示文件系统的操作属性，此处rw表示可读可写。</p><h2 id="5-u-boot参数配置"><a href="#5-u-boot参数配置" class="headerlink" title="5.u-boot参数配置 #"></a>5.u-boot参数配置 <a href="https://www.cnblogs.com/twzy/p/14865952.html#5.u-boot%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p> 选中  <strong>Enable boot arguments</strong> 按空格选中，下面会显示：() <strong>Boot arguments</strong></p><p>然后选中<strong>Boot arguments</strong> ,按回车，进入配置窗口，接下来上面解释过的<strong>bootargs</strong> 参数信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152101050-1297588046.png"><img src="/posts/3433483963/483434-20210928152101050-1297588046.png" class="" title="img"></a></p><p> 配置bootargs信息</p><p>然后按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><p>同理配置：<strong>Enable a default value for bootcmd</strong> 按空格选中，下面会显示：**() bootcmd value** 配置项，</p><p>选中<strong>bootcmd value</strong> 进入配置界面，输入bootcmd命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152626755-371939279.png"><img src="/posts/3433483963/483434-20210928152626755-371939279.png" class="" title="img"></a></p><p> 配置bootcmd参数</p><p> 按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><h2 id="6-u-boot编译与烧录"><a href="#6-u-boot编译与烧录" class="headerlink" title="6.u-boot编译与烧录#"></a>6.u-boot编译与烧录<a href="https://www.cnblogs.com/twzy/p/14865952.html#6.u-boot%E7%BC%96%E8%AF%91%E4%B8%8E%E7%83%A7%E5%BD%95">#</a></h2><p>先保存图形配置界面后推出界面，在终端执行make -j4即可对整个u-boot进行编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152943605-978425396.png"><img src="/posts/3433483963/483434-20210928152943605-978425396.png" class="" title="img"></a></p><p>编译u-boot</p><p><strong>make -j4</strong>后面的-j4表示4个核心进行编译，若电脑的处理器是2核心，请使用make -j2进行编译。</p><p>编译完成后会在当前目录生成<strong>u-boot-sunxi-with-spl.bin</strong>烧录文件。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928153312700-1418379375.png"><img src="/posts/3433483963/483434-20210928153312700-1418379375.png" class="" title="img"></a></p><p>根目录下找到 <strong>u-boot-sunxi-with-spl.bin</strong> 文件</p><p>该文件就是我们最终要烧录的二进制文件。</p><p>在当前目录下会有一个隐藏的文件.config，该文件是u-boot编译后根据各个选项产生的配置文件，这个配置文件记录了所有配置选项的宏开关，编译的时候是根据最终的.config文件来进行编译的，当然编译前是需要有脚本解析.config文件然后进行相应的编译。</p><p>烧录到TF卡</p><p>只要将u-boot-sunxi-with-spl.bin烧录到tf卡的8k偏移处地址就可以了，烧录步骤如下：使用dd命令进行块搬移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if&#x3D;u-boot-sunxi-with-spl.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</span><br></pre></td></tr></table></figure><p>该命令中：</p><p>​    <strong>if</strong>  文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</p><p>​    <strong>of</strong>  文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</p><p>​    <strong>bs</strong> bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p><p>​    <strong>seek</strong> blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>这里的输出文件(<strong>of</strong>)为主机电脑的&#x2F;dev&#x2F;sdb文件，也就是TF卡，这里也体现了Linux一切皆文件的思想。</p><p><strong>&#x2F;dev&#x2F;sdb</strong> 这个可以用gparted 软件查看，该软件可以直接用命令安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>此时在Ubuntu下面可以看到如下软件：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081032210-139894885.png"><img src="/posts/3433483963/483434-20210930081032210-139894885.png" class="" title="img"></a></p><p>安装好GParted软件</p><p> 打开软件</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081827917-1823480007.png"><img src="/posts/3433483963/483434-20210930081827917-1823480007.png" class="" title="img"></a></p><p>GParted</p><p>在右上角可以看到两个硬盘，&#x2F;dev&#x2F;sda 为本地硬盘，&#x2F;dev&#x2F;sdb 是我们将要写数据的TF(当然这只是墨云自己的配置使然，具体情况请根据实际情况而定)，因此这里的of&#x3D;&#x2F;dev&#x2F;sdb 烧录到8k偏移地址处是指绝对地址，这个绝对地址指的是TF卡的物理地址。这8K的值是由F1C200S 中固化的启动代码决定的，所以照抄即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930082436650-910788822.png"><img src="/posts/3433483963/483434-20210930082436650-910788822.png" class="" title="img"></a></p><p>烧写u-boot</p><p>然后我们正常退出TF卡，然后插入我们自制的开发板，通过USB线连接电脑，</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085606475-1688206025.png"><img src="/posts/3433483963/483434-20210930085606475-1688206025.png" class="" title="img"></a></p><p>连接开发板</p><p>打开电脑中的命令行工具，我这里使用Xshell，</p><p>打开Xshell，新建连接：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084928442-133473812.png"><img src="/posts/3433483963/483434-20210930084928442-133473812.png" class="" title="img"></a></p><p>配置名称 ，协议选择Serial,</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085149724-1946801432.png"><img src="/posts/3433483963/483434-20210930085149724-1946801432.png" class="" title="img"></a></p><p> 配置串口</p><p>通过下拉选中com端口，波特率为115200，其他默认即可，点击确定，然后双击主界面左侧会话管理中的刚建立的会话，此时进入连接状态。</p><p>因为在你插入USB通电的时候开发板就已经启动了，所以当你打开串口连接的时候可能未必会看到信息，所以按一下重启键，就可以看到如下的输出信息了，这就是我们的u-boot，执行到u-bbot计数完成后会产生错误，那是因为我们还没有进行系统内核的移植，所以默认就会进入u-boot命令模式。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084405807-1935485286.png"><img src="/posts/3433483963/483434-20210930084405807-1935485286.png" class="" title="img"></a></p><p> 启动信息</p><p> 输入pri命令打印环境变量的所有值，可以找到已经配置的bootcmd 和bootargs</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930090109593-1345294928.png"><img src="/posts/3433483963/483434-20210930090109593-1345294928.png" class="" title="img"></a></p><p> pri命令结果</p><p>至此完成了u-boot移植的全部内容，对于u-boot的移植方法，在后续移植Linux内核和文件系统时都会用到，都是大同小异的，所以有了本篇的说明，之后操作将会非常简单。</p><p>而关于u-boot的内容事实上非常的复杂繁琐，有兴趣的可以自行去了解到，毕竟作为一个小白的我初衷只是先让小板先跑起来。</p><h2 id=""><a href="#" class="headerlink" title="#"></a><a href="https://www.cnblogs.com/twzy/p/14865952.html#">#</a></h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料#"></a>参考资料<a href="https://www.cnblogs.com/twzy/p/14865952.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a></h2><blockquote><p>Lite200 (lishanwen) – <a href="https://lishanwen.cn/index.php/2021/07/03/lite200/">https://lishanwen.cn/index.php/2021/07/03/lite200/</a></p><p>全志F1C200S F1C100S 介绍 ( 迪卡魏曼依奇君 ) <a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">https://blog.csdn.net/tunqimai9331/article/details/95938903</a></p><p>荔枝派Nano 全流程指南 (矽速科技) <a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p></blockquote><h1 id="三-Linux内核与文件系统移植"><a href="#三-Linux内核与文件系统移植" class="headerlink" title="三. Linux内核与文件系统移植"></a>三. Linux内核与文件系统移植</h1><h2 id="1-Linux内核"><a href="#1-Linux内核" class="headerlink" title="1.Linux内核#"></a>1.Linux内核<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.linux%E5%86%85%E6%A0%B8">#</a></h2><p>事实上对于F1C100S&#x2F;F1C200S，Linux官方源码已经对licheepi nano进行支持。所以我们完全可以通过licheepi nano的配置文件进行移植。</p><h3 id="1-1-下载内核源码"><a href="#1-1-下载内核源码" class="headerlink" title="1.1. 下载内核源码#"></a>1.1. 下载内核源码<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.1.-%E4%B8%8B%E8%BD%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81">#</a></h3><p>进入Linux系统官网：</p><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145110377-1315647665.png"><img src="/posts/3433483963/483434-20210930145110377-1315647665.png" class="" title="img"></a></p><p>这里面列出的都是一些主要版本，如主线版本，上时间支持版本，个人推荐使用最新的长时间支持版本（5.10.69）。但是因为我这个项目是在参考一位大神的文档的基础上构建的，所以使用的是5.7.1版本，接下来就给一个选择其他版本的方式。</p><p>选择任意一项点击 [browse]</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145220044-1573759475.png"><img src="/posts/3433483963/483434-20210930145220044-1573759475.png" class="" title="img"></a></p><p>在新打开页面选择 【summary】点击【tag】中的【…】切换下载</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145316299-265231365.png"><img src="/posts/3433483963/483434-20210930145316299-265231365.png" class="" title="img"></a></p><p> 如果想要直接下载5.7.1版本，请直接使用下面的连接</p><p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz</a></p><p>下载后完成后，将代码复制到Ubuntu虚拟机并解压源码。</p><h3 id="1-2-配置编译"><a href="#1-2-配置编译" class="headerlink" title="1.2.配置编译#"></a>1.2.配置编译<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.2.%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91">#</a></h3><p>与上一篇中编译u-boot一样，我们也需要配置对Linux编译进行配置：</p><ul><li>指定架构类型</li><li>指定交叉编译工具</li><li>项目配置</li></ul><p>指定架构，就这个很好理解，就是指定CPU类型，就是配置为Arm就行，交叉编译工具即为上一篇已经安装好的编译工具。</p><p>用VS打开Linux内核代码，找到<strong>Makefile</strong>文件：</p><p>修改如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH              ?&#x3D; arm</span><br><span class="line">CROSS_COMPILE     ?&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>如果没找到ARCH 或 CROSS_COMPILE字段，自己手动添加也行，如下图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930151530833-1001068341.png"><img src="/posts/3433483963/483434-20210930151530833-1001068341.png" class="" title="img"></a></p><blockquote><p> 事实上这两个字段可以不用指定，在进行make的时候加上对应的参数就行，这里为了避免麻烦，所以直接放到了makefile文件中</p></blockquote><p>接下来就是指定项目配置了，这个操作就是让Linux内核认F1C100S&#x2F;F1C200S这颗soc。</p><p>进入内核源码中的<strong>arch&#x2F;arm&#x2F;configs</strong>目录中，可以看到有很多开发板的配置文件，其中<strong>sunxi_defconfig</strong>是全志的配置文件，但是该配置文件非常不全，需要额外配置大量的选项，一般选项多大上千个，这里先使用licheepi_nano的配置文件。</p><p><a href="https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip"> https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip</a></p><p>下载该文件，解压出<strong>linux-licheepi_nano_defconfig</strong>，然后将其放到arch&#x2F;arm&#x2F;configs&#x2F;目录下</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930154001937-799886630.png"><img src="/posts/3433483963/483434-20210930154001937-799886630.png" class="" title="img"></a></p><p> 然后通过终端进入Linux-5.7.1根目录，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005103913552-1730316057.png"><img src="/posts/3433483963/483434-20211005103913552-1730316057.png" class="" title="img"></a></p><p> 进入图形配置界面，如图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005104057991-2077580949.png"><img src="/posts/3433483963/483434-20211005104057991-2077580949.png" class="" title="img"></a></p><p>该界面和u-boot配置一样，所以操作方式也是一样的，上下键移动选项，使用空格键进行选中或取消选择，同样通过空格键或回车键，进入子选项配置，通过Tab键选择保存和退出即可返回上级菜单或命令行界面，也可以直接双击Esc键返回上级目录。</p><h3 id="1-3-配置TF卡设备树信息"><a href="#1-3-配置TF卡设备树信息" class="headerlink" title="1.3 配置TF卡设备树信息#"></a>1.3 配置TF卡设备树信息<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.3-%E9%85%8D%E7%BD%AEtf%E5%8D%A1%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF">#</a></h3><p>我们在完成内核配置后还需要配置TF卡的设备树配置，否则即便是能正常运行内核，在加载文件系统的时候还是会有问题，在这里配置很简单：</p><p>在<strong>linux-5.7.1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录下，分别修改<strong>suniv-f1c100s.dtsi</strong>、<strong>suniv-f1c100s-licheepi-nano.dts</strong> 两个文件（记住这两个文件、以后我们修改的地方多了^_^）</p><p>修改<strong>suniv-f1c100s.dtsi</strong>文件</p><p>首先添加头文件(如果有则忽略)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>在soc-&gt;pio 下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>soc下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">            interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">            pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">            pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status &#x3D; &quot;disabled&quot;;</span><br><span class="line">            #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">            #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>如图，图中的配置可能与读者实际内容不一致，这是因为我改了很多东西，忽略即可，只需要关注红色框中的内容即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009162310863-1685576565.png"><img src="/posts/3433483963/483434-20211009162310863-1685576565.png" class="" title="img"></a></p><p> 修改<strong>suniv-f1c100s-licheepi-nano.dts</strong>文件，在根节点添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>外部添加mmc0使能代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位置如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202201/483434-20220114080223936-810553130.png"><img src="/posts/3433483963/483434-20220114080223936-810553130.png" class="" title="img"></a></p><p>接下来执行make命令开始编译内核和设备树相关的文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>首次进行编译，通常会需要很长时间，编译完成后，就会在在<strong>arch&#x2F;arm&#x2F;boot</strong>目录下生成内核文件：<strong>zImage</strong>，在<strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong>目录下设备树文件：<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 。</p><p>在编译过程中，因为所配置Ubuntu系统的差异，可能会因缺少某些组件导致编译报错，不要慌，将对应的错误关键信息复制到搜索引擎后安装即可，一下是作者碰到的两个编译报错，如果有必要可以提前安装：</p><p> <strong>linux-内核编译配置 lexer.lex.c错误</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wu@ubuntu:~&#x2F;linux-5.4.8$ make exynos_defconfig</span><br><span class="line">HOSTCC scripts&#x2F;basic&#x2F;fixdep</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;conf.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;confdata.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;expr.o</span><br><span class="line">LEX scripts&#x2F;kconfig&#x2F;lexer.lex.c</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: flex: not found</span><br><span class="line">scripts&#x2F;Makefile.host:9: recipe for target ‘scripts&#x2F;kconfig&#x2F;lexer.lex.c’ failed</span><br><span class="line">make[1]: * [scripts&#x2F;kconfig&#x2F;lexer.lex.c] Error 127</span><br><span class="line">Makefile:567: recipe for target ‘exynos_defconfig’ failed</span><br><span class="line">make: * [exynos_defconfig] Error 2 </span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install flex</span><br></pre></td></tr></table></figure><p><strong>编译Linux内核时遇到：“error : openssl&#x2F;bio.h :No such file or folder”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts&#x2F;extract-cert.c:21:25: fatal error: openssl&#x2F;bio.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts&#x2F;Makefile.host:90: recipe for target &#39;scripts&#x2F;extract-cert&#39; failed</span><br><span class="line">make[1]: * [scripts&#x2F;extract-cert] Error 1</span><br><span class="line">Makefile:556: recipe for target &#39;scripts&#39; failed</span><br><span class="line">make: * [scripts] Error 2</span><br></pre></td></tr></table></figure><p>安装openssl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="1-4-TF分区配置"><a href="#1-4-TF分区配置" class="headerlink" title="1.4 TF分区配置#"></a>1.4 TF分区配置<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.4-tf%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE">#</a></h3><p>在上一篇中提到过u-boot 中的bootcmd 配置了Linux内核文件和设备树文件存放位置，即TF卡的0:1分区中，而且我们已经得到了对应的文件，那我们应该怎么操作呢。</p><p>还记得我们在上一篇中安装的Gparted软件吗，如果不记得，可以通过以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>把需要写入系统的TF卡插到电脑的USB上，打开该软件，可以看到此时有两个存储设备，一个是sda另一个是sdb，其中sdb就是我们的TF卡。如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009080733737-2007833399.png"><img src="/posts/3433483963/483434-20211009080733737-2007833399.png" class="" title="img"></a></p><p>选中sdb，我们可以看到分区表中显示为未分配，对于常规Linux嵌入式系统我们需要分两个区，一个是存放zImage和dtb文件，即在bootcmd中配置的0:1分区，另一个区存放根文件系统。对于第一个分区，格式为fat16格式，因为u-boot只能识别这个格式，对于第二个区，一般为ext4格式，为Linux内核识别的格式。下面开始分区吧。</p><p>选中未分配空间并右击鼠标，点击[新建]，然后填写相关属性，然后点击[添加],所示。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081003602-856502421.png"><img src="/posts/3433483963/483434-20211009081003602-856502421.png" class="" title="img"></a></p><p> 需要注意【之前的空余空间】选择1M，这是给u-boot预留的(u-boot在分区表中是无法看到的)，【新大小】选择32M ，【文件系统】选择fat16，【卷标】输入boot。</p><p>我们这里可以用相同的方式新建第二分区——ext4分区，如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081827144-1948779214.png"><img src="/posts/3433483963/483434-20211009081827144-1948779214.png" class="" title="img"></a></p><p> 这里我们设置为100M，文件系统为ext4，卷标为rootfs，然后添加添加。</p><p>配置好分区表后，点击工具来中的【对钩】使配置的分区表生效。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082014437-279426574.png"><img src="/posts/3433483963/483434-20211009082014437-279426574.png" class="" title="img"></a></p><p>配置分区完毕后，我们就可以在文件管理器中看到挂载的两个分区，如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082321646-1578987260.png"><img src="/posts/3433483963/483434-20211009082321646-1578987260.png" class="" title="img"></a></p><h3 id="1-5-内核复制与执行"><a href="#1-5-内核复制与执行" class="headerlink" title="1.5 内核复制与执行#"></a>1.5 内核复制与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.5-%E5%86%85%E6%A0%B8%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>那么，我们将刚才生成好的zImage和dtb文件复制到TF卡的BOOT分区中</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082706512-1631849134.png"><img src="/posts/3433483963/483434-20211009082706512-1631849134.png" class="" title="img"></a></p><p>退出TF卡，插入开发板，上电，按重启，我们就可以看到u-boot启动完成后，自动进入了内核启动环节，但是启动后一会就报错了，因为挂载文件系统产生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32)</span><br><span class="line">DRAM: 32 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Snail Card</span><br><span class="line">DRAM:  32 MiB</span><br><span class="line">MMC:   SUNXI SD&#x2F;MMC: 0</span><br><span class="line">*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">reading zImage</span><br><span class="line">4515448 bytes read in 231 ms (18.6 MiB&#x2F;s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">6105 bytes read in 26 ms (228.5 KiB&#x2F;s)</span><br><span class="line">## Flattened Device Tree blob at 80c00000</span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ff7d8 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 5.7.1 (twzy@ubuntu) (gcc version 7.2.1 20171011 (Linaro GCC 7.2-2017.11), GNU ld (Linaro_Binutils-2017.11) 2.28.2.20170706) #55 Tue Sep 28 21:04:24 CST 2021</span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr&#x3D;0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: LinuxCard by Kevin</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 8128</span><br><span class="line">[    0.000000] Kernel command line: console&#x3D;tty0 console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2  rw</span><br><span class="line">[    0.000000] Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache hash table entries: 2048 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 21496K&#x2F;32768K available (7168K kernel code, 403K rwdata, 1664K rodata, 1024K init, 246K bss, 11272K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] SLUB: HWalign&#x3D;32, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;1, Nodes&#x3D;1</span><br><span class="line"></span><br><span class="line"> …………………</span><br><span class="line"></span><br><span class="line">[    6.598874] Run &#x2F;etc&#x2F;init as init process</span><br><span class="line">[    6.603993] Run &#x2F;bin&#x2F;init as init process</span><br><span class="line">[    6.609078] Run &#x2F;bin&#x2F;sh as init process</span><br><span class="line">[    6.613763] Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class="line">[    6.629985] CPU: 0 PID: 1 Comm: swapper Not tainted 5.7.1 #55</span><br><span class="line">[    6.636727] Hardware name: Allwinner suniv Family</span><br><span class="line">[    6.642216] [&lt;c010d604&gt;] (unwind_backtrace) from [&lt;c010ab60&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class="line">[    6.651031] [&lt;c010ab60&gt;] (show_stack) from [&lt;c01165a4&gt;] (panic+0xe8&#x2F;0x2e4)</span><br><span class="line">[    6.658951] [&lt;c01165a4&gt;] (panic) from [&lt;c071d080&gt;] (kernel_init+0xd8&#x2F;0x110)</span><br><span class="line">[    6.666960] [&lt;c071d080&gt;] (kernel_init) from [&lt;c0100140&gt;] (ret_from_fork+0x14&#x2F;0x34)</span><br><span class="line">[    6.675547] Exception stack(0xc1835fb0 to 0xc1835ff8)</span><br><span class="line">[    6.681293] 5fa0:                                     00000000 00000000 00000000 00000000</span><br><span class="line">[    6.690714] 5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">[    6.700102] 5fe0: 00000000 00000000 00000000 00000000 00000013 00000000</span><br><span class="line">[    6.707633] Rebooting in 5 seconds..</span><br><span class="line">[   12.687513] Reboot failed -- System halted</span><br></pre></td></tr></table></figure><p>内核移植就基本结束了，要想让小板真正的运行起来，还需要Linux的文件系统，那开始吧。</p><h2 id="2-文件系统移植"><a href="#2-文件系统移植" class="headerlink" title="2.文件系统移植#"></a>2.文件系统移植<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D">#</a></h2><p> 根文件系统(rootfs)是内核启动后挂载的第一个文件系统，如果没有根文件系统，内核将无法开启shell以及其他进程。</p><blockquote><p>实际上内核启动后会先挂载一个虚拟的文件系统，这个虚拟文件系统是在内存中运行的，其主要运行核心进程，虚拟文件系统挂载之后才挂载硬盘（TF卡或者emmc）上的根文件系统。</p></blockquote><p>制作文件系统也有很多方式，如通过busyBox、Buildroot等工具制作。</p><p>本次使用Buildroot，制作过程相对简单，兼容性好，由于根文件系统制作比较简单。</p><p>进入buildroot官网</p><p><a href="https://buildroot.org/downloads">https://buildroot.org/downloads</a></p><p>这里选择buildroot2018.2.11版本，将下载好软件包传入Ubuntu系统中，然后解压并进入源码目录中，输入清理命令。主要用于初始化一些设置，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>然后输入以下命令进入配置界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时会终端进入图形配置界面，如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144509521-972063330.png"><img src="/posts/3433483963/483434-20211009144509521-972063330.png" class="" title="img"></a></p><h3 id="2-1-Target-options配置"><a href="#2-1-Target-options配置" class="headerlink" title="2.1 Target options配置#"></a><strong>2.1 Target options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.1-target-options%E9%85%8D%E7%BD%AE">#</a></h3><p>先选择<strong>Target options</strong>选项，进行对应芯片soc相关的配置，如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144541062-504084831.png"><img src="/posts/3433483963/483434-20211009144541062-504084831.png" class="" title="img"></a></p><p>配置如图所示，下面是对其的解释</p><ul><li>第一个选项为架构选择，这里选择ARM架构小端模式，</li><li>第二个为输出的二进制文件格式，这里选择EFL格式，</li><li>第三个为架构体系，这里选择arm926t，因为F1C200S&#x2F;F1C100S的架构就是这个架构，</li><li>第四个为矢量浮点处理器，这里不勾选，因为对于F1C200S&#x2F;F1C100S而言，其内部没有浮点运算单元，只能进行软浮点运算，也就是模拟浮点预运算。</li><li>第五个为应用程序二进制接口，这里选择EABI，原因是该格式支持软件浮点和硬件实现浮点功能混用。</li><li>第六个为浮点运算规则，这里使用软件浮点</li><li>第七个选择指令集，这里选择ARM指令集，因为thumb主要针对Cortex M系列而言的，对于运行操作系统的A系列以及ARM9和ARM11而言，使用的都是32位的ARM指令集。</li></ul><p>按【Tab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-2-Build-options配置"><a href="#2-2-Build-options配置" class="headerlink" title="2.2 Build options配置#"></a><strong>2.2 Build options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.2-build-options%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第二个<strong>Build options</strong>选项，配置如图</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150105319-120500590.png"><img src="/posts/3433483963/483434-20211009150105319-120500590.png" class="" title="img"></a></p><p>按T【ab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-3-Toolchain配置"><a href="#2-3-Toolchain配置" class="headerlink" title="2.3 Toolchain配置#"></a><strong>2.3 Toolchain配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.3-toolchain%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第三个<strong>Toolchain</strong>选项，配置如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150540766-1755147867.png"><img src="/posts/3433483963/483434-20211009150540766-1755147867.png" class="" title="img"></a></p><p>这里我们选择一些C\C++相关的库，这样我们就可以在开发板上直接编译程序了，保存返回。</p><h3 id="2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置"><a href="#2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置" class="headerlink" title="2.4 System configuration配置[#](https://www.cnblogs.com/twzy/p/15355842.html#2.4 system-configuration配置)"></a><strong>2.4 System configuration配置</strong>[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.4">https://www.cnblogs.com/twzy/p/15355842.html#2.4</a> system-configuration配置)</h3><p>对于<strong>System configuration</strong>选项，这里主要是配置一些系统登录时候显示的内容，配置如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009151624384-1186247221.png"><img src="/posts/3433483963/483434-20211009151624384-1186247221.png" class="" title="img"></a></p><p>这里主要配置了登录时候显示的内容和root账号登录密码，接下来保存配置并且退回到命令行界面。</p><p>然后执行构建文件系统命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>因为是首次编译，而且buildroot在制作文件系统的时候需要联网获取组件，所以会编译很久，那么“去和妲己玩耍吧”</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009153556289-1299034541.png"><img src="/posts/3433483963/483434-20211009153556289-1299034541.png" class="" title="img"></a></p><p>当你终于被别人坑的自闭的时候，文件系统大概也许可能已经编译完毕了。</p><h3 id="2-5-文件系统移植与执行"><a href="#2-5-文件系统移植与执行" class="headerlink" title="2.5 文件系统移植与执行#"></a>2.5 文件系统移植与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>此时在源码的<strong>output&#x2F;images</strong>目录下有一个rootfs.tar，这个文件就是最终生成的根文件系统镜像，现在只需要将该镜像解压到TF卡的第二分区即可。插入TF卡到电脑端，进入<strong>out&#x2F;images</strong>目录，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;&lt;你的用户名&gt;&#x2F;rootfs&#x2F;</span><br><span class="line"># 墨云的账号是twzy</span><br><span class="line">sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;twzy&#x2F;rootfs&#x2F;</span><br></pre></td></tr></table></figure><p>此时可以看到TF卡的rootfs分区中有文件系统了</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172303012-746246639.png"><img src="/posts/3433483963/483434-20211009172303012-746246639.png" class="" title="img"></a></p><p>插入开发板，连接好串口，打开串口助手或者其他串口终端软件，可以看到根文件系统成功挂载，同时进入shell交互，用户名默认为root，密码：123456，进入root账号后</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172655126-653041256.png"><img src="/posts/3433483963/483434-20211009172655126-653041256.png" class="" title="img"></a></p><p>那么恭喜，你已经拥有了自己的Linux发行版。</p><p>至此我们完成了全部的系统移植任务，从下一篇开始我们将会升级我们的硬件设备和做一些更加有意义的东西，期待吗？</p><h3 id="2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格"><a href="#2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格" class="headerlink" title="2.6 升级逼格[#](https://www.cnblogs.com/twzy/p/15355842.html#2.6 升级逼格)"></a>2.6 升级逼格[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.6">https://www.cnblogs.com/twzy/p/15355842.html#2.6</a> 升级逼格)</h3><p>我们发现登录进自制的Linux系统后，命令行前置无论怎样只显示一个**#**号，逼格略低呀，怎么处理呢？</p><p>修改&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1&#x3D;&#39;[\u@\h: \w\a\]$&#39;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172755348-361576513.png"><img src="/posts/3433483963/483434-20211009172755348-361576513.png" class="" title="img"></a></p><p>重启小板，就可以看到与与常规Linux一样的操作体验了，只是root账号的时候还是显示 <strong>$</strong> 符号</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173048942-1924983487.png"><img src="/posts/3433483963/483434-20211009173048942-1924983487.png" class="" title="img"></a></p><p>需要注意的是，在开发板运行过程中，如果想要重启，请先执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><p>命令正常关闭系统后，在按重启按钮，否则有很大概率回造成文件系统损坏。</p><h2 id="3-点个灯吧"><a href="#3-点个灯吧" class="headerlink" title="3. 点个灯吧#"></a>3. 点个灯吧<a href="https://www.cnblogs.com/twzy/p/15355842.html#3.-%E7%82%B9%E4%B8%AA%E7%81%AF%E5%90%A7">#</a></h2><p>还记得我们在第一篇中提到过的我们自制小开发板的唯一的那个外设——LED灯吗？</p><p>那我们就利用Linux提供的GPIO系统通过shell命令进行点灯实验吧。</p><p>我们首先需要回到文件系统制作菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt; </span><br><span class="line">        GPIO Support -&gt;</span><br><span class="line">                &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;… (sysfs interface)。</span><br></pre></td></tr></table></figure><p>按如下方式进行配置，然后编译完rootfs，重新写入小板</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173731029-1575334130.png"><img src="/posts/3433483963/483434-20211009173731029-1575334130.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009163731073-1479927383.png"><img src="/posts/3433483963/483434-20211009163731073-1479927383.png" class="" title="img"></a></p><p>通过硬件可知LED灯连接的是<strong>PE6</strong>接口，低电平亮灯</p><p>这里我们先要了解一下GPIO编号和值的计算方式</p><blockquote><p>引脚编号 &#x3D; 控制引脚的寄存器基数 + 控制引脚寄存器位数<br>批注：<br>引脚编号是gpiochipxxx下的base + 第几个GPIO，也就是base加偏移，偏移的是位数。<br>例如gpiochip34 下的第1个GPIO那么编号就是34 + 1 &#x3D; 35</p></blockquote><p>对于F1C200S&#x2F;F1C100S这里：A&#x3D;0、B&#x3D;1、C&#x3D;2D&#x3D;3、E&#x3D;4 ……、32是固定值、6就是偏移量</p><p>举个栗子（如果使想用 PE6，那么引脚编号就可能等于 4 x 32 + 6 &#x3D; 134。</p><p>这是一些参考命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1、导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line"># 2、设置方向</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 3、查看方向</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 4、设置输出（对于LED 设置1 为高电平即LED灯灭，设置0 为低电平，LED灯亮）</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 5、查看输出值</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 6、取消导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction # 灯亮 （默认设置为高电平）</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯灭 </span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯亮</span><br><span class="line"></span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173632837-1965450968.png"><img src="/posts/3433483963/483434-20211009173632837-1965450968.png" class="" title="img"></a></p><p> 我们这里借助Linux内建的GPIO子系统进行了电灯实验，但是真正Linux灵魂点灯是要通过驱动方式来实现的，但是谁让我是小白呢，以后再说吧。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_7275.html">小白自制Linux开发板(F1C200s)整理系列，持续更新中</a></li><li><a href="https://www.cnblogs.com/twzy/p/14714651.html">瞎抄原理图与乱画PCB</a></li><li><a href="https://www.cnblogs.com/twzy/p/14865952.html"> 二. u-boot移植</a></li><li><a href="https://www.cnblogs.com/twzy/p/15355842.html">三. Linux内核与文件系统移植</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">小白自制Linux开发板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zml3589110.github.io/posts/0.html"/>
    <id>https://zml3589110.github.io/posts/0.html</id>
    <published>2025-09-05T08:43:20.000Z</published>
    <updated>2025-09-10T13:10:14.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C200S一步到位编译法"><a href="#F1C200S一步到位编译法" class="headerlink" title="F1C200S一步到位编译法"></a>F1C200S一步到位编译法</h1><p>兜兜转转还是玩上了MangoPi-R3！因为是ARM9的芯片内核架构，所以总觉得过时了的，至少也要整个ARM-A7的架构芯片。</p><img src="/posts/0/f5689089589dcee6cd852c4468152336.png" class="" title="在这里插入图片描述"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://mangopi.cc/f1c_mainline">https://mangopi.cc/f1c_mainline</a><br><a href="https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780">https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这款微型开发板专为运行 Linux 而设计。尽管机身很小，但它具有所有重要功能。板载F1C200S作为主控芯片，提供多种常用外设端口：GPIO、I2C&amp;SPI、SDIO、Audio port(record,play), Video(RGB565 Display, touch, DVP), USB Host, OTG等. 此外，板卡内置64MB DDR和板载128MB Nand Flash，全面支持Linux生态，运行完整的Python。</p><p>目前该产品是完全开源的，用户可以根据自己的需求编译任意模块。但是，它主要面向 Python 开发人员和高级爱好者，因为它上手有点困难。</p><h3 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h3><table><thead><tr><th>芯片型号</th><th>F1C100S</th><th>F1C200S</th><th>F1C500S</th><th>F1C600</th></tr></thead><tbody><tr><td>内存</td><td>SIP 32MB DDR1</td><td>64MB DDR1</td><td>128MB DDR1</td><td>256MB DDR1</td></tr></tbody></table><ul><li>QFN88封装（10x10mm）</li><li>板载 128MB Nand Flash</li><li>ARM926EJ-S内核，420MHz系统时钟默认频率，可超频至700MHz及以上</li><li>丰富的 GPIO 引脚</li><li>板载 SDIO 接口，用于连接 SD 卡或 SDIO WiFi + BT 模块</li><li>DVP摄像头接口，支持OV2640、GC0328等摄像头。</li><li>RGB565显示接口和6线触摸接口</li><li>板载麦克风和功率放大器</li><li>低功耗</li><li>支持完整的Python运行</li></ul><h3 id="芯片优缺点"><a href="#芯片优缺点" class="headerlink" title="芯片优缺点"></a>芯片优缺点</h3><ul><li>缺点：主频过低，内核太古老（ARM9）</li><li>优点：便宜，内置DDR，资料丰富（老芯片的优势）</li></ul><h3 id="MangoPi的Buildroot一键编译"><a href="#MangoPi的Buildroot一键编译" class="headerlink" title="MangoPi的Buildroot一键编译"></a>MangoPi的Buildroot一键编译</h3><p>地址：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r">https://github.com/mangopi-sbc/buildroot-mangopi-r</a></p><p>安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rsync wget unzip build-essential git bc swig libncurses-dev libpython3-dev libssl-dev</span><br><span class="line">sudo apt install python3-distutils</span><br></pre></td></tr></table></figure><p>下载BSP包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mangopi-sbc/buildroot-mangopi-r</span><br></pre></td></tr></table></figure><h3 id="第一次编译"><a href="#第一次编译" class="headerlink" title="第一次编译"></a>第一次编译</h3><p>注意：构建固件不需要 Root 权限。</p><h3 id="应用默认配置"><a href="#应用默认配置" class="headerlink" title="应用默认配置"></a>应用默认配置</h3><p>注意：应用 defconfig 会将所有 buildroot 配置重置为默认值。</p><p>通常，您只需要应用一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot-mangopi-r</span><br><span class="line">make widora_mangopi_r3_defconfig</span><br></pre></td></tr></table></figure><h3 id="常规编译"><a href="#常规编译" class="headerlink" title="常规编译"></a>常规编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j16</span><br></pre></td></tr></table></figure><h3 id="如果更改了-DTS-或-kenrel-构建"><a href="#如果更改了-DTS-或-kenrel-构建" class="headerlink" title="如果更改了 DTS 或 kenrel 构建"></a>如果更改了 DTS 或 kenrel 构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-kernel.sh</span><br></pre></td></tr></table></figure><h3 id="如果更改了-Uboot，则构建"><a href="#如果更改了-Uboot，则构建" class="headerlink" title="如果更改了 Uboot，则构建"></a>如果更改了 Uboot，则构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-uboot.sh</span><br></pre></td></tr></table></figure><h3 id="加快构建进度"><a href="#加快构建进度" class="headerlink" title="加快构建进度"></a>加快构建进度</h3><p><strong>在百度云下载离线的 dl</strong><br>Buildroot 将在编译固件时下载源代码。您可以获取“dl”文件夹的可信存档以加快速度。 <a href="https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111">https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>没有搞清楚这里是怎么用的，现在是下载了两个包：</p><ul><li>buildroot-dl-20220130.zip</li><li>buildroot-mangopi-r-master.zip<br>是不是把buildroot-dl-20220130.zip解压到buildroot-mangopi-r-master目录里面呢？</li></ul><blockquote><p>明白了，把buildroot-dl-20220130.zip解压出来并改名为dl，然后再把dl移动到buildroot-mangopi-r-master.zip解压出来的文件夹目录里面去就行了，编译的好快 啊。</p></blockquote><p>最终编译完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;u-boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;u-boot-sunxi-with-spl.bin&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;bootfs.vfat&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;rootfs&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;rootfs.ext4&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): writing MBR</span><br><span class="line">board/allwinner/generic/genimage-nor.cfg:33: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.kqghzcncg8<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.kqghzcncg8/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0xa00000@0x600000)</span><br><span class="line">board/allwinner/generic/genimage-nand.cfg:39: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.cjWlxAkEjg<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.cjWlxAkEjg/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0x7700000@0x600000)</span><br><span class="line"></span><br><span class="line">real20m23.669s</span><br><span class="line">user93m8.759s</span><br><span class="line">sys31m2.006s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译出来的文件：buildroot-mangopi-r-master&#x2F;output&#x2F;images</p><p>一步到位，所有版本都编译出来了（牛逼！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootfs.vfat     rootfs.ext4        sysimage-sdcard.img</span><br><span class="line">devicetree.dtb  rootfs.squashfs    u-boot.bin</span><br><span class="line">kernel.itb      rootfs.tar         u-boot-sunxi-with-nand-spl.bin</span><br><span class="line">rootfs.cpio     splash.bmp         u-boot-sunxi-with-spl.bin</span><br><span class="line">rootfs.cpio.gz  sysimage-nand.img  zImage</span><br><span class="line">rootfs.ext2     sysimage-nor.img</span><br></pre></td></tr></table></figure><h3 id="刷固件"><a href="#刷固件" class="headerlink" title="刷固件"></a>刷固件</h3><p>指导说明文档：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md">https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md</a></p><p>Windows下失败了，转战Linux下烧录</p><h2 id="Linux下烧录"><a href="#Linux下烧录" class="headerlink" title="Linux下烧录"></a>Linux下烧录</h2><h3 id="使用sunxi-tools"><a href="#使用sunxi-tools" class="headerlink" title="使用sunxi-tools"></a>使用sunxi-tools</h3><p>sunxi-tools 是全志 SoC（全志科技开发的智能应用处理器 SoC）ARM 设备的命令行工具集合。</p><p>设置和安装 sunxi-tools</p><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-dev libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><p>下载代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>什么是dfu？ 设备固件升级（DFU）是一种独立于分销商和设备的机制，用于通过其制造商提供的改进版本来升级USB设备的固件，从而提供（例如）一种部署固件错误的方法修复。在固件升级操作过程中，USB 设备将有效地改变其工作模式，从而成为 PROM 编程器。按照官方 DFU 规范，任何类型的 USB 设备都可以实现此功能。DFU 还允许用户自由使用备份固件来刷新 USB 设备。结果之一是刷新的 USB 设备可以充当多种设备类型。</p><p>什么是 dfu-util？ dfu-util 是一个实现 USB DFU（通用串行总线设备固件升级）协议的主机 (PC) 程序。DFU 会将固件下载到通过 USB 连接的设备，或从设备下载固件。其应用范围从微控制器板等小型设备到手机设备。使用 dfu-util，您可以从支持 DFU 的设备下载&#x2F;上传固件。</p><p>通过 apt-get 安装 dfu-util</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dfu-util</span><br></pre></td></tr></table></figure><h3 id="安装putty"><a href="#安装putty" class="headerlink" title="安装putty"></a>安装putty</h3><p>putty 是一个 Telnet、SSH 和串口连接软件。</p><p>安装串口工具putty</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install putty</span><br></pre></td></tr></table></figure><p>打开串口调试软件putty</p><p>默认安装的情况下，putty被添加到&#x2F;usr&#x2F;bin目录下，所以可以直接在终端使用putty命令打开。</p><p>在ubuntu上找串口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ dmesg | grep tty</span><br><span class="line">[    0.004000] console [tty0] enabled</span><br><span class="line">[    1.247164] 00:05: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A</span><br><span class="line">[25931.988675] usb 2-2.2: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>由此可知，板子的串口是ttyUSB0</p><p>一般串口的名字在dev下，如果没有外接串口卡，默认是dev。</p><p>使用命令<code>ls /dev/ttyUSB0</code>查看是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ ls /dev/ttyUSB0</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>如果结果存在，则串口地址为&#x2F;dev&#x2F;ttyUSB0</p><p>在putty中填入串口，然后打开串口格式化</p><p>序列号：填写对应的序列号<br>速度：填写115200</p><img src="/posts/0/f788e924e13b4e0c9512ea233e08c6d4.png" class="" title="在这里插入图片描述"><blockquote><p>打开有问题时记得加<code>sudo putty</code></p></blockquote><h3 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h3><p>putty打开以后，就进入固件位置:<br>同时按下tiny200的开机键和rst键，然后松开</p><p>此时运行.\fel-uboot.sh脚本</p><img src="/posts/0/1e5e0df7bf4da9879602649309c9e1ef.png" class="" title="在这里插入图片描述"><p>putty里面就有打印数据了</p><p>然后等待操作完成后，在putty里面输入命令：mtd erase spi-nand0，格式化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U-Boot SPL 2020.07 (Feb 16 2022 - 01:28:19 +0000)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from FEL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2020.07 (Feb 16 2022 - 01:28:19 +0000) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Allwinner F1C100s Generic Device</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   mmc@1c0f000: 0, mmc@1c10000: 1</span><br><span class="line">Setting up a 800x480 lcd console (overscan 0x0)</span><br><span class="line">In:    serial</span><br><span class="line">Out:   vga</span><br><span class="line">Err:   vga</span><br><span class="line">Allwinner mUSB OTG (Peripheral)</span><br><span class="line">Hit any key to stop autoboot:  0</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">unrecognized JEDEC id bytes: ff, c8, 51</span><br><span class="line">Failed to initialize SPI flash at 0:0 (error -2)</span><br><span class="line">List of MTD devices:</span><br><span class="line">* spi-nand0</span><br><span class="line">  - device: spi-nand@1</span><br><span class="line">  - parent: spi@1c05000</span><br><span class="line">  - driver: spi_nand</span><br><span class="line">  - <span class="built_in">type</span>: NAND flash</span><br><span class="line">  - block size: 0x20000 bytes</span><br><span class="line">  - min I/O: 0x800 bytes</span><br><span class="line">  - OOB size: 128 bytes</span><br><span class="line">  - OOB available: 4 bytes</span><br><span class="line">  - 0x000000000000-0x000008000000 : <span class="string">&quot;spi-nand0&quot;</span></span><br><span class="line">=========================</span><br><span class="line">Boot Device: fel</span><br><span class="line">Boot Slot 0: empty</span><br><span class="line">Boot Slot 1: spi-nand</span><br><span class="line">=========================</span><br><span class="line">Booting from FEL...</span><br><span class="line">DFU waiting on SPI-NAND...</span><br><span class="line">musb-hdrc: peripheral reset irq lost!</span><br><span class="line">=&gt; mtd erase spi-nand0</span><br><span class="line">Erasing 0x00000000 ... 0x07ffffff (1024 eraseblock(s))</span><br><span class="line">=&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加文件权限<br>使用ll命令查看文件权限。</p><p>如果文件没有执行权限，则需要添加权限，通过以下命令添加权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x fel-uboot.sh</span><br><span class="line">chmod +x dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><h3 id="开始烧录"><a href="#开始烧录" class="headerlink" title="开始烧录"></a>开始烧录</h3><p>输入固件文件夹</p><p>按下开发板子上的 boot 按钮和 rst 按钮，然后松开rst按钮并运行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./fel-uboot.sh &amp;&amp; ./dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><p>开始烧录啦，挺壮观的！</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_28877125/article/details/123143116">mangopi R3–Allwinner F1C200S一步到位编译法</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Allwinner F1C200S一步到位编译法</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/categories/mangopi-R3/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/tags/mangopi-R3/"/>
    
  </entry>
  
  <entry>
    <title>全志f1c200s开发板设计</title>
    <link href="https://zml3589110.github.io/posts/3905997731.html"/>
    <id>https://zml3589110.github.io/posts/3905997731.html</id>
    <published>2025-09-05T07:15:20.000Z</published>
    <updated>2025-09-10T13:10:14.199Z</updated>
    
    <content type="html"><![CDATA[<p>开发板如图所示，模仿树莓派取了一个mango-pi的名字，haha~。<br>硬件主要参考了荔枝派nano和正点原子开发板。经过测试，全部功能正常。</p><img src="/posts/3905997731/985ac40194d0411885bbe6b33a72921a.jpeg" class="" title="请添加图片描述"><img src="/posts/3905997731/2a533be2bf2d1a5be799288c43c75be5.png" class="" title="在这里插入图片描述"><h2 id="芯片特征"><a href="#芯片特征" class="headerlink" title="芯片特征"></a>芯片特征</h2><ol><li>全志F1C200s与F1C100s的区别为F1C200s含有64M SIP RAM，而F1C100s只有32M SIP RAM。F1C200s支持1080p视频解码，F1C100s仅支持720p。</li><li>ARM9架构</li><li>主频 408MHz</li><li><strong>内置RAM简化设计</strong></li><li>支持从spi flash和SD卡启动</li></ol><img src="/posts/3905997731/f26481d46f8a51926a9cab2683435852.png" class="" title="在这里插入图片描述"><h2 id="开发板包含资源"><a href="#开发板包含资源" class="headerlink" title="开发板包含资源"></a>开发板包含资源</h2><ol><li>SD卡*1</li><li>SPI FLASH*1</li><li>调试串口通过type-C引出</li><li>USB-A接口*2</li><li>OTG*1</li><li>按键*2</li><li>调试RGB led*1</li><li>支持正点原子40p RGB屏幕接口和触摸屏IIC接口</li><li>引出串口1路。</li></ol><p>PCB和原理图：<br><strong>链接：<a href="https://pan.baidu.com/s/1M2AIeIsibin_yUDbtMdzwA">https://pan.baidu.com/s/1M2AIeIsibin_yUDbtMdzwA</a><br>提取码：e0xq</strong></p><p>(下载至 全志&#x2F;mango-pi下)</p><h1 id="mangopi自制linux开发板驱动适配进度"><a href="#mangopi自制linux开发板驱动适配进度" class="headerlink" title="mangopi自制linux开发板驱动适配进度"></a>mangopi自制linux开发板驱动适配进度</h1><h2 id="目前进度"><a href="#目前进度" class="headerlink" title="目前进度"></a>目前进度</h2><p>目前自制的mangopi设备驱动适配已完成部分包含：</p><ul><li>基于扫描的gpio-keys子系统适配</li><li>LED子系统适配</li><li>RGB接口LCD显示屏适配</li><li>ft5406触摸屏适配</li><li>博通RTL8188EUS无线网卡适配</li><li>PWM驱动适配</li><li>显示屏背光适配</li></ul><hr><p>以下这几项在下载到荔枝派源码时已经适配好了：</p><ul><li>SPI FLASH驱动</li><li>USB驱动</li><li>串口驱动</li></ul><img src="/posts/3905997731/985ac40194d0411885bbe6b33a72921a.jpeg" class="" title="请添加图片描述"><hr><p>mangopi内核代码和uboot代码是基于licheepi nano修改的。<br>mangopi有哪些外设资源可以看：<a href="https://blog.csdn.net/qq_27350133/article/details/124107951">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></p><p>内核源码：<strong><a href="https://github.com/LiangtaoZhong/linux-mangopi-kernel5.2">https://github.com/LiangtaoZhong/linux-mangopi-kernel5.2</a></strong><br>uboot源码：<strong><a href="https://github.com/LiangtaoZhong/uboot-mangopi">https://github.com/LiangtaoZhong/uboot-mangopi</a></strong></p><h2 id="过程记录博客"><a href="#过程记录博客" class="headerlink" title="过程记录博客"></a>过程记录博客</h2><ol><li><a href="https://blog.csdn.net/qq_27350133/article/details/124107951?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124181468?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】使用genimage工具制作img系统镜像</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124246500?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】Linux板卡刷写img镜像后对分区进行扩容&#x2F;调整分区大小</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124261591?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】不带中断引脚采用扫描的方式实现通用gpio-keys</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124560457?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】系统运行期间替换内核镜像和设备树</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124602894?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】RGB接口 LCD驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124619357?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】PWM驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124800980?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】屏幕背光驱动适配</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124974526?spm=1001.2014.3001.5501">【f1c200s&#x2F;f1c100s】FT5426触摸屏适配</a></li></ol><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_27350133/article/details/124107951">【f1c200s&#x2F;f1c100s】全志f1c200s开发板设计（含原理图和PCB）</a></li><li><a href="https://blog.csdn.net/qq_27350133/article/details/124687320">mangopi自制linux开发板驱动适配进度</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志f1c200s开发板设计</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>学习笔记F1C100S之u-boot编译过程记录</title>
    <link href="https://zml3589110.github.io/posts/2357015472.html"/>
    <id>https://zml3589110.github.io/posts/2357015472.html</id>
    <published>2025-09-05T07:15:20.000Z</published>
    <updated>2025-09-10T13:10:14.215Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通-自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就-高手勿喷高手勿喷高手勿喷"><a href="#本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通-自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就-高手勿喷高手勿喷高手勿喷" class="headerlink" title="本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通 :) 自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就~ 高手勿喷高手勿喷高手勿喷~~~"></a><strong>本人纯属软件文盲，linux更文盲，本身做硬件设计的，对软件一窍不通 :) 自从掉到咱们论坛这个大坑后，翻贴无数，在此做一下记录，尽量多配截图，以方便后面的新手少走弯路，快速体验编译成功的小成就~ 高手勿喷高手勿喷高手勿喷~~~</strong></h5><p>由于是学习，所以采用了虚拟机安装ubuntu的方式，比较耐折腾，安装好后复制出来备份，需要重新安装系统的时候替换出来就可以了~<br>1、具体虚拟机安装ubuntu的过程在此不详细记录了，百度一堆一堆的。建议安装的时候断网，免得安装过程中下载插件。<br>2、安装好系统后，第一步先更新一下apt-get，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><p>备注：快速打开命令行的快捷键是Ctrl+Alt+t</p><img src="/posts/2357015472/apt-get.jpg" class="" title="更新apt-get"><p>3、紧着接安装git工具，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/git%E5%B7%A5%E5%85%B7.jpg" class="" title="安装git工具"><p>4、获取编译工具，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir f1c100s</span><br><span class="line">cd f1c100s</span><br></pre></td></tr></table></figure><p>以上是先建立了一个f1c100s的目录，然后进入f1c100s。也可以省去此步骤、没有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;releases.linaro.org&#x2F;components&#x2F;toolchain&#x2F;binaries&#x2F;7.2-2017.11&#x2F;arm-linux-gnueabi&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/none.jpg" class="" title="获取编译工具"><p>5、此时技巧来了，再次按Ctrl+Alt+t新建一个命令行窗口，拽取u-boot源码，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir uboot</span><br><span class="line">cd uboot</span><br></pre></td></tr></table></figure><p>当然上面两行诗创建uboot目录和进入uboot目录的命令，可以省去，没有影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Lichee-Pi&#x2F;u-boot.git</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/u-boot%E6%BA%90%E7%A0%811.jpg" class="" title="拽取u-boot源码1"><p>这时等待拽取源码或者获取编译工具结束，静静的等待 ·-· 。。。<br>6、其实我们还可以做点别的<br>根据坛友们的经验，尤其是晕哥的<a href="https://whycan.cn/t_3019.html">全志开发资料精华汇总, 持续更新 (<strong><strong><strong>请大家继续补充</strong></strong></strong>**)</a>LinjieGuo的<a href="https://whycan.cn/t_3138.html">尝试从零构建F1C100s开发环境</a></p><p>需要补充安装下面这些包，具体命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br><span class="line">sudo apt-get install device-tree-compiler</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install swig python-dev python3-dev</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/libncurses5-dev.jpg" class="" title="libncurses5-dev"><img src="/posts/2357015472/device-tree-compiler.jpg" class="" title="device-tree-compiler"><p>7、待获取编译环境的命令行窗口获取完毕后，安装vim编辑器，不装用vi也可以，具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure><p>我也搞不清楚什么时候用apt install什么时候用apt-get install，好像喵过一眼是说这是两个组合命令，get是获取，apt是安装，不作数，我这里糊涂着呢~<br>另外，不管你开了多少个命令行，貌似只能有一个apt-get运行，如果有运行中的apt-get再运行会报错。</p><img src="/posts/2357015472/vim.jpg" class="" title="vim"><p>有关vim编辑器的使用自行百度补脑，不细说了~百度有很多。<br>8、解压编译环境，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxJf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/tar.jpg" class="" title="tar"><p>9、拷贝编译环境到&#x2F;opt&#x2F;目录，也就是平常说的安装，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r .&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi &#x2F;opt&#x2F;</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/cp.jpg" class="" title="cp"><p>10、配置编译环境，添加path环境变量，具体方法是用vim打开&#x2F;etc&#x2F;目录下面的bash.bashrc，在末尾添加<br>PATH&#x3D;”$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin”，这一行，具体操作是运行sudo vim &#x2F;etc&#x2F;bash.bashrc命令<br>然后按光标向下按键移动显示内容到最后面一行，再按光标向右键，移动到行尾，这时按“i”键，转化为插入模式。输入PATH&#x3D;”$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin”输入完后按ESC键，甭管显示什么，输入：wq保存退出即可。还是如前面提到的，具体怎么使用请百度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;bash.bashrc</span><br></pre></td></tr></table></figure><p>这里少截了一个图，借用后面更新source &#x2F;etc&#x2F;bash.bashrc命令的图吧~</p><img src="/posts/2357015472/bash.jpg" class="" title="bash"><p>添加的内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;&quot;$PATH:&#x2F;opt&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin&quot;</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/path.jpg" alt="path"><br><img src="https://whycan.cn/files/members/2412/wq.jpg" alt="wq"><br>最后运行更新命令，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;bash.bashrc</span><br></pre></td></tr></table></figure><img src="/posts/2357015472/bash.jpg" class="" title="bash"><p>小试一下gcc是否正常，使用gcc显示版本号的方式测试安装是否正常，出来一堆，反正我看不懂~~~<br>命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -v</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/gcc.jpg" alt="gcc"><br>自此整个编译环境获取、配置完毕。嗷嗷嗷，忘记说了，觉得有必要提醒一下，<br>从步骤7开始，都是在最开始打开的那个窗口或者说是步骤4哪里的那个窗口才可以完成的。<br>也许在其他窗口执行会有问题。</p><p>11、关闭所有的命令行窗口，按Ctrl+Alt+t重新打开一个窗口（因为之前分开三个窗口操作，为了节省时间），<br>命令行窗口之间操作的内容比如安装了XX，是不会过度到操作窗口以外的，除非是后面新打开的命令行窗口，不严谨的描述~高手勿喷！<br>正题：进入uboot目录，在进入u-boot目录，反正最终你找的u-boot目录，进去就OK了，运行git branch -a查看分支。具体命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd uboot</span><br><span class="line">cd u-boot</span><br><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/gitbranch.jpg" alt="gitbranch"><br>选择nano-v2018.01分支，命令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/nano2018.jpg" alt="nano2018"></p><p>12、开始编译咯，运行命令make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_spiflash_defconfig指定配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_spiflash_defconfig</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/makearch1.jpg" alt="makearch1.jpg"><br>可视化配置，具体怎么配置坛内或者百度搜吧，我也不造~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm menuconfig</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/menuconfig.png" alt="menuconfig"></p><p>正式开始编译，运行命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j1</span><br></pre></td></tr></table></figure><p><img src="https://whycan.cn/files/members/2412/make_ok.png" alt="make_ok"><br>顺利编译<br><img src="https://whycan.cn/files/members/2412/makels.png" alt="makels"><br>其中末尾的J1是因为我电脑配置低，只分配给了虚拟机一个处理器，只有一个核心，可根据具体实际情况更改，核心数量越多编译越快。四核就是J4，J8都是土豪~~~~~</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_3269.html">学习笔记F1C100S之u-boot编译过程记录</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">学习笔记F1C100S之u-boot编译过程记录</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="uboot" scheme="https://zml3589110.github.io/tags/uboot/"/>
    
  </entry>
  
  <entry>
    <title>LTspice仿真基本使用</title>
    <link href="https://zml3589110.github.io/posts/3987226932.html"/>
    <id>https://zml3589110.github.io/posts/3987226932.html</id>
    <published>2025-08-11T06:04:20.000Z</published>
    <updated>2025-09-10T13:10:14.230Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容摘自:<a href="https://zhuanlan.zhihu.com/p/57983635">https://zhuanlan.zhihu.com/p/57983635</a> 给电路初学者的 LTspice操作入门教程 Step by Step Student @IC Design李瑄</p><p>因为要用到LT的电源芯片，设计时出现错误，回过头才发现，有一堆软件可以供我使用。</p><p>SPICE仿真器核心 是给电路设计者的“计算器”。功能是 求解非线性微分方程组（电路方程）。(这个计算器利用了电路网络所通常具备的稀疏等特性做过求解速度上的优化)</p><p>SPICE仿真器通常会附加的各种 waveform viewer工具，是送给电路设计者的“理想”（带宽、信噪比、负载效应、存储深度都堪称完美）示波器、频谱仪等，来将SPICE的输出结果给人直观地展示出来，还带各种高级后处理功能。</p><p>用久了你可能会发现，手工分析电路所用到的各种激励假设、端接条件、分析方法，在SPICE中大都提供有相应的理想 .Elements &amp; .Analysis Commands；用SPICE的作用之一是当你有了分析电路的思路后，可用SPICE求解器来替你计算来完成验证、设计迭代的过程。</p><p>当然，这个”计算器”要想用好，你得输入一个足够接近物理实现的电路模型给SPICE：需要你足够全面得考虑到物理世界元件的各种作用关系（比如注意到各种RC寄生、热效应），并且将这些物理量作用关系描述得足够准确（选择|编写足够准确的模型）。</p><p>这都需要你有足够多在物理世界中上手测试过的电路调试经验作积累，你就能知道需要考虑哪些效应，你才能借助SPICE工具，准确地验证你的猜想。</p><h1 id="LTspice电路图用户界面说明"><a href="#LTspice电路图用户界面说明" class="headerlink" title="LTspice电路图用户界面说明"></a>LTspice电路图用户界面说明</h1><img src="/posts/3987226932/231ecae21c25fd52548eeccd7fe77c12.jpeg" class="" title="img"><p>另：在软件中可以多处试试右键菜单，看看可用的操作。</p><p>更多快捷键操作，可打印查看 <a href="https://link.zhihu.com/?target=https://www.analog.com/cn/license/spice-models?mediaPath=media/en/simulation-models/spice-models/LTspice_ShortcutFlyerC.pdf&modelType=spice-models">LTspice 信息单张和快捷键</a></p><img src="/posts/3987226932/eff90292233f7ba3379bf2b54f64d011.jpeg" class="" title="img"><p>LTspice快捷键表_Windows</p><p>部分计算机建议把键盘设置为 FN lock（取消 FN键默认多媒体功能）</p><h2 id="2-编辑电路图-schematic"><a href="#2-编辑电路图-schematic" class="headerlink" title="2-编辑电路图(schematic)"></a>2-编辑电路图(schematic)</h2><p>(提示: 在电路图编辑界面: Zoom to Fit(空格键)可缩放窗格至合适大小; 鼠标滚轮缩放)</p><p><strong>2-1 添加元器件</strong></p><p><strong>2-1-1 Edit-&gt;Resistor (或快捷键 <code>R</code>) 放置电阻；</strong></p><p>（MacOSX上无 <code>R</code>快捷键，只能用 Component(<code>F2</code>)库里搜索 res等来调用元件）</p><p><strong>2-1-2 Edit-&gt;Diode (或快捷键 <code>D</code>) 放置二极管：</strong></p><p>Ctrl+R旋转放置方向，Ctrl+E镜像放置方向</p><p>放置后可用 <code>F5</code>删除元件; <code>F6</code>复制元件; <code>F7</code>挪动元件; <code>F8</code>粘连挪动; <code>F9</code>撤销操作; (详见 Menu&gt;Edit 和 <a href="https://link.zhihu.com/?target=https://www.analog.com/cn/license/spice-models?mediaPath=media/en/simulation-models/spice-models/LTspice_ShortcutFlyerC.pdf&modelType=spice-models">LTspice快捷键表</a>.pdf)</p><p><strong>2-1-3 Edit-&gt;Place GND (或快捷键 <code>G</code>) 放置GND；</strong></p><p>SPICE<strong>计算</strong>需要给出0V参考点(即<strong>GND</strong>)；若有悬浮网络会导致SPICE不可解。</p><p><strong>2-1-4 若需要放置菜单栏中无快捷操作的元器件,需调出元件(Component)符号(Symbol)库:</strong></p><img src="/posts/3987226932/70c717a64d68c7dc868bf60d628a9eed.png" class="" title="img"><p><strong>2-1-5 从元件库中检索 voltage(电压源)元件，并放置：</strong></p><img src="/posts/3987226932/3959bbeea7849ce36ca150b2cffe8376.png" class="" title="img"><p>注：有调用快捷键的 电阻(res) 电容(cap) 等 亦可以直接从此<strong>默认元件库</strong>里选取。</p><p><strong>2-2 用导线绘制元件连接关系</strong></p><p><strong>2-2-1 Edit-&gt;Draw wire (或快捷键 <code>F3</code>) 绘制导线：</strong></p><img src="/posts/3987226932/30dda93c8c219d22abf243141df8c069.png" class="" title="img"><p><strong>2-2-2 对导线(电压节点 Node)命名(Label Net)：</strong></p><img src="/posts/3987226932/39d2a80139d2f2198b6fcb3f5ac4fb52.png" class="" title="img"><p>注：同名节点在电路拓扑上是同一节点（&#x3D;短路）。</p><p><strong>2-3 编辑元件参数</strong></p><p><strong>2-3-1 右键点击 (Right-Mouse-Botton,下文简称 <code>RMB</code>,(左键简称 <code>LMB</code>)) 电阻 Symbol:</strong></p><p>如电阻值3.3k (也可写成3.3e3)：</p><img src="/posts/3987226932/1bb3c7c1a2c6b7b0be780507eb73f8f7.png" class="" title="img"><p>物理单位(Ohm, F, H等)加不加均可；</p><p>数量单位见 Help-&gt;LTspice®-&gt;Introduction-&gt;General… 说明：(备注：LTSPICE不区分大小写，故) <strong>注意：兆 1e6可写作 Meg，而不能写作 M</strong>（&#x3D;m, 毫）</p><p><strong>2-3-2 <code>RMB</code> 编辑 Diode 选型</strong></p><img src="/posts/3987226932/b6b575cee3cc583fcef9a5dca6ce0d16.png" class="" title="img"><p>选择常见 高速小信号二极管 1N4148 （或大电流管 1N5819）</p><img src="/posts/3987226932/99dcd8fb94fad4c82c4559b6ed463fd0.png" class="" title="img"><p>(可在选型窗口内查看其性能参数及 SPICE模型)</p><p><strong>2-3-3 <code>RMB</code> 编辑 voltage作正弦信号源</strong></p><p>(再点进voltage元件的 <strong>Advanced菜单</strong>后：)</p><img src="/posts/3987226932/3a30b1e261c0c168cf683730e4f1681c.png" class="" title="img"><p><strong>2-4 <code>Ctrl+S</code> 保存电路图；</strong></p><hr><h3 id="3-设置仿真参数"><a href="#3-设置仿真参数" class="headerlink" title="3-设置仿真参数"></a><strong>3-设置仿真参数</strong></h3><p><strong>3-1 调出仿真(SPCIE .)命令配置向导</strong></p><img src="/posts/3987226932/856e10fcd3ea972832c23d28254c4480.png" class="" title="img"><p><strong>3-2 配置时域（.tran ）仿真选项</strong></p><p>（注：DC Sweep扫描分析可后续自行探索）</p><img src="/posts/3987226932/b8939a554ee1b3e7533760455002f038.jpeg" class="" title="img"><p>确定后鼠标上挂着一行 SPICE命令，<strong>记得</strong>挪到合适的位置<strong>单击放置</strong>在电路图中</p><img src="/posts/3987226932/66394caa0acd1ac3d1dff0bad856d62d.png" class="" title="img"><p>也可 <code>S</code>快捷键直接编辑<strong>SPICE命令</strong>贴入电路图中；</p><ul><li>编辑器里: (右键)<strong><code>RMB</code>&gt;Help me edit&gt;Analysis Cmd</strong> 可调出写常用SPICE命令的各辅助向导</li><li>MacOS版若未有GUI向导，则只能手动写CLI的仿真控制命令，可参考 Help文档中语法，和 examples中例</li></ul><p>注意 <code>T</code>快捷键贴入的是 Comment注释文本，对仿真无作用；</p><p><strong>3-3 <code>Ctrl+S</code> 保存；</strong></p><p><strong>3-4 对此电路图(Schematic)用 LTspice®仿真求解</strong></p><img src="/posts/3987226932/5b37212329a362f5499770411892002f.jpeg" class="" title="img"><p>（运行仿真后，LTspice关闭前可在工作目录下 自行打开 netlist文件(*.net后缀)查看<strong>网表</strong>（可用LTspice打开查看编辑，或 VS Code编辑器的 SPICE语法加亮插件编辑 等））</p><p>（仿真计算后会在当前路径下输出同名 *.raw波形数据文件）</p><h3 id="4-查看-raw仿真输出结果"><a href="#4-查看-raw仿真输出结果" class="headerlink" title="4-查看 .raw仿真输出结果"></a><strong>4-查看 .raw仿真输出结果</strong></h3><p>（多窗口排列方式设置：见 Menu&gt;Window&gt;Tile Vertically 等选项）</p><p>（可参考 Help-&gt;Waveform Viewer文档说明）</p><p><strong>4-1 LTspice选择绘制波形</strong></p><p><strong>4-1-1 选择输入节点 V(Vsin)的电压波形数据绘制：</strong></p><img src="/posts/3987226932/bae89a9ec51f86718aff95e2ff72cd9c.png" class="" title="img"><p><strong>4-1-2 用鼠标保持单击 Vsin导线并拖动至 输出Vrec节点以绘制 V(Vsin,Vrec)差分电压</strong></p><img src="/posts/3987226932/94899755a0570387c8c631f38b5e72be.png" class="" title="img"><p><strong>4-1-3 单击二极管：plot流过二极管端口的电流</strong></p><img src="/posts/3987226932/68baafe8e3d2a2aa39dbc3a741062163.png" class="" title="img"><p>把鼠标放置在元件端口上，鼠标显示为&amp;amp;amp;quot;电流探头&amp;amp;amp;quot;</p><p>把鼠标放置在元件上，鼠标显示为”电流探头”</p><img src="/posts/3987226932/8ff920fcb3bd48b8c82cab074316a3ae.png" class="" title="img"><p>输出波形电流波形，及右纵轴标尺</p><img src="/posts/3987226932/cb17b128d0bcd265bfc50682748b5f42.png" class="" title="img"><p>若需绘制导线电流：<code>Alt+左键单击(LMB)导线</code></p><p>若需电流取反，参考 <em>4-2-2（右键单击编辑波形后处理表达式）</em>编辑为 -I(D1)</p><p><strong>4-1-4 多窗口查看绘制波形</strong></p><img src="/posts/3987226932/30b121508d7bfbc5711fbc5a5ccedd32.jpeg" class="" title="img"><p><strong>4-2 .raw查看器的波形后处理</strong></p><p>（注意：在波形查看器中：**<code>Ctrl+E</code> 恢复 full缩放**）（而非 <code>空格键</code>）</p><p>（提示：缩放中 <strong><code>Ctrl+Y</code>可恢复 Y轴方向的 AutoRange</strong>，且横坐标范围不变）</p><p><strong>4-2-0 波形缩放查看</strong></p><img src="/posts/3987226932/cf30b551cd9ce7e74f335f7606966f4e.jpeg" class="" title="img"><p>(注意: 在波形查看器中: (Menu&gt;View&gt;Zoom to Fit)<strong><code>Ctrl+E</code> 恢复 full缩放</strong>, 而非 <code>空格</code>)</p><p>（提示：缩放中 <strong><code>Ctrl+Y</code>可恢复 Y轴方向的 AutoRange</strong>，且横坐标范围不变）</p><p><strong>4-2-1 左键单击用 Cursor测量波形数据点</strong></p><img src="/posts/3987226932/50969172777b884b6429faa5a267c341.png" class="" title="img"><p><strong>4-2-2 右键单击编辑波形后处理表达式</strong></p><img src="/posts/3987226932/f100b4ba2e2b2e558717b9e035199455.png" class="" title="img"><ul><li>参数表达式亦可通过 *1A &#x2F;1V等操作来改变量纲；</li></ul><p>支持的数学函数详见 <strong>软件帮助</strong> <em>Help&gt;Waveform Viewer&gt;Waverform Arithmetic表格</em></p><h4 id="也可以直接在波形查看器中-右键-gt-Add-trace，添加波形绘制表达式；"><a href="#也可以直接在波形查看器中-右键-gt-Add-trace，添加波形绘制表达式；" class="headerlink" title="也可以直接在波形查看器中 右键-&gt; Add trace，添加波形绘制表达式；"></a>也可以直接在波形查看器中 右键-&gt; Add trace，添加波形绘制表达式；</h4><ul><li>也可在此处看到此次仿真的所有原始输出量。</li></ul><p><strong>4-2-3 窗口范围内波形计算均值及有效值</strong></p><img src="/posts/3987226932/75e4deccda6075d3713362b644aa7487.png" class="" title="img"><p><strong>4-2-4 波形查看器技巧：自变量选择：从时间函数替换成轨迹图 X-Y plot：</strong></p><img src="/posts/3987226932/dfa5e6b88c6ef7ecdef5a050b11b3040.png" class="" title="img"><hr><blockquote><p><strong>说明：本文是收集参考网络文档，以方便查看（侵删）</strong></p></blockquote><hr><h1 id="信息链接"><a href="#信息链接" class="headerlink" title="信息链接:"></a>信息链接:</h1><ol><li><a href="https://blog.csdn.net/qq_25144391/article/details/109693681">LTspice - 基础操作2</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">LTspice仿真基本使用</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="硬件" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E7%A1%AC%E4%BB%B6/"/>
    
    <category term="LTspice" scheme="https://zml3589110.github.io/categories/LTspice/"/>
    
    
    <category term="LTspice" scheme="https://zml3589110.github.io/tags/LTspice/"/>
    
    <category term="仿真" scheme="https://zml3589110.github.io/tags/%E4%BB%BF%E7%9C%9F/"/>
    
    <category term="硬件" scheme="https://zml3589110.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何判断IGBT或者MOS的好坏</title>
    <link href="https://zml3589110.github.io/posts/3813959588.html"/>
    <id>https://zml3589110.github.io/posts/3813959588.html</id>
    <published>2025-08-07T01:21:20.000Z</published>
    <updated>2025-09-10T13:10:14.168Z</updated>
    
    <content type="html"><![CDATA[<p>对于新入行电机控制的小伙伴，尤其新手调试没什么经验，拿到控制器往往坏了都不知道。</p><p>尤其高压的项目，有的小伙伴在二手平台买的控制器，却无法判断控制器，尤其逆变部分是不是好的，容易被坑。</p><p>那么新手，缺乏调试经验，如何判断控制器的逆变器好坏呢？</p><p>初步判断，需要一块万用表。</p><p>一般是在<strong>不通电</strong>的情况下进行检测。</p><img src="/posts/3813959588/MBXY-CR-2da7a4d74ea8eed922ce0b89cd2150b8.png" class="" title="img"><p>如上图，比如一台变频器，整流部分用二极管，逆变器部分用IGBT。</p><p>无论是整流器还是逆变器，都有反并联二极管，所以</p><p>第一步：</p><p>用万用表的二极管档，以DC+作为二极管阳极，R&#x2F;S&#x2F;T&#x2F;U&#x2F;V&#x2F;W分别作为二极管的阴极，即可测试6个<strong>下桥</strong>二极管是否正常。如压降在0.5~0.7V左右即正常，短路或者开路即异常。</p><p>第二步：</p><p>用万用表的二极管档，以DC-作为二极管阴极，R&#x2F;S&#x2F;T&#x2F;U&#x2F;V&#x2F;W分别作为二极管的阳极，即可测试6个<strong>上桥</strong>二极管是否正常。如压降在0.5~0.7V左右即正常，短路或者开路即异常。</p><p>第三步：</p><p>万用表调整为欧姆档，用万用表测试6个IGBT的gs之间的阻抗，三相上桥或者下桥，三相的gs之间阻抗应该是kohm级别以上，三相值差不多，不能短路或者不均衡，否则IGBT损坏。</p><p>第四步：</p><p>万用表调整为欧姆档，用万用表测试6个IGBT的ds之间的阻抗，三相上桥或者下桥，三相的ds之间阻抗应该是kohm级别以上，三相值差不多，不能短路或者不均衡，否则IGBT损坏。</p><p>注意：</p><p>如果用万用表二极管档，测量二极管的反向压降，应该显示不断变化的电压或者无穷大。</p><p>因为二极管此时反向截止，因为结电容的存在，所以万用表注入的电流流过结电容，对电容充电，会测出变化的反向压降，大约1.5V左右，逐步增大到显示.0L V，这是正常现象。</p><p>反向压降不能是0.5~0.7V，或者短路，都是异常的。</p><p>至此，完成了对IGBT逆变器的初步检测。</p><p>至于低压驱动器，不存在整流桥，而MOSFET逆变器的检测和IGBT一致。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.eet-china.com/mp/a427161.html">如何判断IGBT或者MOS的好坏)</a></li><li><a href="https://mp.weixin.qq.com/s/ag6Xdn20EfSQi3yp1jqAGw">IGBT或者MOS的好坏</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">如何判断IGBT或者MOS的好坏</summary>
    
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/categories/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="IGBT" scheme="https://zml3589110.github.io/categories/IGBT/"/>
    
    
    <category term="电磁炉" scheme="https://zml3589110.github.io/tags/%E7%94%B5%E7%A3%81%E7%82%89/"/>
    
    <category term="IGBT" scheme="https://zml3589110.github.io/tags/IGBT/"/>
    
    <category term="万用表" scheme="https://zml3589110.github.io/tags/%E4%B8%87%E7%94%A8%E8%A1%A8/"/>
    
    <category term="电机" scheme="https://zml3589110.github.io/tags/%E7%94%B5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>C奇偶校验方法</title>
    <link href="https://zml3589110.github.io/posts/2418004517.html"/>
    <id>https://zml3589110.github.io/posts/2418004517.html</id>
    <published>2025-08-07T00:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux源码奇偶校验方法"><a href="#linux源码奇偶校验方法" class="headerlink" title="linux源码奇偶校验方法"></a>linux源码奇偶校验方法</h1><p>求8位奇偶校验<br><strong>Linux函数方法：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parity8</span><span class="params">(u8 val)</span></span></span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><strong>一、循环遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(val)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (val&amp; <span class="number">0x1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    parity = !parity;</span><br><span class="line">  &#125;</span><br><span class="line">  data &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二、异或操作</strong></p><p>回忆一下，相异为1，相同为0。</p><p> 看，如果我们只针对2个bit，是不是可以对异或操作的定义换一个说法，偶数个1为0，奇数个1为1，所以针对2个bit来说，异或操作就是求奇偶校验。</p><p>  举个例子。</p><p>  0B00，偶数个1，两比特相异为0.</p><p>  0B01，0B10，奇数个1，两比特相异为1.</p><p>  0B11，偶数个1，两比特相异为0.</p><p>就8bit而言。</p><p>我们只需要像下面这样，即每次折叠一下，上下2个bit对齐求异或。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val ^= val &gt;&gt; <span class="number">4</span>;</span><br><span class="line">val ^= val &gt;&gt; <span class="number">2</span>;</span><br><span class="line">val ^= val &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们通过位运算实现了类似并行的操作。</p><p><strong>三、Linux函数方法</strong></p><p><strong>函数原型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parity8</span><span class="params">(u8 val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * One explanation of this algorithm:</span></span><br><span class="line"><span class="comment"> * https://funloop.org/codex/problem/parity/README.html</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">val ^= val &gt;&gt; <span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0x6996</span> &gt;&gt; (val &amp; <span class="number">0xf</span>)) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯？0x6996是个啥？嗯，看懂了很简单也很惊艳</p><p>val在经过一次折叠异或之后，其取值是0-15。</p><p>然后奇偶校验的返回值不是0就是1。所以如果这个时候我们查表只需要2个字节即可。</p><p>嗯，是的，0x6996即是0B0110100110010110。</p><p>它的对应位置的bit，正好是0-15对应的奇偶返回值，所以我们直接移位查表即可。</p><p>压缩到极致的位表</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://mp.weixin.qq.com/s/FoC5sSGMO-rNyVFbG9bG-g">Linux源码中的位运算技巧之计算奇偶校验</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">C常用奇偶校验方法</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="C" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/C/"/>
    
    <category term="奇偶校验" scheme="https://zml3589110.github.io/categories/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/"/>
    
    
    <category term="C" scheme="https://zml3589110.github.io/tags/C/"/>
    
    <category term="数据结构" scheme="https://zml3589110.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="奇偶校验" scheme="https://zml3589110.github.io/tags/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Python Vue Electron 构建桌面应用</title>
    <link href="https://zml3589110.github.io/posts/1490818296.html"/>
    <id>https://zml3589110.github.io/posts/1490818296.html</id>
    <published>2025-08-07T00:29:20.000Z</published>
    <updated>2025-09-10T13:10:14.324Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过Electron技术 + python 构建桌面应用实际上非常麻烦，需要使用python构成后端并打包，然后使用Vue作为前端，还要用Electron打包。<br>但是好处就是可以同时得到来自前端UI框架的高颜值支持以及python海量轮子的快速实现（以及较为完善的多端部署功能），项目可以快速扩展成全平台应用。<br>所以我在这个博客里记录了Python + Vue Electron 构建桌面应用的方法。<br>(其实单纯使用node.js进行开发可能会更快，毕竟不用写后端api，但是python的社区有很多超级方便的库，可以节约大量的时间，比较起来还是写api来得节省时间)</p><h1 id="Step-1-新建Vue项目"><a href="#Step-1-新建Vue项目" class="headerlink" title="Step 1. 新建Vue项目"></a>Step 1. 新建Vue项目</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-electron-app</span><br></pre></td></tr></table></figure><h1 id="Step-2-选择一个UI框架"><a href="#Step-2-选择一个UI框架" class="headerlink" title="Step 2. 选择一个UI框架"></a>Step 2. 选择一个UI框架</h1><p><a href="https://www.naiveui.com/zh-CN/dark">Naive UI</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -D naive-ui</span><br><span class="line">npm i -D vfonts</span><br></pre></td></tr></table></figure><p>为了方便，全局引入UI组件，在main.js 中添加<br><code>import naive from &#39;naive-ui&#39;</code><br><code>createApp(App).use(naive).use(store).use(router).mount(&#39;#app&#39;)</code></p><h1 id="Step-3-安装-electron-builder"><a href="#Step-3-安装-electron-builder" class="headerlink" title="Step 3. 安装 electron-builder"></a>Step 3. 安装 electron-builder</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue add electron-builder</span><br></pre></td></tr></table></figure><p>安装成功后package.json中多了几个命令</p><img src="/posts/1490818296/2322533-20220712164131897-586632426.png" class="" title="image"><p>运行<code>npm run electron:serve</code></p><img src="/posts/1490818296/2322533-20220712164114888-1374706448.png" class="" title="image"><p>到这里就基本完成前端部分的环境设置,后续只需要像开发web应用一样写api就行了</p><h1 id="Step-4-创建后端项目-作者使用-FastAPI-作为Python后端框架"><a href="#Step-4-创建后端项目-作者使用-FastAPI-作为Python后端框架" class="headerlink" title="Step 4. 创建后端项目,作者使用 FastAPI 作为Python后端框架"></a>Step 4. 创建后端项目,作者使用 <a href="https://fastapi.tiangolo.com/">FastAPI</a> 作为Python后端框架</h1><p>安装fastapi及其依赖项<br><code>pip install fastapi[all] pyinstaller</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> This_config</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">root</span>():</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;message&quot;</span>: <span class="string">&quot;Hello World&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    logging.basicConfig(filename=<span class="string">&#x27;log.log&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, level=logging.INFO, <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">&quot;Now start service&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        uvicorn.run(<span class="string">&quot;main:app&quot;</span>, host=<span class="string">&quot;localhost&quot;</span>, port=This_config[<span class="string">&#x27;port&#x27;</span>], log_level=<span class="string">&quot;info&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br></pre></td></tr></table></figure><p>下面的命令用于pyinstaller打包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --uac-admin -w main.py --distpath W:\YoutubeProject\frontend\vue-electron-app\dist_electron\win-unpacked\backend_dist --hidden-<span class="keyword">import</span>=main</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>--hidden-import=main</code> 不能省略，否则服务器无法启动。</p><h1 id="Step-5-配置前后端联合启动"><a href="#Step-5-配置前后端联合启动" class="headerlink" title="Step 5. 配置前后端联合启动"></a>Step 5. 配置前后端联合启动</h1><p>因为是桌面端软件，在前端Electron打包，后端pyinstaller打包之后，需要在启动前端的Electron .exe文件时，也同时启动pyinstaller打包的后端exe文件，这就需要在前端代码中写入命令行以唤起后端的exe，并在退出时关闭后端exe。<br>首先安装node-cmd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add node-cmd</span><br></pre></td></tr></table></figure><p>然后在管理electron生命周期的<em>项目名</em>.js 文件中，完成以下代码以唤起和关闭后端exe</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; app, protocol, BrowserWindow &#125; <span class="keyword">from</span> <span class="string">&#x27;electron&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createProtocol &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-cli-plugin-electron-builder/lib&#x27;</span></span><br><span class="line"><span class="keyword">import</span> installExtension, &#123; VUEJS3_DEVTOOLS &#125; <span class="keyword">from</span> <span class="string">&#x27;electron-devtools-installer&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cmd=<span class="built_in">require</span>(<span class="string">&#x27;node-cmd&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取程序的根目录地址</span></span><br><span class="line"><span class="keyword">var</span> currentPath = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>).dirname(<span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>).app.getPath(<span class="string">&quot;exe&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isDevelopment = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Scheme must be registered before the app is ready</span></span><br><span class="line">protocol.registerSchemesAsPrivileged([</span><br><span class="line">  &#123; <span class="attr">scheme</span>: <span class="string">&#x27;app&#x27;</span>, <span class="attr">privileges</span>: &#123; <span class="attr">secure</span>: <span class="literal">true</span>, <span class="attr">standard</span>: <span class="literal">true</span> &#125; &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">createWindow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Create the browser window.</span></span><br><span class="line">  <span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    width: <span class="number">800</span>,</span><br><span class="line">    height: <span class="number">600</span>,</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// Use pluginOptions.nodeIntegration, leave this alone</span></span><br><span class="line">      <span class="comment">// See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info</span></span><br><span class="line">      nodeIntegration: process.env.ELECTRON_NODE_INTEGRATION,</span><br><span class="line">      contextIsolation: !process.env.ELECTRON_NODE_INTEGRATION</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.WEBPACK_DEV_SERVER_URL) &#123;</span><br><span class="line">    <span class="comment">// Load the url of the dev server if in development mode</span></span><br><span class="line">    <span class="keyword">await</span> win.loadURL(process.env.WEBPACK_DEV_SERVER_URL)</span><br><span class="line">    <span class="keyword">if</span> (!process.env.IS_TEST) win.webContents.openDevTools()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    createProtocol(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">    <span class="comment">// Load the index.html when not in development</span></span><br><span class="line">    win.loadURL(<span class="string">&#x27;app://./index.html&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quit when all windows are closed.</span></span><br><span class="line">app.on(<span class="string">&#x27;window-all-closed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// On macOS it is common for applications and their menu bar</span></span><br><span class="line">  <span class="comment">// to stay active until the user quits explicitly with Cmd + Q</span></span><br><span class="line">  <span class="keyword">if</span> (process.platform !== <span class="string">&#x27;darwin&#x27;</span>) &#123;</span><br><span class="line">    app.quit()</span><br><span class="line">    cmd.run(<span class="string">`taskkill /F /im main.exe`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.on(<span class="string">&#x27;activate&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// On macOS it&#x27;s common to re-create a window in the app when the</span></span><br><span class="line">  <span class="comment">// dock icon is clicked and there are no other windows open.</span></span><br><span class="line">  <span class="keyword">if</span> (BrowserWindow.getAllWindows().length === <span class="number">0</span>) createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method will be called when Electron has finished</span></span><br><span class="line"><span class="comment">// initialization and is ready to create browser windows.</span></span><br><span class="line"><span class="comment">// Some APIs can only be used after this event occurs.</span></span><br><span class="line">app.on(<span class="string">&#x27;ready&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDevelopment &amp;&amp; !process.env.IS_TEST) &#123;</span><br><span class="line">    <span class="comment">// Install Vue Devtools</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> installExtension(VUEJS3_DEVTOOLS)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">&#x27;Vue Devtools failed to install:&#x27;</span>, e.toString())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;now start service&quot;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;currentPath&#125;</span>/backend_dist/main/main.exe`</span>)</span><br><span class="line">  <span class="comment">// 启动服务器exe</span></span><br><span class="line">  cmd.run(<span class="string">`<span class="subst">$&#123;currentPath&#125;</span>/backend_dist/main/main.exe`</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, data, stderr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="built_in">console</span>.log(stderr)</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  createWindow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exit cleanly on request from parent process in development mode.</span></span><br><span class="line"><span class="keyword">if</span> (isDevelopment) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.platform === <span class="string">&#x27;win32&#x27;</span>) &#123;</span><br><span class="line">    process.on(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (data === <span class="string">&#x27;graceful-exit&#x27;</span>) &#123;</span><br><span class="line">        app.quit()</span><br><span class="line">        <span class="comment">// 关闭服务器exe</span></span><br><span class="line">        cmd.run(<span class="string">`taskkill /F /im main.exe`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    process.on(<span class="string">&#x27;SIGTERM&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      app.quit()</span><br><span class="line">      cmd.run(<span class="string">`taskkill /F /im main.exe`</span>)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是后端pyinstaller打包的程序需要安装到指定的目录中：<code>$&#123;currentPath&#125;/backend_dist/main/main.exe</code><br>这里项目中使用的后端端口是5003，但是在实际生产环境中端口有可能被占用，所以有必要在开发时将后端最终运行的端口号记录在数据库里</p><p><strong>最终达到的效果就是启动前端exe时，后端进程同时打开，关闭前端exe时，后端exe也同时关闭</strong></p><img src="/posts/1490818296/2322533-20220713154736382-1799585233.png" class="" title="image"><h1 id="Step-6-配置跨域CORS"><a href="#Step-6-配置跨域CORS" class="headerlink" title="Step 6. 配置跨域CORS"></a>Step 6. 配置跨域CORS</h1><p>由于浏览器默认禁止跨域通信，为了让工作在不同端口上的服务可以互相通信，需要配置CORS，最简单的办法就是禁用掉CORS，<br>参考:<a href="https://pratikpc.medium.com/bypassing-cors-with-electron-ab7eaf331605">https://pratikpc.medium.com/bypassing-cors-with-electron-ab7eaf331605</a></p><p>在 <code>项目名.js</code> 文件中写入以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> win = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    webPreferences: &#123;</span><br><span class="line">        webSecurity: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在就可以通过api通信让前端js调用后端的python api了。</p><p>到目前为止，一个前后端全栈的Electron桌面应用的功能就已经基本实现了。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/SongLink/p/16472239.html">Python + Vue Electron 构建桌面应用</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Python Vue Electron 构建桌面应用并打包</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="前端" scheme="https://zml3589110.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Python" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/Python/"/>
    
    <category term="Electron" scheme="https://zml3589110.github.io/categories/Electron/"/>
    
    
    <category term="VUE" scheme="https://zml3589110.github.io/tags/VUE/"/>
    
    <category term="Python" scheme="https://zml3589110.github.io/tags/Python/"/>
    
    <category term="桌面端应用" scheme="https://zml3589110.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    
    <category term="pyinstaller" scheme="https://zml3589110.github.io/tags/pyinstaller/"/>
    
    <category term="Electron" scheme="https://zml3589110.github.io/tags/Electron/"/>
    
  </entry>
  
  <entry>
    <title>Python将Vue项目打包成桌面端应用程序的方法</title>
    <link href="https://zml3589110.github.io/posts/3154352287.html"/>
    <id>https://zml3589110.github.io/posts/3154352287.html</id>
    <published>2025-08-07T00:05:20.000Z</published>
    <updated>2025-09-10T13:10:14.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用pywebview方法打包"><a href="#使用pywebview方法打包" class="headerlink" title="使用pywebview方法打包"></a>使用pywebview方法打包</h1><p>在不使用 Electron 的情况下，怎么将前端项目（Vue&#x2F;React）变成一个桌面端 exe 应用程序呢？使用 pywebview + pyinstaller 就可以实现。本文详细介绍如何从零开始创建一个基于 pywebview 的桌面应用，并最终将其打包成独立的可执行文件（exe）。整个过程包括环境搭建、前端集成、Python 交互实现以及打包部署。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pywebview pyinstaller</span><br></pre></td></tr></table></figure><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_app/</span><br><span class="line">├── web_dist/      # 前端资源目录（Vue/React打包结果）</span><br><span class="line">│   └── dist/</span><br><span class="line">│       ├── index.html</span><br><span class="line">│       ├── style.css</span><br><span class="line">│       └── app.js</span><br><span class="line">├── main.py        # 主程序</span><br><span class="line">└── topackage.py   # 打包脚本</span><br></pre></td></tr></table></figure><img src="/posts/3154352287/034ef7a1e9fb329e439fc258ff855713.png" class="" title="img"><h2 id="主程序开发-main-py"><a href="#主程序开发-main-py" class="headerlink" title="主程序开发 (main.py)"></a>主程序开发 (main.py)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webview</span><br><span class="line"><span class="keyword">from</span> webview <span class="keyword">import</span> screens</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Api</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.cancel_heavy_stuff_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    screen = screens[<span class="number">0</span>]</span><br><span class="line">    width = screen.width</span><br><span class="line">    height = screen.height</span><br><span class="line">    api = Api()</span><br><span class="line"></span><br><span class="line">    webview.settings = &#123;</span><br><span class="line">        <span class="string">&#x27;OPEN_DEVTOOLS_IN_DEBUG&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    window = webview.create_window(</span><br><span class="line">        <span class="string">&#x27;我的应用&#x27;</span>, <span class="string">&#x27;./web_dist/dist/index.html&#x27;</span>, fullscreen=<span class="literal">False</span>, width=<span class="built_in">int</span>(width), height=<span class="built_in">int</span>(height))</span><br><span class="line">    webview.start(http_server=<span class="literal">False</span>, debug=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打包脚本-topackage-py"><a href="#打包脚本-topackage-py" class="headerlink" title="打包脚本 (topackage.py)"></a>打包脚本 (topackage.py)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">package_app</span>():</span></span><br><span class="line">    <span class="comment"># 1. 检查必要文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Path(<span class="string">&quot;main.py&quot;</span>).exists():</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">&quot;主程序 main.py 不存在&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> Path(<span class="string">&quot;web_dist/dist/index.html&quot;</span>).exists():</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">&quot;前端资源 web_dist/dist/index.html 不存在&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 安装 PyInstaller（如果未安装）</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">import</span> PyInstaller</span><br><span class="line">    <span class="keyword">except</span> ImportError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在安装 PyInstaller...&quot;</span>)</span><br><span class="line">        subprocess.check_call([<span class="string">&quot;pip&quot;</span>, <span class="string">&quot;install&quot;</span>, <span class="string">&quot;pyinstaller&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 清理旧构建文件</span></span><br><span class="line">    build_dir = Path(<span class="string">&quot;build&quot;</span>)</span><br><span class="line">    dist_dir = Path(<span class="string">&quot;dist&quot;</span>)</span><br><span class="line">    spec_file = Path(<span class="string">&quot;main.spec&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> [build_dir, dist_dir, spec_file]:</span><br><span class="line">        <span class="keyword">if</span> path.exists():</span><br><span class="line">            <span class="keyword">if</span> path.is_dir():</span><br><span class="line">                shutil.rmtree(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                path.unlink()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4. 执行打包命令</span></span><br><span class="line">    cmd = [</span><br><span class="line">        <span class="string">&quot;pyinstaller&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--onefile&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--windowed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--add-data&quot;</span>, <span class="string">&quot;web_dist/dist;web_dist/dist&quot;</span>,  <span class="comment"># Windows 用分号分隔</span></span><br><span class="line">        <span class="string">&quot;--name&quot;</span>, <span class="string">&quot;MyWebViewApp&quot;</span>,</span><br><span class="line">        <span class="string">&quot;main.py&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始打包...&quot;</span>)</span><br><span class="line">    subprocess.check_call(cmd)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 验证结果</span></span><br><span class="line">    exe_path = dist_dir / <span class="string">&quot;MyWebViewApp.exe&quot;</span></span><br><span class="line">    <span class="keyword">if</span> exe_path.exists():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n 打包成功！可执行文件位置: <span class="subst">&#123;exe_path.resolve()&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;注意：目标计算机需要安装 WebView2 Runtime&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;打包失败，请检查错误信息&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    package_app()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="打包与运行"><a href="#打包与运行" class="headerlink" title="打包与运行"></a>打包与运行</h2><p>执行打包脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python topackage.py</span><br></pre></td></tr></table></figure><img src="/posts/3154352287/b7ea181e7d611331d5314a8f0e4c0f38.png" class="" title="img"><p>双击<strong>MyWebViewApp.exe</strong></p><img src="/posts/3154352287/df52963ec44e8b10e389fa40d961db8b.png" class="" title="img"><p>通过 pywebview（<strong>轻量级、使用系统原生 WebView 组件、Python 和 JavaScript 无缝交互</strong>），可以轻松创建桌面应用。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_52814911/article/details/149962039">Python是怎么将Vue项目打包成桌面端应用程序的？看这篇就够了</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Python使用pywebview+pyinstaller将Vue项目打包成桌面端应用程序</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="前端" scheme="https://zml3589110.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Python" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/Python/"/>
    
    <category term="pywebview" scheme="https://zml3589110.github.io/categories/pywebview/"/>
    
    <category term="pyinstaller" scheme="https://zml3589110.github.io/categories/pyinstaller/"/>
    
    
    <category term="VUE" scheme="https://zml3589110.github.io/tags/VUE/"/>
    
    <category term="Python" scheme="https://zml3589110.github.io/tags/Python/"/>
    
    <category term="桌面端应用" scheme="https://zml3589110.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    
    <category term="pywebview" scheme="https://zml3589110.github.io/tags/pywebview/"/>
    
    <category term="pyinstaller" scheme="https://zml3589110.github.io/tags/pyinstaller/"/>
    
  </entry>
  
</feed>
