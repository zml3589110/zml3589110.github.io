<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赵逸尘个人博客</title>
  
  <subtitle>记录工作生活</subtitle>
  <link href="https://zml3589110.github.io/atom.xml" rel="self"/>
  
  <link href="https://zml3589110.github.io/"/>
  <updated>2025-09-19T08:24:03.338Z</updated>
  <id>https://zml3589110.github.io/</id>
  
  <author>
    <name>ZhaoYichen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从零开始自制linux掌上电脑（F1C200S)</title>
    <link href="https://zml3589110.github.io/posts/2887556754.html"/>
    <id>https://zml3589110.github.io/posts/2887556754.html</id>
    <published>2025-09-18T03:49:20.000Z</published>
    <updated>2025-09-19T08:24:03.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPIO-编号规则"><a href="#GPIO-编号规则" class="headerlink" title="GPIO 编号规则"></a>GPIO 编号规则</h1><p>F1C200s 有 5 个 PIO（平台 I&#x2F;O）端口组，分别标记为 PIO0、PIO1、PIO2、PIO3 和 PIO4。<br>每个 PIO 端口组包含了 16 个 GPIO 管脚，分别标记为 PIOx.0 到 PIOx.15，其中 x 为 PIO 端口组的编号，从 0 到 4。</p><h1 id="硬件制作"><a href="#硬件制作" class="headerlink" title="硬件制作"></a>硬件制作</h1><h2 id="一、工作环境及项目简介"><a href="#一、工作环境及项目简介" class="headerlink" title="一、工作环境及项目简介"></a>一、工作环境及项目简介</h2><p><strong>立创EDA：</strong>硬件原理图及PCB绘制。</p><p><strong>全志F1C200S：</strong>F1C100S内置32MB DDR1内存，F1C200S内置64MB DDR1内存。</p><p><strong>原理图：</strong>参考开源项目，详见<a href="https://whycan.com/t_75.html">墨云</a>， 详见<a href="https://github.com/peng-zhihui/Planck-Pi">peng-zhihui</a>。</p><p><strong>核心板：</strong>四层。</p><p><strong>底板：</strong>两层。</p><p><strong>工具：</strong>烙铁、热风枪、焊锡膏、洗板水、各种电子元器件。</p><h2 id="二、原理图设计"><a href="#二、原理图设计" class="headerlink" title="二、原理图设计"></a>二、原理图设计</h2><h3 id="1、核心板"><a href="#1、核心板" class="headerlink" title="1、核心板"></a>1、核心板</h3><h4 id="🍎-电源电路"><a href="#🍎-电源电路" class="headerlink" title="🍎 电源电路"></a>🍎 电源电路</h4><p>在F1C200s的<strong>datasheet Allwinner_F1C200s_Datasheet_V1_1</strong>中可以得到推荐的运行环境，主要参考Typ，也就是典型值：</p><img src="/posts/undefined/2d9430c5289eeee40ca4d356efe50d7c.png" class="" title="img"><p>因此我们需要实现的电压有四个：<strong>1.1V、2.5V、3.0V、3.3V。</strong></p><p>使用<strong>SY8088AAC SOT-23-5</strong>同步降压DC-DC稳压器，设置其外围的电阻搭配调整其输出电压（<strong>Vout &#x3D; 0.6 * (1+Ra&#x2F;Rb)</strong> ），使用其实现1.1V、2.5V、3.3V三个电压需求：</p><img src="/posts/undefined/1b86745c004bfba59c4f01309b4f7349.png" class="" title="img"><p>使用<strong>XC6206P302MR-SOT23</strong>的封装方式，输入电压5V ，输出需求电压3.0V：</p><img src="/posts/undefined/70782d5c0cd4d7cf50adeda7b911fe83.png" class="" title="img"><p>电路设计如下图所示，根据墨云所说电感选用<strong>2.2uH功率电感，电感额定电流为2A。</strong>此处的5V电源来自底板的USB供电。下面电阻的搭配方式可以进行调节，只要满足输出的电压为需求电压即可</p><img src="/posts/undefined/827611cbbd62a080c721ab825f318b39.png" class="" title="img"><img src="/posts/undefined/0f7b68ed8dcc4d86d72cefdf14503879.png" class="" title="img"><h4 id="🍎-板对板连接器"><a href="#🍎-板对板连接器" class="headerlink" title="🍎 板对板连接器"></a>🍎 板对板连接器</h4><p>板对板连接器选用可靠性较高的排针排母对。</p><img src="/posts/undefined/5e63267b6b7b27651de3092a5e1f9a28.png" class="" title="img"><h4 id="🍎-复位电路"><a href="#🍎-复位电路" class="headerlink" title="🍎 复位电路"></a>🍎 复位电路</h4><p>复位电路比较简单，不再赘述。</p><img src="/posts/undefined/0d0b698979c70fa4661a3cb6d39202a6.png" class="" title="img"><h4 id="🍎-晶振电路"><a href="#🍎-晶振电路" class="headerlink" title="🍎 晶振电路"></a>🍎 晶振电路</h4><p>晶振采用24MHz无源晶振，两个15pF电容滤波。</p><img src="/posts/undefined/ad8dc4a3fd879786a00bef677ff945d4.png" class="" title="img"><h4 id="🍎-主控电路"><a href="#🍎-主控电路" class="headerlink" title="🍎 主控电路"></a>🍎 主控电路</h4><p>主控电路主要参考墨云和稚辉君，相关链接见上方。主要从主控F1C200s中引出TF卡引脚（本文选用的系统加载电路）、音频、晶振、串口、复位、SPI、OTG、图像、一些GPIO等等。</p><img src="/posts/undefined/799a4d55fb7441679ea0fa068b094d5c.png" class="" title="img"><h3 id="2、底板"><a href="#2、底板" class="headerlink" title="2、底板"></a>2、底板</h3><h4 id="🍍-串口转USB电路"><a href="#🍍-串口转USB电路" class="headerlink" title="🍍 串口转USB电路"></a>🍍 串口转USB电路</h4><p>选用CH340E芯片，注意某宝的芯片<strong>可能是拆机、复新芯片，</strong>如果串口通信失败，考虑芯片问题。至于下面的接线，墨云提到：<strong>“根据CH340E官方的原理图，当VCC接入5V的时候，V3 需要接一个100nf的电容，但是此处在V3直接接入5V，也可以工作。”</strong>，因此本文选择将VCC接入5V，将V3接入3.3V。</p><img src="/posts/undefined/28e07909febda8f33861f0f65a3021c1.png" class="" title="img"><h4 id="🍍-TF卡电路"><a href="#🍍-TF卡电路" class="headerlink" title="🍍 TF卡电路"></a>🍍 TF卡电路</h4><p>TF卡作为本系统唯一的系统加载方式，具体接线方式如下所示，TF卡为自弹minTF卡，只要PCB和你的硬件匹配，其他全部相同。</p><img src="/posts/undefined/92c57b2923b250a9507fa07a958906dd.png" class="" title="img"><p>🍍 <strong>USB扩展电路</strong></p><p>FE8.1（1扩4）是一个非常紧凑的高速4端口USB集线器控制器。此处我们仅使用其中两个，也就是将一个USB扩展为两个。</p><img src="/posts/undefined/c6edd905cd4bb890de290ef4288ca35c.png" class="" title="img"><h4 id="🍍-WIFI电路"><a href="#🍍-WIFI电路" class="headerlink" title="🍍 WIFI电路"></a>🍍 WIFI电路</h4><p>主要参考墨云的接线方式，暂未进行验证。</p><img src="/posts/undefined/d39a092e5c8b936de5671ed271595b7e.png" class="" title="img"><h4 id="🍍-TFT屏幕"><a href="#🍍-TFT屏幕" class="headerlink" title="🍍 TFT屏幕"></a>🍍 TFT屏幕</h4><p>1.14英寸的IPS屏幕，某宝十几块钱，我这里加了一个接线端子，因为我留出了4.3寸屏幕（正点原子）的接口，防止干扰，我加了接线端子进行选择。</p><img src="/posts/undefined/f68a36b58f4f313d8e6c0fc8633a92ed.png" class="" title="img"><h4 id="🍍-音频"><a href="#🍍-音频" class="headerlink" title="🍍 音频"></a>🍍 音频</h4><p>在墨云的基础上，结合稚辉君，我添加了咪头和3.5mm耳机接口。</p><img src="/posts/undefined/6234497a6864f15eefbbc9114858c6e4.png" class="" title="img"><h4 id="🍍-板对板连接器"><a href="#🍍-板对板连接器" class="headerlink" title="🍍 板对板连接器"></a>🍍 板对板连接器</h4><p>和核心版的板对板连接器相对应，注意不要搞反了，否则可能导致短路，板对板连接器管脚分布和PCB布局有关，因为我未考虑到PCB布局，导致后面的布局较为困难，虽然核心板采用四层板，底板采用两层板，但布线还是花了很大功夫。</p><img src="/posts/undefined/d71bd954a76da65a43c1aa710018bd1b.png" class="" title="img"><h4 id="🍍-40Pin4-3寸屏幕"><a href="#🍍-40Pin4-3寸屏幕" class="headerlink" title="🍍 40Pin4.3寸屏幕"></a>🍍 40Pin4.3寸屏幕</h4><p>屏幕为4.3寸正点原子屏幕，采用FPC连接，接线端子管脚间距为0.5mm，由于我的焊接设备原因，焊接较为麻烦。</p><img src="/posts/undefined/775906117b7296dcfb39c7aa0fc623d6.png" class="" title="img"><h2 id="三、PCB展示"><a href="#三、PCB展示" class="headerlink" title="三、PCB展示"></a>三、PCB展示</h2><p>Wood是我做的标志，之所以选用排针连接底板和核心板，是因为排针相较于金手指和BTB来说，可以重复拔插，更便于将一个核心板应用到其他底板上。</p><img src="/posts/undefined/42d2a04b4746c7c9e37e1a70f7d8d4b4.png" class="" title="img">**核心板（四层，挺漂亮哈）**<img src="/posts/undefined/acddb7024a7548b4413b8a39437aa308.png" class="" title="img">**底板**<h2 id="四、实物展示"><a href="#四、实物展示" class="headerlink" title="四、实物展示"></a>四、实物展示</h2><img src="/posts/undefined/fa7f9a6ab4afe90e944ef6b3aa852e2c.png" class="" title="img">**核心板**<img src="/posts/undefined/3f103fc619624827174a8cc0cd1ceeb3.png" class="" title="img">**底板**<img src="/posts/undefined/b0b9fbcdbc90441cd4c8401120a75269.png" class="" title="img">**焊接完成组装实物**<h1 id="uboot移植"><a href="#uboot移植" class="headerlink" title="uboot移植"></a>uboot移植</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote><p>在移植Linux之前我们需要先移植一个bootloader代码，这个bootloader代码用于启动Linux内核，<strong>bootloader有很多，常用的就是 uboot。</strong>移植好uboot以后再移植Linux内核，移植完Linux内核以后Linux还不能正常启动，还需要再移植一个根文件系统(rootfs)，根文件系统里面包含了一些最常用的命令和文件。所以<strong><em>*uboot、Linux kernel 和 rootfs*</em> 这三者一起构成了一个完整的Linux系统</strong>，一个可以正常使用、功能完善的 Linux 系统。</p><p><strong>– 来自正点原子嵌入式Linux驱动开发指南。</strong></p></blockquote><p>Linux系统要启动就必须需要一个bootloader程序，<strong>也就说芯片上电以后先运行一段bootloader程序。这段 bootloader 程序会先初始化DDR等外设，然后将 Linux 内核从 flash(NAND，NOR FLASH，SD，MMC等)拷贝到DDR中，最后启动Linux内核。</strong>下面我们首先进行uboot的移植，或者说适配。</p><hr><h2 id="二、F1C200s上电启动顺序"><a href="#二、F1C200s上电启动顺序" class="headerlink" title="二、F1C200s上电启动顺序"></a>二、F1C200s上电启动顺序</h2><p>在进行uboot移植之前，需要了解<strong>F1C200s芯片上电后启动的顺序，</strong>避免重复造轮子，我们直接根据<a href="https://whycan.com/t_1746.html">F1C100s启动时搜索SPI Flash的顺序？</a>了解到启动顺序如下，F1C200s同F1C100s。</p><blockquote><p>\1. 上电后, f1c100s内部 BROM (芯片内置，无法擦除) 启动,<br>\2. 首先检查 SD0 有没有插卡, 如果有插卡就读卡 8k偏移数据，是否是合法的启动数据, 如果是BROM 引导结束, 否则进入下一步<br>\3. 检测SPI0 NOR FLASH(W25QXXX, MX25LXXX) 是否存在, 是否有合法的启动数据, 如果是BROM 引导结束, 否则进入下一步<br>\4. 检测SPI0 NAND FLASH 是否存在, 是否有合法的启动数据, 如果是BROM 引导结束, 否则进入下一步<br>\5. 因为找不到任何可以引导的介质， 系统进入usb fel 模式， 可以用USB烧录了。</p></blockquote><p><strong>上电之后，F1C200s芯片内部的BROM启动检查到SD卡，读取8k偏移数据。</strong></p><blockquote><p>注意：这里的<code>bs=1024 seek=8</code>是添加了8192字节的偏移，之所以要加8K偏移是因为FSBL也就是bootROM里面硬写死了会从设备的8K地址处加载SPL，然后进入uboot。因此上面烧写的时候，指定的偏移地址一定是相对于储存设备硬件的偏移，而不是相对于分区的偏移！</p><p>来自：<a href="https://github.com/peng-zhihui/Planck-Pi">peng-zhihui&#x2F;Planck-Pi: Super TINY &amp; Low-cost Linux Develop-Kit Based On F1C200s.</a></p></blockquote><hr><h2 id="三、前期准备"><a href="#三、前期准备" class="headerlink" title="三、前期准备"></a>三、前期准备</h2><p><strong>虚拟机VmwareWorkstation安装；</strong></p><p><strong>ubuntu16.04系统安装。</strong></p><hr><h2 id="四、新建用户"><a href="#四、新建用户" class="headerlink" title="四、新建用户"></a>四、新建用户</h2><p>如果你已经再当前用户安装了一些其他的编译器，那么最好创建一个<strong>新的账户</strong>，避免一些命令可能出现干扰，或者说与其他项目隔离开，具体操作如下，比较简单，看图操作即可。</p><img src="/posts/undefined/c70236345acc7b5dec031062c915dcdc.png" class="" title="img"><img src="/posts/undefined/ab18a8cba47d153dba64c7efae2edf0c.png" class="" title="img"><img src="/posts/undefined/81aa4470e3a91dfd81c1910cf8109302.png" class="" title="img"><img src="/posts/undefined/158f58337ef05c4add45859e667916c7.png" class="" title="img"><hr><h2 id="五、交叉编译环境配置"><a href="#五、交叉编译环境配置" class="headerlink" title="五、交叉编译环境配置"></a>五、交叉编译环境配置</h2><p>在路径 <em><strong>*“ linaro release*</strong></em><em><strong>*-&gt;compoments-&gt;toolchain-&gt;binaries-&gt;7.2-2017.11-&gt;arm-linux-gnueabi-&gt;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz ”*</strong></em> 中下载对应的交叉编译器，记住是release版本，不是snapshots版本。<strong>（Snapshot版本代表不稳定、尚处于开发中的版本，快照版本。Release版本则代表稳定的版本，发行版本。）</strong>具体链接如下：</p><p><a href="https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/">Linaro Releases<img src="/posts/undefined/039a84e0f347bb45be0e5dcf71ea800a.png" class="" title="img">https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/</a><strong>下载完成，使用如下面命令解压缩：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz </span><br></pre></td></tr></table></figure><p><strong>将解压的文件复制到&#x2F;usr&#x2F;local&#x2F;arm&#x2F;中，操作命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rf &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi .&#x2F;</span><br></pre></td></tr></table></figure><p>**然后添加该*<em>交叉编译器的环境变量，*<em>只有这样编译器才能在任何目录或者任何位置打开的终端中执行，打开~&#x2F;.bashrc文件 *</em>(修改<code>.bashrc文件</code>，只是针对某一个特定的用户；修改<code>/etc/profile文件</code>，它是针对于所有的用户)*<em>，写入以下内容：</em></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;arm&#x2F;gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;bin</span><br></pre></td></tr></table></figure><p><strong>使环境变量生效：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bashrc </span><br></pre></td></tr></table></figure><p><strong>验证是否成功：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -v</span><br></pre></td></tr></table></figure><img src="/posts/undefined/5a0b5ac09e8bb21ede25a4d3785c6744.png" class="" title="img"><hr><h2 id="六、uboot简介"><a href="#六、uboot简介" class="headerlink" title="六、uboot简介"></a>六、uboot简介</h2><p>bootloader主要的工作就是启动 Linux 内核，<strong>bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样</strong>****，**bootloader就相当于BIOS。**常见的bootloader有 U-Boot、vivi、RedBoot 等等。</p><p>本文使用<strong>uboot</strong>作为系统的bootloader，它的全称是**”Universal Boot Loader”<strong>，意为</strong>“通用引导加载程序”。<strong>uboot是一种裸机程序，可以视为是一个</strong>汇集了多种裸机功能的综合示例。**目前的uboot已经支持液晶显示屏、网络连接、USB等高级功能。</p><p><strong>uboot官方</strong>会维护uboot源码，也是最原汁原味的源码，但是官方提供的代码是供<strong>半导体厂商</strong>，也就是生产F1C200s的厂商使用的，他们会维护一个<strong>定制版本的uboot，</strong>但是，很遗憾，全志并没有将资料公开。<strong>**（注：后来发现，<a href="https://github.com/allwinner-zh/bootloader">这里</a>有全志的uboot，不知道这个是否是官方的网站，但已经好久没有更新）*<em><strong>由于网上关于F1C200s的uboot从零开始的开发资料几乎没有，此处我们使用</strong>荔枝派</em>*的uboot启动Linux。</strong>（后面有时间再完善，欢迎大佬加群或评论区指导）**</p><hr><h2 id="七、uboot移植"><a href="#七、uboot移植" class="headerlink" title="七、uboot移植"></a><strong>七、uboot移植</strong></h2><h4 id="🍏-uboot下载"><a href="#🍏-uboot下载" class="headerlink" title="🍏 uboot下载"></a><strong>🍏 uboot下载</strong></h4><p>**首先在github上*<em>下载Lichee-Pi提供的uboot，*<em>当然，前提是你的虚拟机能访问网络，如果不会配置，参看我左侧专栏虚拟机中的文章即可。或者直接在Windows中<a href="https://github.com/Lichee-Pi/u-boot">github</a>上下载，然后传到ubuntu中解压。</em></em> </p><img src="/posts/undefined/ba3d3c29db1402f9d167aa44056565eb.png" class="" title="img"><p>uboot下载完成后，打开文件夹，<strong>uboot文件内容</strong>如下图所示：</p><img src="/posts/undefined/5decc9a2b753263ee8f79eb86e916490.png" class="" title="img"><h4 id="🍏-uboot默认配置"><a href="#🍏-uboot默认配置" class="headerlink" title="🍏 uboot默认配置"></a><strong>🍏</strong> uboot默认配置</h4><p>对于同一款芯片，比如F1C200s，可能有<strong>不同的外设</strong>，uboot需要<strong>初始化的内容也不相同</strong>，因此需要选用uboot中的某些配置，去初始化各个外设，在uboot中的configs文件夹中存储着一些配置“套餐”，就是已经固定配置某些外设的<strong>**默认配置文件**，**一旦进行编译，uboot会</strong>根据这个配置文件进行配置。**</p><img src="/posts/undefined/d4d61856f45cecf40476ac0d04cec742.png" class="" title="img"><p>如上图所示，为uboot的<strong>configs目录</strong>下的两个荔枝派的配置文件，第一个<strong>licheepi_nono_defconfig</strong>   是针对<strong>**TF卡*<em><strong>的配置文件，第二个</strong>licheepi_nano_spiflash_defconfig</em>*是针对</strong>flash<strong>的启动文件，显然我们需要</strong>选择第一个配置文件**编译uboot，因为我们只有TF卡一种存储介质，没有flash。下面是编译指令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>为了避免使用类似于上方的<strong>繁琐编译指令，</strong>在uboot根目录Makfile中加入如下内容：</p><img src="/posts/undefined/dca8b0ceb6b83a231f786574a63afadb.png" class="" title="img"><p>这样我们可以通过以下简洁的代码进行uboot配置： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 进入u-boot目录</span><br><span class="line">cd u-boot&#x2F;</span><br><span class="line"></span><br><span class="line"># 加载配置文件</span><br><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><img src="/posts/undefined/9c9ae54d1123928cd1f4bbbe61c6b6df.png" class="" title="img"><p> 经过以上操作，默认配置文件<strong>licheepi_nano_deconfig</strong>已经写入到，**&#x2F;uboot&#x2F;.config文件<strong>中，这是根据默认配置文件，生成的uboot的</strong>最终配置文件**，这个配置文件记录了所有配置选项的宏开关，我们可以通过宏开关对其进行修改。</p><p><strong>注意：硬件中USB T口连接uart0，而荔枝派默认初始化uart0，因此无需修改。</strong></p><h4 id="🍏-uboot图形界面配置"><a href="#🍏-uboot图形界面配置" class="headerlink" title="🍏 uboot图形界面配置"></a><strong>🍏 uboot图形界面配置</strong></h4><p>使用<strong>make menuconfig</strong>命令进行图形界面配置uboot。</p><ol><li>bootcmd，主要用于描述控制Linux内核文件以及其他描述文件加载到内存中位置以及启动Linux内核系统等</li><li>bootargs，用于配制文件系统、串口信息等。</li></ol><p><strong>Enable boot arguments</strong> 选项上点击空格，弹出<strong>Boot arguments</strong>选项，选中回车输入以下内容后回车保存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p>同样的操作输入<strong>bootcmd</strong>的值，输入完成后如下图所示，有关<strong>bootargs和bootcmd</strong>值的含义，后序文章进行分析，这里不做解释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/17b3b46aaae4fefaf43d314c6c1580e5.png" class="" title="img"><h4 id="🍏-uboot编译"><a href="#🍏-uboot编译" class="headerlink" title="🍏 uboot编译"></a><strong>🍏</strong> uboot编译</h4><p>在进行编译之前需要在Ubuntu 中安装 <strong>ncurses 库</strong>，否则可能编译会报错，安装命令如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev</span><br></pre></td></tr></table></figure><p>使用<strong>make -j2</strong>进行编译，其中-j2代表处理器核心数。编译完成，在根目录下找到<strong>u-boot-sunxi-with-spl.bin文件，</strong>该文件为最终烧录文件。</p><h4 id="🍏-烧录bin文件"><a href="#🍏-烧录bin文件" class="headerlink" title="🍏 烧录bin文件"></a><strong>🍏</strong> 烧录bin文件</h4><p>只要将<strong>u-boot-sunxi-with-spl.bin</strong>烧录到tf卡的<strong>8k偏移地址处</strong>就可以了，至于为什么，上面的引用已经解释清楚了。将准备号的TF卡插入读卡器，使用如下<strong>块搬移命令</strong>进行烧写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if&#x3D;u-boot-sunxi-with-spl.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</span><br></pre></td></tr></table></figure><blockquote><p><strong>if</strong>  文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</p><p><strong>of</strong>  文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</p><p><strong>bs</strong> bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p><p><strong>seek</strong> blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>这里的输出文件(of)为主机电脑的&#x2F;dev&#x2F;sdb文件，也就是插入的读卡器代表的TF卡。</p></blockquote><p> 烧录完成，如下图所示，然后弹出读卡器之后再拔出，否则可能损坏读卡器。<img src="/posts/undefined/65702ac2a6ae73522cd590802f6d7164.png" class="" title="img"></p><hr><h2 id="八、uboot启动测试"><a href="#八、uboot启动测试" class="headerlink" title="八、uboot启动测试"></a>八、uboot启动测试</h2><p>将开发板使用<strong>数据线</strong>与电脑相连，打开<strong>串口调试</strong>工具，根据<strong>bootargs参数</strong>设置串口通信参数：</p><img src="/posts/undefined/af0b325e42802fc3d6755ec8888726ab.png" class="" title="img"><p> 正常启动，窗串口调试工具为<strong>SecureCRT，</strong>选中端口后，波特率设置为<strong>115200：</strong></p><img src="/posts/undefined/0569a1909e121f7e1e9b29cd9b24ae88.png" class="" title="img"><blockquote><p>墨云：</p><p>因为在你插入USB通电的时候开发板就已经启动了，所以当你打开串口连接的时候可能<strong>未必会看到信息，</strong>所以按一下<strong>重启键</strong>，就可以看到如下的输出信息了，这就是我们的u-boot，执行到u-boot计数完成后会产生错误，那是因为我们还没有进行系统内核的移植，所以默认就会进入u-boot命令模式。</p></blockquote><p>点击复位按钮之后，在3秒之内（我设置的5秒）<strong>点击回车</strong>即可进入<strong>uboot命令模式</strong>，在 <strong>uboot命令模式</strong>输入<strong>“print”</strong>来查看环境变量 <strong>bootargs和bootcmd的值</strong>如下，和我们设置的相同，表示uboot启动成功！</p><img src="/posts/undefined/05fa8bba2156590e7ec8adbcff93148a.png" class="" title="img"><p> 至此，完成uboot移植全部内容，然而并没有像我想的那样，从零开始，按照官方的uboot一步一步自己移植，谁让我是个小白呢。</p><hr><h1 id="内核移植"><a href="#内核移植" class="headerlink" title="内核移植"></a>内核移植</h1><h2 id="一、bootloader、kernel、rootfs联系"><a href="#一、bootloader、kernel、rootfs联系" class="headerlink" title="一、bootloader、kernel、rootfs联系"></a>一、bootloader、kernel、rootfs联系</h2><p>kernel可以理解为一个<strong>庞大的裸机程序</strong>，和uboot以及其他比如点灯类似的裸机程序没有本质区别，只是kernel分为<strong>用户态和内核态</strong>，内存和设备操作与裸机程序不同。kernel是<strong>最底层</strong>，负责各种外设硬件的驱动，kernel类似于<strong>黑盒子</strong>，从外面只能看到接口，无法看到具体功能是如何实现的，内核初始化提供的接口后，将<strong>控制权</strong>通过<strong>init程序</strong>交给根文件系统。</p><p><a href="https://zhuanlan.zhihu.com/p/489819324#:~:text=%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%98%AF%E6%8E%A7%E5%88%B6,%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%80%E4%B8%AA%E6%A1%A5%E6%A2%81%E3%80%82">详见：一文讲解Linux内核中根文件系统挂载流程 - 知乎</a></p><hr><h2 id="二、内核移植"><a href="#二、内核移植" class="headerlink" title="二、内核移植"></a>二、内核移植</h2><h3 id="1-内核源码获取"><a href="#1-内核源码获取" class="headerlink" title="1. 内核源码获取"></a>1. 内核源码获取</h3><p>下载<a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags?h=v5.10.161">Linux5.7.1源码</a> ，下载后完成后，将代码复制到Ubuntu新建的用户中并解压。</p><p>或者在<a href="https://mirror.bjtu.edu.cn/kernel/linux/kernel/v5.x/">国内镜像网站</a> 下载，速度相比于官网快很多很多。</p><h3 id="2-内核配置与编译"><a href="#2-内核配置与编译" class="headerlink" title="2. 内核配置与编译"></a>2. 内核配置与编译</h3><h4 id="🍍-基础配置与编译"><a href="#🍍-基础配置与编译" class="headerlink" title="🍍 基础配置与编译"></a>🍍 基础配置与编译</h4><p>解压完成后，使用<strong>VScode</strong>打开linux源码，同uboot编译前一样进行配置，首先在<strong>顶层Makfile</strong>中指定<strong>架构和交叉编译工具。*<em>注意：arm必须是小写，必须！*</em></strong></p><img src="/posts/undefined/1ce48567fc7491d4ad1f80f6cfd23257.png" class="" title="img"><p>在uboot移植中，我们使用<strong>licheepi_nano_defconfig配置uboot，</strong>以识别开发板（不同开发板拥有不同的外设），同样，Linux内核也需要进行配置，在墨云对Linux内核进行移植时，提到：</p><blockquote><p>进入内核源码中的<strong>arch&#x2F;arm&#x2F;configs</strong>目录中，可以看到有很多开发板的配置文件，其中<strong>sunxi_defconfig</strong>是全志的配置文件，但是该配置文件<strong>非常不全</strong>，需要额外配置大量的选项，一般选项多大上千个，这里先使用**<a href="https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip">licheepi_nano的配置文件。</a>**</p></blockquote><p>因此，同样，作为新手来讲，只能使用<strong>荔枝派的配置文件，</strong>下载文件后放到<strong>arch&#x2F;arm&#x2F;configs</strong>文件夹中，在根目录使用以下命令配置Linux内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make linux-licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>可能会报错：</p><img src="/posts/undefined/0334512651d95c7d3c0eaab704a89509.png" class="" title="img"><img src="/posts/undefined/9e599b56ec9c8c2633f1a165e05bd1e0.png" class="" title="img"><p> 使用如下命令安装组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install bison -y</span><br></pre></td></tr></table></figure><p>如果出现以下错误，考虑更换<a href="https://blog.csdn.net/qq_27979907/article/details/107974738">镜像源，</a>注意一定要<strong>按照自己的Ubuntu版本</strong>选择对应的源，最好更新为<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">最新的清华源：</a></p><img src="/posts/undefined/6fb7fae25e1841d6ee20d7ea70054910.png" class="" title="img"><p>使用<strong>make</strong>命令编译，经过漫长的等待后，在 <strong>arch&#x2F;arm&#x2F;boot</strong>目录下生成内核文件：<strong>zImage，</strong>在<strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong>目录下设备树文件：<strong>suniv-f1c100s-licheepi-nano.dtb。</strong></p><p>如果出现以下错误，使用<strong>sudo apt install libssl-dev</strong>命令安装对应缺失库文件即可。</p><img src="/posts/undefined/6c7731469a92e90d14dc91683b32c79c.png" class="" title="img"><h4 id="🍍-TF卡分区"><a href="#🍍-TF卡分区" class="headerlink" title="🍍 TF卡分区"></a>🍍 TF卡分区</h4><p>uboot移植的时候<strong>**bootcmd*<em><strong>变量记录了</strong>内核文件（zImage）</em>*和</strong>**设备树（.dtb文件）*<em><strong>的存放位置，那么现在我们就要准备好TF卡的分区，一旦编译出内核文件和设备树文件，就可以放到TF卡的</strong>指定位置</em>*，启动Linux内核。</p><img src="/posts/undefined/c62958a8be622b4a937e3e253d5278c7.png" class="" title="img"><p>我们需要将TF卡分区如下，其中uboot只能识别FAT16格式，EXT4格式为Linux内核识别格式。<strong>注意：一定要把上面图片中的分区删除，否则无法识别到启动文件（zImage、.dtb）。</strong></p><table><thead><tr><th><strong>分区</strong></th><th><strong>分区一</strong></th><th><strong>分区二</strong></th></tr></thead><tbody><tr><td><strong>名称</strong></td><td><strong>kernel</strong></td><td><strong>rootfs</strong></td></tr><tr><td><strong>分区格式</strong></td><td><strong>FAT16</strong></td><td><strong>EXT4</strong></td></tr><tr><td><strong>大小</strong></td><td><strong>32M（可以随意填写)</strong></td><td><strong>剩余空间</strong></td></tr></tbody></table><p>TF卡配置完成如下图所示，注意我的TF卡是8G容量。</p><img src="/posts/undefined/71debed3f21e7eaabe0a8cc53fd97620.png" class="" title="img"><p>注意需要给uboot<strong>预留1M</strong>的空间，在【之前的空余空间】选择1M即可，在上面的可视化分区中无法看到这个预留空间。</p><h4 id="🍍-内核烧录"><a href="#🍍-内核烧录" class="headerlink" title="🍍 内核烧录"></a>🍍 内核烧录</h4><p>将上面编译产生的<strong>zImage、suniv-f1c100s-licheepi-nano.dtb</strong>两个文件拷贝到<strong>KERNEL分区。</strong>将TF卡插好之后上电，打开<strong>串口调试，</strong>按下复位按键，等待uboot启动，5秒倒计时结束，读取两个文件，启动Linux内核。至此，Linux内核移植完成，下一步是Linux根文件系统（rootfs）。</p><img src="/posts/undefined/39d8a10735492e012f0f5ca0e8985ee5.png" class="" title="img"><hr><h1 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h1><h2 id="一、根文件系统介绍"><a href="#一、根文件系统介绍" class="headerlink" title="一、根文件系统介绍"></a>一、根文件系统介绍</h2><blockquote><p>文件系统是对一个<strong>存储设备</strong>上的数据和元数据进行<strong>组织的机制</strong>，这种机制有利于<strong>用户和操作系统的交互。</strong>在Linux没有文件系统的话，用户和操作系统的交互也就断开了。</p></blockquote><blockquote><p>Unix<strong>没有盘符</strong>的概念，要求自己的文件系统是<strong>单一的一棵树</strong>。直接挂载在整棵树根上的那个盘里面的文件系统，就是<strong>根文件系统。</strong></p></blockquote><blockquote><p>文件系统不是指某一个<strong>文件系统类型，</strong>而是指任何可以将文件目录组织成<strong>特定系统所需结构</strong>的文件系统，然后把它挂载在系统的<strong>根</strong>上。</p></blockquote><p>Linux中的根文件系统像是一个<strong>文件夹管理系统，</strong>或者说像是一本书的<strong>目录，</strong>在某种意义上讲，根文件系统就是一个文件夹，只不过是这是一个特殊的文件夹，在这个目录里面会有很多的子目录，如下图所示。</p><img src="/posts/undefined/38bf130a320c2fede1942831de9cfdc1.png" class="" title="img"><img src="/posts/undefined/bf9d263d7c59f3b1d9d8925b7394db8f.png" class="" title="img"><p>下面是虚拟机中<strong>Ubuntu系统</strong>的根文件系统，根文件系统的目录名字为 <strong>‘&#x2F;’</strong> ，也就是一个<strong>斜杠，</strong>各个目录的功能在下面的表格中做了详细介绍。</p><img src="/posts/undefined/63ec775ad71f6331f5f2b305fa5528b5.png" class="" title="img"><table><thead><tr><th align="left">Item</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><strong>&#x2F; (root filesystem)</strong></td><td align="left">根文件系统是文件系统的最高级别目录。在其他文件系统被挂载之前，它必须包含启动Linux系统所需的所有文件。它必须包括启动其余文件系统所需的所有可执行文件和库。在系统启动后，所有其他文件系统都被挂载在标准的、定义明确的挂载点上，作为根文件系统的子目录。</td></tr><tr><td align="left"><strong>&#x2F;bin</strong></td><td align="left">&#x2F;bin目录包含用户可执行文件。</td></tr><tr><td align="left"><strong>&#x2F;boot</strong></td><td align="left">包含启动Linux计算机所需的静态引导程序和内核可执行文件以及配置文件。</td></tr><tr><td align="left"><strong>&#x2F;dev</strong></td><td align="left">这个目录包含了连接到系统的每个硬件设备的设备文件。这些不是设备驱动程序，而是代表计算机上每个设备的文件，并为访问这些设备提供便利。</td></tr><tr><td align="left"><strong>&#x2F;etc</strong></td><td align="left">包含主机的本地系统配置文件。</td></tr><tr><td align="left"><strong>&#x2F;home</strong></td><td align="left">用户文件的主目录存储。每个用户都有一个&#x2F;home的子目录。</td></tr><tr><td align="left"><strong>&#x2F;lib</strong></td><td align="left">包含启动系统所需的共享库文件。</td></tr><tr><td align="left"><strong>&#x2F;media</strong></td><td align="left">一个安装外部可移动媒体设备的地方，如可能连接到主机的USB拇指驱动器。</td></tr><tr><td align="left"><strong>&#x2F;mnt</strong></td><td align="left">普通文件系统（如不是可移动媒体）的临时挂载点，可以在管理员修复或处理文件系统的时候使用。</td></tr><tr><td align="left"><strong>&#x2F;opt</strong></td><td align="left">可选的文件，如供应商提供的应用程序应位于这里。</td></tr><tr><td align="left"><strong>&#x2F;root</strong></td><td align="left">这不是根（&#x2F;）文件系统。它是根用户的主目录。</td></tr><tr><td align="left"><strong>&#x2F;sbin</strong></td><td align="left">系统二进制文件。这些是用于系统管理的可执行文件。</td></tr><tr><td align="left"><strong>&#x2F;tmp</strong></td><td align="left">临时目录。由操作系统和许多程序用来存储临时文件。用户也可以在这里临时存储文件。请注意，存储在这里的文件可能在任何时候被删除，而无需事先通知。</td></tr><tr><td align="left"><strong>&#x2F;usr</strong></td><td align="left">这些是可共享的、只读的文件，包括可执行的二进制文件和库、人文件和其他类型的文件。</td></tr><tr><td align="left"><strong>&#x2F;var</strong></td><td align="left">可变的数据文件被存储在这里。这可以包括像日志文件、MySQL和其他数据库文件、网络服务器数据文件、电子邮件收件箱，以及更多的东西。</td></tr></tbody></table><hr><h2 id="二、根文件系统移植"><a href="#二、根文件系统移植" class="headerlink" title="二、根文件系统移植"></a>二、根文件系统移植</h2><h3 id="1、buildroot下载"><a href="#1、buildroot下载" class="headerlink" title="1、buildroot下载"></a>1、buildroot下载</h3><p>我们使用<strong>buildroot</strong>制作根文件系统，之前imx6ull使用的<strong>busybox，</strong>这里换一下，哈哈，首先进入官网，下载根文件系统<strong>buildroot2018.2.11版本，</strong>与墨云保持一致，下载后放到Ubuntu中解压。<a href="https://buildroot.org/download.html">https://buildroot.org/download.html<img src="https://i-blog.csdnimg.cn/blog_migrate/039a84e0f347bb45be0e5dcf71ea800a.png" alt="img">https://buildroot.org/download.html</a></p><img src="/posts/undefined/16bf53f255e1014e4e752296ceb6f0b2.png" class="" title="img"><p>这个网站比较友好，不需要魔法，buildroot体积较小，直接下载即可，下面是几个不同后缀的文件。</p><img src="/posts/undefined/e4373534d5b7ae809f099e92c13867b7.png" class="" title="img"><p> 上面的四个选项，下载后是下面的文件，sign是什么文件我不清楚，嘿嘿，欢迎评论区指出，选择一个压缩包，到Ubuntu中解压</p><img src="/posts/undefined/3856ef4f5b04ad470b82f0c43b224cd1.png" class="" title="img"><h3 id="2、根文件系统制作"><a href="#2、根文件系统制作" class="headerlink" title="2、根文件系统制作"></a>2、根文件系统制作</h3><p> 解压完成后进入根目录，<strong>清理工程</strong>后，进入<strong>图形界面配置：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><strong>图形配置界面</strong>如下图所示，使用<strong>方向键</strong>选择不同选项，<strong>空格</strong>进行选中，<strong>回车</strong>进行确认。</p><img src="/posts/undefined/3a02d588de0c22fb0d46063ed18e678a.png" class="" title="img"><p>Target options选项的配置如下图所示，每个选项的含义墨云解释过了，我就不造轮子了。 </p><img src="/posts/undefined/455724818a74976030400f831f5e5140.png" class="" title="img"><blockquote><ul><li>第一个选项为架构选择，这里选择ARM架构小端模式，</li><li>第二个为输出的二进制文件格式，这里选择EFL格式，</li><li>第三个为架构体系，这里选择arm926t，因为F1C200S&#x2F;F1C100S的架构就是这个架构，</li><li>第四个为矢量浮点处理器，这里不勾选，因为对于F1C200S&#x2F;F1C100S而言，其内部没有浮点运算单元，只能进行软浮点运算，也就是模拟浮点预运算。</li><li>第五个为应用程序二进制接口，这里选择EABI，原因是该格式支持软件浮点和硬件实现浮点功能混用。</li><li>第六个为浮点运算规则，这里使用软件浮点</li><li>第七个选择指令集，这里选择ARM指令集，因为thumb主要针对Cortex M系列而言的，对于运行操作系统的A系列以及ARM9和ARM11而言，使用的都是32位的ARM指令集。</li></ul><p>来自：<a href="https://www.cnblogs.com/twzy/p/15355842.html">小白自制Linux开发板 三. Linux内核与文件系统移植 - 淡墨青云 - 博客园</a></p></blockquote><p>据说Toolchain按照下方配置（打开了一些功能）可以在开发板上直接编译程序。 </p><img src="/posts/undefined/9e713011b73ff3129131295e7da48c4c.png" class="" title="img"><p>登录的时候会显示 <strong>“Wecome to kashine linux system.”</strong> ，并且我们设置了<strong>root用户密码为“good luck!”。</strong></p><img src="/posts/undefined/68122ef42f9ee4586e28bfa96df5bd6d.png" class="" title="img"><p>配置完成后，使用<strong>make命令</strong>进行编译，从下面可以看出，buildroot的编译需要<strong>网络支持，</strong>以通过网络配置我们选择的内容。 当然如果你的虚拟机无法连接网络，请看<a href="https://blog.csdn.net/qq_41709234/article/details/123145449">虚拟机ubuntu桥接怎么联网</a>，或者是<a href="https://blog.csdn.net/qq_41709234/article/details/124901317">虚拟机net模式访问互联网</a>。</p><img src="/posts/undefined/97c047f3075ca262d6381b9b5ff906fe.png" class="" title="img"><p>此处是<strong>漫长的等待……….，</strong>建议来一道力扣中等！复杂链表的复制！<a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress=y16046r">力扣<img src="/posts/undefined/039a84e0f347bb45be0e5dcf71ea800a.png" class="" title="img">https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/?envType=study-plan&id=lcof&plan=lcof&plan_progress&#x3D;y16046r</a></p><p>这个下载速度真的是<strong>奇慢无比！</strong>如果下载依赖包或者软件速度非常慢，可以尝试（不要试了，我试过不管用，哈哈）<a href="https://blog.51cto.com/u_15175006/2720995">Ubuntu20.04换源之后依旧慢？</a><a href="https://blog.csdn.net/LukeZhaZha/article/details/104070045">Ubuntu16.04找不到Software&amp;Updates（软件更新）</a>，但我试了一下仍然很慢，这不科学呀！魔法也不管用。</p><img src="/posts/undefined/9d637b3f3f4c7a7526b01aa749780086.png" class="" title="img"><p>终于编译完成了！已经是第二天了，昨天搞到1：00还没有编译完，我就直接挂起虚拟机，今天早晨打开Ubuntu没大会，就已经编译完成了，大概两个多小时。编译完成后，在buildroot根目录的****output&#x2F;images目录*<em><strong>下生成一个</strong>rootfs.rar文件</em>*，这个就是我们心心念念的根文件系统。</p><img src="/posts/undefined/a97b6c2f1c95c40b78f572acfe223960.png" class="" title="img"><p>注意：第二次编译就会快很多，比如误删，别问我怎么知道的，唔哈哈哈。 </p><h3 id="3、根文件系统移植"><a href="#3、根文件系统移植" class="headerlink" title="3、根文件系统移植"></a>3、根文件系统移植</h3><p>将上面得到的<strong>rootfs.rar</strong>解压到TF卡的<strong>第二个分区</strong>，也就是<strong>rootfs分区</strong>，不要解压完成在复制过去，因为解压出来好多文件夹。两种选择，要么把压缩包复制到rootfs分区，解压后删除压缩包，要么直接解压到第二分区。使用如下命令将压缩包<strong>解压到rootfs分区后</strong>如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -vxf rootfs.tar -C &#x2F;media&#x2F;project01&#x2F;rootfs&#x2F;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/f41f2b0688c2bc690b8ebf14a886a9aa.png" class="" title="img"><p>其中tar解压缩命令格式如下：</p><table><thead><tr><th><strong>选项</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>-x</strong></td><td><strong>对 tar 包做解打包操作。</strong></td></tr><tr><td><strong>-f</strong></td><td><strong>指定要解压的 tar 包的包名。</strong></td></tr><tr><td><strong>-t</strong></td><td><strong>只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作。</strong></td></tr><tr><td><strong>-C 目录</strong></td><td><strong>指定解打包位置。</strong></td></tr><tr><td><strong>-v</strong></td><td><strong>显示解打包的具体过程。</strong></td></tr></tbody></table><h3 id="4、根文件系统加载"><a href="#4、根文件系统加载" class="headerlink" title="4、根文件系统加载"></a>4、根文件系统加载</h3><p>TF卡第二个分区内已经放置了我们制作好的根文件系统，将TF卡插到开发板上并<strong>上电启动，</strong>打开<strong>串口调试</strong>助手，设置<strong>波特率115200，</strong>可以看到下面的内容，<strong>uboot和内核启动成功。</strong></p><img src="/posts/undefined/c5af8acc93d90bc7be2efe5f252f2a25.png" class="" title="img"><p>但是并没有启动Linux的根文件系统，我们看最后打印出的提示代码为： <strong>Waiting for root device &#x2F;dev&#x2F;mmcblk0p2…，</strong>看来是<strong>mmcblk0p2表示mmc设备（MultiMedia Card，多媒体存储卡）没有被内核启动成功</strong>，mmcblk0是我们的TF卡，p2代表第二个分区，我们最终确定是<strong>mmc设备</strong>出了问题。</p><img src="/posts/undefined/87902481b25d7c127344c9821270fdbf.png" class="" title="img"><h3 id="5、mmc设备问题分析"><a href="#5、mmc设备问题分析" class="headerlink" title="5、mmc设备问题分析"></a>5、mmc设备问题分析</h3><p>我们先来分析一下出现这个问题的原因，如果说<strong>mmcblk0p2</strong>设备出现问题，那么为什么在启动Linux内核的时候没有出错的，内核文件和设备树文件存放在<strong>mmcblk0p1</strong>中，如果是<strong>mmcblk0p2</strong>加载出错，也就表示TF卡的设备树或者是驱动出了问题，那么<strong>mmcblk0p1</strong>不应该也是错的吗？<strong>那Linux内核不应该能够启动才对的？</strong></p><p>小朋友，你是否有很多问号？好的，现在来说一下我对上面问题的理解。其实上面的<strong>问题有点不太对，</strong>不知道大家是否有相同的疑问，所以我对上面也进行了保留。<strong>下面分析：</strong>首先是<strong>uboot的启动，</strong>在TF卡的8k处，我们硬件没有问题，也就是说TF卡接在F1C200s的指定引脚，bootROM启动的时候一定会读取TF卡的8k位置，成功启动uboot，而在uboot启动后，进入倒计时，<strong>倒计时结束后，****执行bootcmd命令，</strong>bootcmd命令如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>该命令的主要作用是将<strong>zImage和设备树从mmc的第一个分区拷贝到内存中执行，</strong>这个应该好理解哈，Linux内核启动成功了，说明uboot能够将两个文件拷贝到内存中执行，进一步说明<strong>**uboot的TF卡驱动**是没有问题的，**拷贝结束后，</strong>uboot生命周期结束，Linux内核启动，<strong>但是</strong>Linux内核TF卡启动出错**，导致无法加载TF卡第二分区中的根文件系统。</p><p>至此，我们大致分析出<strong>导致无法启动Linux根文件系统的原因是：TF卡设备树或者驱动出错。</strong>对于设备树来讲，我们只需要提供对应的硬件信息，即可在不同的开发板可以使用相同的驱动。形象一点讲就是：对某个LED点灯程序<strong>（驱动），</strong>我宏定义了一个LED管脚<strong>（设备树），</strong>程序是官方给的，也就是说确定这个程序可以点灯，现在我们将这套程序放到另一个相同主控的开发板上运行，出问题的话就很可能是我们的<strong>宏定义出错了</strong>，也就是说，<strong>很可能是设备树出错。</strong></p><p>通过上面的分析，<strong>我们怀疑很可能是设备树出了问题</strong>，那下面我们对设备树进行检查。首先介绍一下设备树相关文件，打开**&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts<strong>可以看到我们我们前面拷贝到TF卡KERNEL分区的设备树文件，</strong>其中.dtsi文件为“头文件”，储存一个主控芯片的共同信息，供针对相同主控芯片不同开发板的设备树源文件.dts文件调用，编译后生成设备树文件.dtb。**</p><img src="/posts/undefined/eb3e061a68c2eb42fd75840a44e71475.png" class="" title="img"><p>打开**&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts<strong>目录下的</strong>suniv-f1c100s-licheepi-nano.dts、suniv-f1c100s.dtsi<strong>，在dtsi文件中并</strong>没有发现mmc的内容，<strong>也就是如<a href="https://blog.csdn.net/weixin_43850980/article/details/125931067?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-125931067-blog-77833552.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-7-125931067-blog-77833552.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=9">orange2c</a>所说，是因为我们使用的</strong>主线Linux内核源码，<strong>而主线Linux设备树中并</strong>没有开启mmc。**</p><h3 id="6、mmc功能开启"><a href="#6、mmc功能开启" class="headerlink" title="6、mmc功能开启"></a>6、mmc功能开启</h3><p>参考荔枝派<a href="https://blog.csdn.net/u012577474/article/details/102855237">设备树源码，</a>进行以下修改。首先添加头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>然后在soc结点下的pio添加如下代码，其中<strong>PF0、PF1、PF2、PF3、PF4、PF5为TF卡相关引脚，</strong>详见<a href="https://blog.csdn.net/qq_41709234/article/details/124389957%E3%80%82">https://blog.csdn.net/qq_41709234/article/details/124389957。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>在soc结点下添加如下代码，使用<strong>pinctrl子系统</strong>初始化引脚，其中<strong>compatible变量</strong>保存着mmc对应的驱动。其他时钟总线之类的我就不详细解释了，因为我也不懂，哈哈。<strong>但是一定要注意，.dtsi文件里面是默认关闭mm功能的（可以看到下面的status是disabled状态），需要在.dts里面使能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">            interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">            pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">            pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status &#x3D; &quot;disabled&quot;;</span><br><span class="line">            #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">            #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p> <strong>.dtsi文件</strong>修改完成后如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: (GPL-2.0+ OR X11)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2018 Icenowy Zheng &lt;icenowy@aosc.io&gt;</span><br><span class="line"> * Copyright 2018 Mesih Kilinc &lt;mesihkilinc@gmail.com&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F; &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">interrupt-parent &#x3D; &lt;&amp;intc&gt;;</span><br><span class="line"></span><br><span class="line">clocks &#123;</span><br><span class="line">osc24M: clk-24M &#123;</span><br><span class="line">#clock-cells &#x3D; &lt;0&gt;;</span><br><span class="line">compatible &#x3D; &quot;fixed-clock&quot;;</span><br><span class="line">clock-frequency &#x3D; &lt;24000000&gt;;</span><br><span class="line">clock-output-names &#x3D; &quot;osc24M&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">osc32k: clk-32k &#123;</span><br><span class="line">#clock-cells &#x3D; &lt;0&gt;;</span><br><span class="line">compatible &#x3D; &quot;fixed-clock&quot;;</span><br><span class="line">clock-frequency &#x3D; &lt;32768&gt;;</span><br><span class="line">clock-output-names &#x3D; &quot;osc32k&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpus &#123;</span><br><span class="line">cpu &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,arm926ej-s&quot;;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">soc &#123;</span><br><span class="line">compatible &#x3D; &quot;simple-bus&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">sram-controller@1c00000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-system-control&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-system-control&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c00000 0x30&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">sram_d: sram@10000 &#123;</span><br><span class="line">compatible &#x3D; &quot;mmio-sram&quot;;</span><br><span class="line">reg &#x3D; &lt;0x00010000 0x1000&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges &#x3D; &lt;0 0x00010000 0x1000&gt;;</span><br><span class="line"></span><br><span class="line">otg_sram: sram-section@0 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-sram-d&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-sram-d&quot;;</span><br><span class="line">reg &#x3D; &lt;0x0000 0x1000&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ccu: clock@1c20000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-ccu&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20000 0x400&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;</span><br><span class="line">clock-names &#x3D; &quot;hosc&quot;, &quot;losc&quot;;</span><br><span class="line">#clock-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#reset-cells &#x3D; &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intc: interrupt-controller@1c20400 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-ic&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20400 0x400&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells &#x3D; &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pio: pinctrl@1c20800 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-pinctrl&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20800 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;38&gt;, &lt;39&gt;, &lt;40&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 37&gt;, &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;</span><br><span class="line">clock-names &#x3D; &quot;apb&quot;, &quot;hosc&quot;, &quot;losc&quot;;</span><br><span class="line">gpio-controller;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells &#x3D; &lt;3&gt;;</span><br><span class="line">#gpio-cells &#x3D; &lt;3&gt;;</span><br><span class="line"></span><br><span class="line">uart0_pe_pins: uart0-pe-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PE0&quot;, &quot;PE1&quot;;</span><br><span class="line">function &#x3D; &quot;uart0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer@1c20c00 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-timer&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20c00 0x90&gt;;</span><br><span class="line">interrupts &#x3D; &lt;13&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;osc24M&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">wdt: watchdog@1c20ca0 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-wdt&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-wdt&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20ca0 0x20&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart0: serial@1c25000 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25000 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;1&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 38&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 24&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart1: serial@1c25400 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25400 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;2&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 39&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 25&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart2: serial@1c25800 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25800 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;3&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 40&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 26&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">            interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">            pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">            pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status &#x3D; &quot;disabled&quot;;</span><br><span class="line">            #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">            #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 在**.dts文件<strong>里面进行以下修改，首先</strong>使能mmc：**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后这个是<strong>墨云****在根节点下</strong>添加的一个结点，他并没有说明为什么添加，我百度了一下，这是一个<strong>电源管理</strong>相关的结点，<strong>使用regulator-fixed来实现使用GPIO控制某个电源开关 ，</strong>希望在开机时尽快输出高低电平来控制电源。详见<a href="https://blog.csdn.net/weixin_43245753/article/details/125380619">。Rockchip RK3588 kernel dts解析之regulator-fixed</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>.dts文件修改完成之后下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: (GPL-2.0+ OR X11)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2018 Icenowy Zheng &lt;icenowy@aosc.io&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;dts-v1&#x2F;;</span><br><span class="line">#include &quot;suniv-f1c100s.dtsi&quot;</span><br><span class="line"></span><br><span class="line">&#x2F; &#123;</span><br><span class="line">model &#x3D; &quot;Lichee Pi Nano&quot;;</span><br><span class="line">compatible &#x3D; &quot;licheepi,licheepi-nano&quot;, &quot;allwinner,suniv-f1c100s&quot;;</span><br><span class="line"></span><br><span class="line">aliases &#123;</span><br><span class="line">serial0 &#x3D; &amp;uart0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">chosen &#123;</span><br><span class="line">stdout-path &#x3D; &quot;serial0:115200n8&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;uart0_pe_pins&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7、设备树编译与下载"><a href="#7、设备树编译与下载" class="headerlink" title="7、设备树编译与下载"></a>7、设备树编译与下载</h3><p>在Linux内核根目录下，使用以下命令重新编译设备树，内核无需重新编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make dtbs</span><br></pre></td></tr></table></figure><p>在内核源码根目录使用<strong>make dtbs</strong>编译变成后生成设备树文件，如下图所示。</p><img src="/posts/undefined/016df9392a916bc2589868fa1d114caf.png" class="" title="img"><p>编译完成后，将<strong>新的设备树文件（.dtb）</strong>拷贝到<strong>TF卡的第二分区，**zImage无需修改，*<em><strong>打开串口调试助手，上电复位，</strong>成功启动根文件系统！！！</em>*，成功打印出“Welcome to kashine linux system.”，</strong>root为管理员用户名，密码为前面设置的“good luck！”，**将路径切换到根目录之后，查看根目录的文件夹，如下图所示。</p><img src="/posts/undefined/639c6985e0ba0bdb02ef1502577c2783.png" class="" title="img"><p> 在上电成功启动根文件系统之后，不要直接拔掉USB断电，可能造成根文件系统损坏，使用<strong>poweroff命令****关闭根文件系统</strong>后断电。</p><img src="/posts/undefined/ce20f3dbc1e60e81a10ce5222c787027.png" class="" title="img"><h1 id="Debian系统"><a href="#Debian系统" class="headerlink" title="Debian系统"></a>Debian系统</h1><h2 id="一、Debian系统介绍"><a href="#一、Debian系统介绍" class="headerlink" title="一、Debian系统介绍"></a>一、Debian系统介绍</h2><p>Debian GNU&#x2F;Linux 是 Linux 操作系统的一个特定发行版，以及在其上运行的众多软件包。Debian项目由 Ian Murdock 于 1993 年发起，是在Linux发行版的概念还很新的时候获得广泛认可的首批自由软件项目之一。Debian 这个名字——发音为 deb-EE-uhn——是一个合成词，它混合了创建者的名字 Ian 和他妻子 Debra 的名字。</p><hr><h2 id="二、Linux发行版和Linux内核的关系"><a href="#二、Linux发行版和Linux内核的关系" class="headerlink" title="二、Linux发行版和Linux内核的关系"></a>二、Linux发行版和Linux内核的关系</h2><p>**内核：**位于应用软件和底层硬件系统之间。它直接与硬件通信，传递应用软件的任何请求。****一个简单的例子来说明这一点，就是在手机上录制视频。当你点击相机应用程序时，该软件将向内核传达它想要使用相机和麦克风的信息。然后，内核将通知摄像头和麦克风硬件唤醒并做好准备。那么现在，软件和硬件将协同工作，为你录制好视频。</p><p>**操作系统：**主要目的是管理系统进程和资源。它包含内核，因此执行内核可以执行的所有任务。****此外，它还确保系统保护和安全。操作系统充当用户和底层硬件系统之间的接口。所有应用程序都在操作系统创建的封闭环境中运行。因此，没有操作系统就无法使用系统。</p><p><strong>Linux 本身就是一个内核。然后，开发人员在其基础上进行构建，以提供当今可用的各种 Linux 发行版。</strong></p><hr><h2 id="三、Debian文件系统制作"><a href="#三、Debian文件系统制作" class="headerlink" title="三、Debian文件系统制作"></a>三、Debian文件系统制作</h2><blockquote><p>由于F1C200s的RAM只有64M，无法支持像是Ubuntu-Core这样的文件系统（最低RAM需求512M），所以一般只能用buildroot来生成简单的文件系统，或者裸机开发。</p><p>但是为了方便地使用Debian系的丰富软件，我们可以自己构建Debian最小系统，最小rootfs在180MB左右。</p><p><strong>– 稚辉君</strong></p></blockquote><h3 id="1、环境配置"><a href="#1、环境配置" class="headerlink" title="1、环境配置"></a>1、环境配置</h3><p>首先下载两个工具：<strong>qemu-arm-static和debootstrap。</strong></p><p><strong>🥝 qemu-arm-static：</strong>通过qemu-arm-static，我们在x86的Ubuntu PC机上，可以<strong>模拟ARM处理器，</strong>就像运行在ARM上一样进行各种操作。这样<strong>既实现了ARM环境，又利用了x86 PC的处理能力。</strong></p><p><strong>🥝 debootstrap：</strong>是Debian&#x2F;Ubuntu下的一个工具，<strong>用来构建一套基本的系统(根文件系统)。</strong>生成的目录符合Linux文件系统标准(FHS)，即包含了&#x2F;boot、&#x2F;etc、&#x2F;bin、&#x2F;usr等等目录，但<strong>它比发行版本的Linux体积小很多，</strong>当然功能也没那么强大，因此，只能说是“基本的系统”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install qemu-user-static -y</span><br><span class="line">sudo apt install debootstrap -y</span><br><span class="line">mkdir Debian_rootfs</span><br></pre></td></tr></table></figure><h3 id="2、Debian文件系统构建"><a href="#2、Debian文件系统构建" class="headerlink" title="2、Debian文件系统构建"></a>2、Debian文件系统构建</h3><p><strong>由于我们的Ubuntu是Linux系统，而开发板是ARM系统，在使用bootstrap为外部体系结构引导发行版时，才需要分开两个阶段。</strong>请参见<a href="http://linux.die.net/man/8/debootstrap">手册页</a>–foreign上的选项说明。</p><p>例如，使用x64机器为嵌入式ARM系统创建Debian安装系统。<strong>第一阶段</strong>将下载所需的.deb文件并将其解压缩到您指定的目录中。<strong>第二阶段</strong>解压运行所有程序包配置脚本，这些脚本必须使用<strong>目标体系结构或使用qemu-user-static模拟目标体系结构</strong>来完成，在此处我们使用<strong>qemu-user-static模拟ARM系统来完成</strong>。在完成两个阶段的配置后，还需要进入qemu模拟器进行一些<strong>必要配置。</strong></p><h4 id="🍟-第一阶段"><a href="#🍟-第一阶段" class="headerlink" title="🍟 第一阶段"></a><strong>🍟</strong> <strong>第一阶段</strong></h4><p>使用华为镜像源抽取根文件系统<strong>**（下载deb软件包）**，**命令如下，</strong>bootstrap<strong>命令详解见<a href="https://blog.csdn.net/talkxin/article/details/84075368">Bootstrap命令详解</a>。其中</strong>foreign<strong>表示若目标架构与本机架构不符时，需要携带该参数；</strong>arch<strong>代表架构，armhf (支持硬件浮点)、armel (软浮点)；</strong>verbose<strong>表示不打印wget等包下载数据，进行静默安装；</strong>buster**代表Debian发行版本代号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo debootstrap --foreign --verbose --arch&#x3D;armel  buster rootfs http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;debian&#x2F;</span><br></pre></td></tr></table></figure><p>其中，不同<strong>Debian发行版代号</strong>如下。命令执行完成后就是大家最常见的linux根文件系统，但是目前还不能直接使用，还需要对其做一些其他的配置。 </p><table><thead><tr><th><strong>版本号</strong></th><th><strong>代号</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td><strong>Debian 11</strong></td><td><strong>bullseye</strong></td><td><strong>稳定版</strong></td></tr><tr><td><strong>Debian 10</strong></td><td><strong>buster</strong></td><td><strong>旧稳定版</strong></td></tr><tr><td><strong>Debian 9</strong></td><td><strong>stretch</strong></td><td><strong>旧稳定版</strong></td></tr><tr><td><strong>Debian 8</strong></td><td><strong>jessie</strong></td><td><strong>已存档版</strong></td></tr><tr><td><strong>Debian 7</strong></td><td><strong>wheezy</strong></td><td><strong>被淘汰版</strong></td></tr><tr><td><strong>Debian 6</strong></td><td><strong>squeeze</strong></td><td><strong>被淘汰版</strong></td></tr><tr><td><strong>Debian 5</strong></td><td><strong>lenny</strong></td><td><strong>被淘汰版</strong></td></tr></tbody></table><p>至此,已经下载了<strong>最小的Debian系统,</strong> 你也可以将它想象为”最小系统”类似的存在,没有其他 “外设” 。下图是我补充的图片，所在文件夹名字和上面不同。</p><img src="/posts/undefined/08f88522f395f4d9428589319926c724.png" class="" title="img"><h4 id="🍟-第二阶段"><a href="#🍟-第二阶段" class="headerlink" title="🍟 第二阶段"></a><strong>🍟</strong> <strong>第二阶段</strong></h4><p>上面讲在第二阶段我们应该使用<strong>qemu-user-static模拟ARM系统</strong>运行所有程序包配置脚本，怎么模拟ARM系统呢？使用qemu这个虚拟机。简而言之，我们需要在<strong>qemu模拟出的ARM系统中执行一个Debian系统配置，</strong>相当于把Debian放到ARM开发板上配置。<strong>具体操作为：文件夹挂载 + chroot切换根目录。</strong></p><p><strong>1）文件挂载：</strong></p><p>首先对文件夹按照下面的命令进行挂载，这里<strong>为什么需要挂载呢？</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd rootfs</span><br><span class="line">sudo mount --bind &#x2F;dev dev&#x2F;</span><br><span class="line">sudo mount --bind &#x2F;sys sys&#x2F;</span><br><span class="line">sudo mount --bind &#x2F;proc proc&#x2F;</span><br><span class="line">sudo mount --bind &#x2F;dev&#x2F;pts dev&#x2F;pts&#x2F;</span><br></pre></td></tr></table></figure><p>我的理解是：因为在<strong>宿主（Ubuntu虚拟机）是x64架构</strong>，不能安装<strong>arm架构</strong>的软件，需要依靠<strong>qemu-arm-static</strong>来<strong>模拟成arm环境</strong>进行安装，而模拟arm环境相当于，以指定的某个目录为新的根目录，如果不更改挂载点，直接下载一些软件或者依赖项就会下载到原来的挂载点而出错。</p><p>通俗一点的理解：虽然更新了根目录，如果没有挂载新文件系统的&#x2F;dev等文件夹，如果再去操作&#x2F;dev，相当于还是在操作Ubuntu的&#x2F;dev，只有挂载了这个文件夹之后，再操作才相当于真正操作Debian新的根文件系统的&#x2F;dev。评论区讨论吧！欢迎指正！</p><p><strong>2）chroot切换根目录：</strong></p><p>chroot，即 change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以 &#x2F;，即以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为 &#x2F; 位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp &#x2F;usr&#x2F;bin&#x2F;qemu-arm-static  usr&#x2F;bin&#x2F;</span><br></pre></td></tr></table></figure><p>使用上面的命令将我们之前安装的<strong>qemu复制到&#x2F;rootfs&#x2F;usr&#x2F;bin目录下</strong>，可以看到我们具有该文件的<strong>读、写、可执行权限。</strong></p><img src="/posts/undefined/f20fa610319ba7b63d613e8a10a61c35.png" class="" title="img"><p>然后<strong>在Debian_rootfs目录下</strong>执行下面的命令，该命令意思是<strong>设置一些环境变量，</strong>并使用<strong>chroot命令将rootfs切换为新的根目录，</strong>执行目录<strong>rootfs&#x2F;debootstrap下的命令: debootstrap –second-stage，</strong>后面的是debootstrap可执行文件的两个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo LC_ALL&#x3D;C LANGUAGE&#x3D;C LANG&#x3D;C chroot rootfs &#x2F;debootstrap&#x2F;debootstrap --second-stage --verbose</span><br></pre></td></tr></table></figure><p><strong>该命令的主要作用是：对拉取的Debian根文件系统进行配置。</strong>这主要是由上面的–foreign选项决定的。这里是使用qemu-user-static模拟目标体系结构来完成的，因为我们使用的chroot更改了根目录，并挂载了新的文件系统的文件夹，相当于使用chroot命令+挂载，完成arm架构的模拟。</p><hr><h2 id="三、Debian文件系统配置"><a href="#三、Debian文件系统配置" class="headerlink" title="三、Debian文件系统配置"></a>三、Debian文件系统配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo LC_ALL&#x3D;C LANGUAGE&#x3D;C LANG&#x3D;C chroot rootfs</span><br></pre></td></tr></table></figure><p>使用上面的命令<strong>进入qemu虚拟器，</strong>相当于进入ARM系统下的Debian文件系统中，如下图所示。chroot rootfs 后面不加命令相当于执行chroot rootfs &#x2F;bin&#x2F;bash，也就是打开一个shell，详见<a href="https://www.cnblogs.com/sparkdev/p/8556075.html">chroot语法。</a></p><img src="/posts/undefined/8a2125e9f686eb426eb89f7f3557d165.png" class="" title="img"><h4 id="1、更新源"><a href="#1、更新源" class="headerlink" title="*1、更新源*"></a><em><strong>*1、更新源*</strong></em></h4><p>更新源为<strong>国内源</strong>可以提高后续软件下载速度，具体命令如下。因为默认的源是 http 的，但是如果准备使用的镜像源是https 的，所以需要额外的安装有关 HTTPS 的包。所以安装这两个包之后就可以正常拉取https的源了：<strong>apt-transport-https和ca-certificates。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">#写入： deb http:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;debian buster main</span><br><span class="line">apt-get update</span><br></pre></td></tr></table></figure><h4 id="2、安装网络相关库"><a href="#2、安装网络相关库" class="headerlink" title="*2、安装网络相关库*"></a><em><strong>*2、安装网络相关库*</strong></em></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apt-get install wpasupplicant #安装WIFI配置相关的组件</span><br><span class="line">apt-get install net-tools     #安装网络基础组件、如使用ifconfig等</span><br><span class="line">apt-get install udhcpc        #当wifi连接成功后，需要用这个组件去获取IP地址</span><br><span class="line"></span><br><span class="line">apt-get install evtest        #触摸屏测试</span><br><span class="line">apt-get install mplayer</span><br><span class="line">apt-get install alsa-utils    #音频测试</span><br><span class="line"></span><br><span class="line">## 其他组件</span><br><span class="line">apt-get install wireless-tools </span><br><span class="line">apt install sudo vim openssh-server htop</span><br><span class="line">apt install pciutils usbutils acpi #acpi我没有安装成功，换了其他的源也不可以</span><br></pre></td></tr></table></figure><h4 id="3、配置账号"><a href="#3、配置账号" class="headerlink" title="*3、配置账号*"></a><em><strong>*3、配置账号*</strong></em></h4><p>设置root账号密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br></pre></td></tr></table></figure><h4 id="4、配置时区"><a href="#4、配置时区" class="headerlink" title="*4、配置时区*"></a><em><strong>*4、配置时区*</strong></em></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure><h4 id="5、配置SSH"><a href="#5、配置SSH" class="headerlink" title="*5、配置SSH*"></a><em><strong>*5、配置SSH*</strong></em></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">#写入： PermitRootLogin yes</span><br></pre></td></tr></table></figure><h4 id="6、rootfs打包"><a href="#6、rootfs打包" class="headerlink" title="*6、rootfs打包*"></a><em><strong>*6、rootfs打包*</strong></em></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apt clean #清理</span><br><span class="line">exit #退出chroot</span><br><span class="line">rm rootfs&#x2F;usr&#x2F;bin&#x2F;qemu-arm-static #删除之前拷贝的文件</span><br><span class="line">cd rootfs</span><br><span class="line">sudo umount   dev&#x2F;pts&#x2F; # 一定要在&#x2F;dev前面umount</span><br><span class="line">sudo umount   dev&#x2F;</span><br><span class="line">sudo umount   sys&#x2F;</span><br><span class="line">sudo umount   proc&#x2F;</span><br><span class="line">sudo tar cvf ..&#x2F;rootfs.tar .&#x2F; #在rootfs目录下执行</span><br></pre></td></tr></table></figure><p>最终生成了Debian文件系统压缩包，解压即可使用。</p><h4 id="7、Debian文件系统启动"><a href="#7、Debian文件系统启动" class="headerlink" title="*7、Debian文件系统启动*"></a><em><strong>*7、Debian文件系统启动*</strong></em></h4><p>在<strong>rootfs.tar文件</strong>目录终端中，输入以下命令解压到TF卡的rootfs分区，也就是第二分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -vxf .&#x2F;rootfs.tar -C &#x2F;media&#x2F;project01&#x2F;rootfs&#x2F;</span><br></pre></td></tr></table></figure><p><strong>注意：一定要等待拷贝完成，再拔出TF卡，</strong>我的转接器上有指示灯，等待指示灯常亮，不再闪烁即可拔出。将TF卡插到开发板上，上电启动复位，等待，启动成功！！！</p><img src="/posts/undefined/c883c629eea516375bfbf77afe890d80.png" class="" title="img"><hr><h2 id="四、增加swap分区"><a href="#四、增加swap分区" class="headerlink" title="四、增加swap分区"></a>四、增加swap分区</h2><blockquote><p>芯片的SiP内存只有64MB，大部分情况下都不够用，所以需要开启swap使用内存卡的一部分空间来作为交换内存。</p></blockquote><blockquote><p>在使用一些软件的过程中，会遇到系统崩溃，尤其是使用 apt-get install 的时候，所以需要加入swap分区，可以简单理解为虚拟内存。</p></blockquote><p>这十分类似于Windows的虚拟内存，<strong>虚拟内存</strong>其实就是<strong>将硬盘的一部分容量当内存使用</strong>，从而弥补物理内存不足的问题。</p><p>我们可以通过<strong>free -m</strong>来查看下<strong>内存使用状况，</strong>此处我直接在qemu虚拟器中查看：</p><img src="/posts/undefined/06cc1d8987eed57e16072098dd76046d.png" class="" title="img"><p> 使用如下命令创建你想要添加swap分区的大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;swap1 bs&#x3D;1M count&#x3D;512  #count是SWAP大小，512就是512MB</span><br></pre></td></tr></table></figure><p>设置swap分区文件，然后激活分区：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 设置分区文件</span><br><span class="line">mkswap &#x2F;swap1</span><br><span class="line"># 激活swap分区</span><br><span class="line">swapon &#x2F;swap1</span><br><span class="line">vi &#x2F;etc&#x2F;fstab</span><br><span class="line"># 最后一行添加 </span><br><span class="line"># &#x2F;swap1 swap swap defaults 0 0</span><br></pre></td></tr></table></figure><p> 将新的根文件系统拷贝到TF卡的第二分区，重新上电启动，查看交换分区大小，的确为我们设置的512M。</p><img src="/posts/undefined/a5b1c2ac211d085037cc50e947161494.png" class="" title="img"><h1 id="正点原子4-3寸RGB屏幕驱动"><a href="#正点原子4-3寸RGB屏幕驱动" class="headerlink" title="正点原子4.3寸RGB屏幕驱动"></a>正点原子4.3寸RGB屏幕驱动</h1><h2 id="一、RGB屏幕介绍"><a href="#一、RGB屏幕介绍" class="headerlink" title="一、RGB屏幕介绍"></a>一、RGB屏幕介绍</h2><p>正点原子ATK4384<strong>显示屏，</strong>分辨率<strong>800*480，</strong>支持RGB接口，详细资料下载地址为：<a href="http://47.111.11.73/docs/modules/lcd/4.3-RGBLCD-800480.html">4.3寸RGBLCD电容触摸屏800*480</a>。RGB LCD接口信号线如下所示：</p><table><thead><tr><th><strong>信号线</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>R[7:0]</strong></td><td><strong>数据线</strong></td></tr><tr><td><strong>G[7:0]</strong></td><td><strong>数据线</strong></td></tr><tr><td><strong>B[7:0]</strong></td><td><strong>数据线</strong></td></tr><tr><td><strong>DE</strong></td><td><strong>数据使能线</strong></td></tr><tr><td><strong>VSYNC</strong></td><td><strong>垂直同步信号线</strong></td></tr><tr><td><strong>HSYNC</strong></td><td><strong>水平同步信号线</strong></td></tr><tr><td><strong>PCLK</strong></td><td><strong>像素钟信号线</strong></td></tr></tbody></table><p>屏幕的参数如下所示，其中<strong>各参数的含义</strong>详见<a href="https://blog.csdn.net/Richard_LiuJH/article/details/46352857">这篇博客</a>，解释的比较详细，我就不再重复造轮子了。</p><table><thead><tr><th><strong>参数</strong></th><th><strong>值</strong></th><th><strong>单位</strong></th></tr></thead><tbody><tr><td><strong>水平显示区域</strong></td><td><strong>800</strong></td><td><strong>每时钟 (tCLK)</strong></td></tr><tr><td><strong>HSPW (thp)</strong></td><td><strong>48</strong></td><td><strong>每时钟 (tCLK)</strong></td></tr><tr><td><strong>HBP (thb)</strong></td><td><strong>88</strong></td><td><strong>每时钟 (tCLK)</strong></td></tr><tr><td><strong>HFP (thf)</strong></td><td><strong>40</strong></td><td><strong>每时钟 (tCLK)</strong></td></tr><tr><td><strong>垂直显示区域</strong></td><td><strong>480</strong></td><td><strong>每行 (th)</strong></td></tr><tr><td><strong>VSPW (tvp)</strong></td><td><strong>3个</strong></td><td><strong>每行 (th)</strong></td></tr><tr><td><strong>VBP (tvb)</strong></td><td><strong>32</strong></td><td><strong>每行 (th)</strong></td></tr><tr><td><strong>VFP (tvf)</strong></td><td><strong>13</strong></td><td><strong>每行 (th)</strong></td></tr></tbody></table><p>我的板子上存在两个屏幕接口， 1.14寸ips屏幕、ATK4384的40pinrgb屏幕，由于1.14寸屏幕实在是太小了，因此，本系统使用的<strong>40PinRGB屏幕接口</strong>如图所示。由下面的硬件原理图可以看出我们采用的屏<strong>**数据格式是RGB666**，**当然，</strong>I2C接口<strong>用作</strong>触摸屏数据传输**，本文暂时用不到。</p><img src="/posts/undefined/3a3c60956eda74885ee7511e2e863906.png" class="" title="img"><hr><h2 id="二、RGB屏幕驱动"><a href="#二、RGB屏幕驱动" class="headerlink" title="二、RGB屏幕驱动"></a>二、RGB屏幕驱动</h2><p>linux内核<strong>已经配备</strong>了RGB模式下的LCD驱动<strong>（见drivers&#x2F;gpu&#x2F;drm&#x2F;panel&#x2F;panel-simple.c，也就是DRM驱动）</strong>，而我们的F1C200s支持RGB模式的LCD，我们<strong>不需要从零写一个屏幕驱动，</strong>我们只需要简单几步即可驱动LCD屏幕。F1C200s虽然不像IMX6ULL那样配备eLCDIF接口，但只需要符合RGB接口的时序即可点亮。</p><p><strong>注意：内核配置文件和之前相同！</strong></p><h3 id="1、设备树修改"><a href="#1、设备树修改" class="headerlink" title="1、设备树修改"></a>1、设备树修改</h3><p><strong>.dtsi文件</strong>中做以下修改，代码修改处添加了<strong>modify by kashine</strong>的标注。其中，加入reset和clock两个文件夹下的<strong>suniv-ccu-f1c100s.h文件</strong>，是为了<strong>提供一些宏定义</strong>；<strong>设备树de结点</strong>是display engine驱动初始化结点，官方解释为：<strong>Allwinner A10 Display Engine DRM&#x2F;KMS Driver，</strong>关于DRM驱动的知识，这里不在赘述；<strong>tcon0结点</strong>对应<strong>时序控制驱动</strong>，官方解释为：<strong>Allwinner A10 Timing Controller Driver</strong>；pio结点中加入RGB屏幕的管脚信息；<strong>fe0结点和be0结点</strong>为RGB显示的前后端驱动程序；<strong>pwm结点</strong>用于背光显示，亮度调节。</p><p>我们来详细分析一下代码中的各个部分。</p><ol><li>display-engine：描述了显示引擎，这是 F1C100s 处理器中的一个重要组件，用于处理图像数据。它与显示前端（display-frontend）和显示后端（display-backend），相连接包含一条pipeline fe0。</li><li>tcon0：代表了时序控制器（Timing Controller，简称 TCON），它负责生成正确的时序信号，以驱动显示面板。这部分代码中，我们可以看到 TCON 的寄存器地址、中断号、时钟和复位信号等信息。此外，还定义了输入和输出端口，分别连接到显示后端和显示面板。</li><li>lcd_rgb666_pins：定义了与 RGB 屏幕连接的引脚，这里使用了 18 位的 RGB666 接口。</li><li>display-frontend 和 display-backend：显示前端和显示后端分别负责图像数据的预处理和后处理。显示前端接收原始图像数据，对其进行缩放、色彩空间转换等操作；显示后端则负责图像数据的合成、alpha 混合等功能。这两个部分通过端口和端点（endpoint）进行连接。</li><li>panel：描述了显示面板，定义了使用的LCD panel参数。这里使用了一个兼容于 “alientek,alientek_4p3_inch” 和 “simple-panel” 的面板。面板的输入端口与 TCON 的输出端口相连接。</li><li>reg_vcc3v3：描述了一个固定电压的电源，为面板提供 3.3V 电源。</li></ol><p>最后，在设备树末尾，启用了 be0（显示后端）、de（显示引擎）和 tcon0（时序控制器）节点。</p><p>从这段代码中可以看出，该 RGB 屏幕驱动确实使用了 DRM 框架。其工作原理大致如下：</p><ol><li>显示前端接收原始图像数据，进行预处理。</li><li>处理后的图像数据传递给显示后端，进行后处理和合成。</li><li>处理后的图像数据通过 TCON 生成正确的时序信号，驱动显示面板。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: (GPL-2.0+ OR X11)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2018 Icenowy Zheng &lt;icenowy@aosc.io&gt;</span><br><span class="line"> * Copyright 2018 Mesih Kilinc &lt;mesihkilinc@gmail.com&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;&#x2F;&#x2F; 下面引用该文件中的一些宏定义</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F; &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">interrupt-parent &#x3D; &lt;&amp;intc&gt;;</span><br><span class="line"></span><br><span class="line">clocks &#123;</span><br><span class="line">osc24M: clk-24M &#123;</span><br><span class="line">#clock-cells &#x3D; &lt;0&gt;;</span><br><span class="line">compatible &#x3D; &quot;fixed-clock&quot;;</span><br><span class="line">clock-frequency &#x3D; &lt;24000000&gt;;</span><br><span class="line">clock-output-names &#x3D; &quot;osc24M&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">osc32k: clk-32k &#123;</span><br><span class="line">#clock-cells &#x3D; &lt;0&gt;;</span><br><span class="line">compatible &#x3D; &quot;fixed-clock&quot;;</span><br><span class="line">clock-frequency &#x3D; &lt;32768&gt;;</span><br><span class="line">clock-output-names &#x3D; &quot;osc32k&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cpus &#123;</span><br><span class="line">cpu &#123;</span><br><span class="line">compatible &#x3D; &quot;arm,arm926ej-s&quot;;</span><br><span class="line">device_type &#x3D; &quot;cpu&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">de: display-engine &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-display-engine&quot;;</span><br><span class="line">allwinner,pipelines &#x3D; &lt;&amp;fe0&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">soc &#123;</span><br><span class="line">compatible &#x3D; &quot;simple-bus&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">sram-controller@1c00000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-system-control&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-system-control&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c00000 0x30&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges;</span><br><span class="line"></span><br><span class="line">sram_d: sram@10000 &#123;</span><br><span class="line">compatible &#x3D; &quot;mmio-sram&quot;;</span><br><span class="line">reg &#x3D; &lt;0x00010000 0x1000&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;1&gt;;</span><br><span class="line">ranges &#x3D; &lt;0 0x00010000 0x1000&gt;;</span><br><span class="line"></span><br><span class="line">otg_sram: sram-section@0 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-sram-d&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-sram-d&quot;;</span><br><span class="line">reg &#x3D; &lt;0x0000 0x1000&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">tcon0: lcd-controller@1c0c000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-tcon&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c0c000 0x1000&gt;;</span><br><span class="line">interrupts &#x3D; &lt;29&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_LCD&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_TCON&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">      &quot;tcon-ch0&quot;;</span><br><span class="line">clock-output-names &#x3D; &quot;tcon-pixel-clock&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_LCD&gt;;</span><br><span class="line">reset-names &#x3D; &quot;lcd&quot;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line"></span><br><span class="line">ports &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">tcon0_in: port@0 &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">tcon0_in_be0: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;be0_out_tcon0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tcon0_out: port@1 &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reg &#x3D; &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ccu: clock@1c20000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-ccu&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20000 0x400&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;</span><br><span class="line">clock-names &#x3D; &quot;hosc&quot;, &quot;losc&quot;;</span><br><span class="line">#clock-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#reset-cells &#x3D; &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">intc: interrupt-controller@1c20400 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-ic&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20400 0x400&gt;;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells &#x3D; &lt;1&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pio: pinctrl@1c20800 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-pinctrl&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20800 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;38&gt;, &lt;39&gt;, &lt;40&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 37&gt;, &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;</span><br><span class="line">clock-names &#x3D; &quot;apb&quot;, &quot;hosc&quot;, &quot;losc&quot;;</span><br><span class="line">gpio-controller;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells &#x3D; &lt;3&gt;;</span><br><span class="line">#gpio-cells &#x3D; &lt;3&gt;;</span><br><span class="line"></span><br><span class="line">uart0_pe_pins: uart0-pe-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PE0&quot;, &quot;PE1&quot;;</span><br><span class="line">function &#x3D; &quot;uart0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">lcd_rgb666_pins: lcd-rgb666-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PD0&quot;, &quot;PD1&quot;, &quot;PD2&quot;, &quot;PD3&quot;, &quot;PD4&quot;,</span><br><span class="line">       &quot;PD5&quot;, &quot;PD6&quot;, &quot;PD7&quot;, &quot;PD8&quot;, &quot;PD9&quot;,</span><br><span class="line">       &quot;PD10&quot;, &quot;PD11&quot;, &quot;PD12&quot;, &quot;PD13&quot;, &quot;PD14&quot;,</span><br><span class="line">       &quot;PD15&quot;, &quot;PD16&quot;, &quot;PD17&quot;, &quot;PD18&quot;, &quot;PD19&quot;,</span><br><span class="line">       &quot;PD20&quot;, &quot;PD21&quot;;</span><br><span class="line">function &#x3D; &quot;lcd&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">timer@1c20c00 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-timer&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20c00 0x90&gt;;</span><br><span class="line">interrupts &#x3D; &lt;13&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;osc24M&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">wdt: watchdog@1c20ca0 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-wdt&quot;,</span><br><span class="line">     &quot;allwinner,sun4i-a10-wdt&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20ca0 0x20&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart0: serial@1c25000 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25000 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;1&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 38&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 24&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart1: serial@1c25400 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25400 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;2&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 39&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 25&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">uart2: serial@1c25800 &#123;</span><br><span class="line">compatible &#x3D; &quot;snps,dw-apb-uart&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c25800 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;3&gt;;</span><br><span class="line">reg-shift &#x3D; &lt;2&gt;;</span><br><span class="line">reg-io-width &#x3D; &lt;4&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 40&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu 26&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">      &quot;mmc&quot;,</span><br><span class="line">      &quot;output&quot;,</span><br><span class="line">      &quot;sample&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">fe0: display-frontend@1e00000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-display-frontend&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01e00000 0x20000&gt;;</span><br><span class="line">interrupts &#x3D; &lt;30&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_DE_FE&gt;, &lt;&amp;ccu CLK_DE_FE&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_DRAM_DE_FE&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;, &quot;mod&quot;,</span><br><span class="line">      &quot;ram&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_DE_FE&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line"></span><br><span class="line">ports &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">fe0_out: port@1 &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reg &#x3D; &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">fe0_out_be0: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;be0_in_fe0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">be0: display-backend@1e60000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-display-backend&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01e60000 0x10000&gt;;</span><br><span class="line">reg-names &#x3D; &quot;be&quot;;</span><br><span class="line">interrupts &#x3D; &lt;31&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_DE_BE&gt;, &lt;&amp;ccu CLK_DE_BE&gt;,</span><br><span class="line"> &lt;&amp;ccu CLK_DRAM_DE_BE&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;, &quot;mod&quot;,</span><br><span class="line">      &quot;ram&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_DE_BE&gt;;</span><br><span class="line">reset-names &#x3D; &quot;be&quot;;</span><br><span class="line">assigned-clocks &#x3D; &lt;&amp;ccu CLK_DE_BE&gt;;</span><br><span class="line">assigned-clock-rates &#x3D; &lt;300000000&gt;;</span><br><span class="line"></span><br><span class="line">ports &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">be0_in: port@0 &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line">be0_in_fe0: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;fe0_out_be0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">be0_out: port@1 &#123;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reg &#x3D; &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">be0_out_tcon0: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;tcon0_in_be0&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">pwm: pwm@1c21000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,sun4i-a10-pwm&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01C21000 0x08&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;osc24M&gt;;</span><br><span class="line">#pwm-cells &#x3D; &lt;3&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>.dts文件</strong>做以下修改，添加了一个<strong>panel面板设备结点，</strong>对应4.3寸RGB屏幕，其compatible属性对应指定的显示驱动，我们将在后面提到；添加了<strong>backlight背光调节结点，</strong>设置了不同的背光等级；然后打开或修改了.dtsi文件中结点的功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; SPDX-License-Identifier: (GPL-2.0+ OR X11)</span><br><span class="line">&#x2F;*</span><br><span class="line"> * Copyright 2018 Icenowy Zheng &lt;icenowy@aosc.io&gt;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;dts-v1&#x2F;;</span><br><span class="line">#include &quot;suniv-f1c100s.dtsi&quot;</span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">#include &lt;dt-bindings&#x2F;gpio&#x2F;gpio.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;input&#x2F;input.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;interrupt-controller&#x2F;irq.h&gt;</span><br><span class="line"></span><br><span class="line">&#x2F; &#123;</span><br><span class="line">model &#x3D; &quot;Lichee Pi Nano&quot;;</span><br><span class="line">compatible &#x3D; &quot;licheepi,licheepi-nano&quot;, &quot;allwinner,suniv-f1c100s&quot;;</span><br><span class="line"></span><br><span class="line">aliases &#123;</span><br><span class="line">serial0 &#x3D; &amp;uart0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">chosen &#123;</span><br><span class="line">stdout-path &#x3D; &quot;serial0:115200n8&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine </span><br><span class="line">panel: panel &#123;&#x2F;&#x2F;ampire_am800480r3tmqwa1h_mode</span><br><span class="line">compatible &#x3D; &quot;alientek,alientek_4p3_inch&quot;, &quot;simple-panel&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">reset-gpios &#x3D; &lt;&amp;pio 4 4 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">power-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">&#x2F;&#x2F;backlight &#x3D; &lt;&amp;backlight&gt;;</span><br><span class="line"> port@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line"></span><br><span class="line"> panel_input: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;tcon0_out_lcd&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">backlight: backlight &#123;</span><br><span class="line">compatible &#x3D; &quot;pwm-backlight&quot;;</span><br><span class="line">pwms &#x3D; &lt;&amp;pwm 1 500000 0&gt;;</span><br><span class="line">pwm-names &#x3D; &quot;backlight&quot;;</span><br><span class="line"></span><br><span class="line">brightness-levels &#x3D; &lt;0 4 8 16 32 64 128 255&gt;;</span><br><span class="line">default-brightness-level &#x3D; &lt;7&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;uart0_pe_pins&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine all down</span><br><span class="line">&amp;mmc0 &#123;</span><br><span class="line">vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">broken-cd;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;be0 &#123;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;de &#123;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;tcon0 &#123;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;lcd_rgb666_pins&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;tcon0_out &#123;</span><br><span class="line">tcon0_out_lcd: endpoint@0 &#123;</span><br><span class="line">reg &#x3D; &lt;0&gt;;</span><br><span class="line">remote-endpoint &#x3D; &lt;&amp;panel_input&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;pio &#123;</span><br><span class="line">pwm1_pin: pwm1_pin &#123;</span><br><span class="line">pins &#x3D; &quot;PE6&quot;;</span><br><span class="line">function &#x3D; &quot;pwm1&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;pwm &#123;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;pwm1_pin&gt;;</span><br><span class="line">status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、屏幕信息添加"><a href="#2、屏幕信息添加" class="headerlink" title="2、屏幕信息添加"></a>2、屏幕信息添加</h3><p>本文使用<strong>正点原子40Pin RGB 屏幕，分辨率为800*480，</strong>根据正点原子提供的资料，在内核目录**&#x2F;drivers&#x2F;gpu&#x2F;drm&#x2F;panel&#x2F;panel_simple.c<strong>中，填写屏幕</strong>时序信息**如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">static const struct drm_display_mode alientek_4p3_inch_mode &#x3D; &#123;</span><br><span class="line">.clock &#x3D; 31000,</span><br><span class="line">.hdisplay &#x3D; 800,</span><br><span class="line">.hsync_start &#x3D; 800 + 40,</span><br><span class="line">.hsync_end &#x3D; 800 + 40 + 48,</span><br><span class="line">.htotal &#x3D; 800 + 40 + 48 + 88,</span><br><span class="line">.vdisplay &#x3D; 480,</span><br><span class="line">.vsync_start &#x3D; 480 + 13,</span><br><span class="line">.vsync_end &#x3D; 480 + 13 + 3,</span><br><span class="line">.vtotal &#x3D; 480 + 13 + 3 + 32,</span><br><span class="line">.vrefresh &#x3D; 60,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct panel_desc alientek_4p3_inch &#x3D; &#123;</span><br><span class="line">.modes &#x3D; &amp;alientek_4p3_inch_mode,</span><br><span class="line">.num_modes &#x3D; 1,</span><br><span class="line">.bpc &#x3D; 6,</span><br><span class="line">.size &#x3D; &#123;</span><br><span class="line">.width &#x3D; 154,</span><br><span class="line">.height &#x3D; 85,</span><br><span class="line">&#125;,</span><br><span class="line">.bus_format &#x3D; MEDIA_BUS_FMT_RGB666_1X18,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先来解释<strong>alientek_4p3_inch_mode结构体</strong>中的<strong>参数含义</strong>，主要为<strong>屏幕的时序信息</strong>，设置错误可能导致显示错位、不完整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clock： RGB屏幕需要使用的时钟频率</span><br><span class="line">hdisplay：有效显示区水平像素数量，800*480中的800，对应Active Width</span><br><span class="line">hsync_start：水平同步开始，对应hdispay + HFP</span><br><span class="line">hsync_end：水平同步结束，对应hdisplay + HFP + HSYNC width(HSPW)</span><br><span class="line">htotal：水平总像素，对应hdisplay + HFP + HSYNC width + HBP</span><br><span class="line"></span><br><span class="line">vdisplay：垂直显示像素，800*480中的480，对应Active Height</span><br><span class="line">vsync_start：垂直同步开始，对应vdispay + VFP</span><br><span class="line">vsync_end：垂直像素结束，对应vdisplay + VFP + VSYNC width(VSPW)</span><br><span class="line">vtotal：垂直总像素，对应vdisplay + VFP + VSYNC width + VBP</span><br><span class="line"></span><br><span class="line">vrefresh：刷新率</span><br><span class="line"></span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;u012794472&#x2F;article&#x2F;details&#x2F;124868025</span><br></pre></td></tr></table></figure><p><strong>alientek_4p3_inch结构体</strong>主要用来描述所用屏幕的信息，包括<strong>显示模式、像素格式等。</strong>其中<strong>MEDIA_BUS_FMT_RGB666_1X18</strong>的含义详见<a href="https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/subdev-formats.html?highlight=media_bus_fmt_uyvy8_2x8">The Linux Kernel documentation</a>。<strong>width、height为液晶的尺寸，</strong>需要根据屏幕的用户<strong>使用手册</strong>进行设置，如下图所示为本文使用的ATK4384屏幕尺寸图。</p><img src="/posts/undefined/1b4c1bc5fa42ef9c8a7a396ed065a7cb.png" class="" title="img"><p>另一处需要修改的地方如下所示，添加设备树对应的<strong>设备驱动绑定信息。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.data &#x3D; &amp;vl050_8048nt_c01,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">.compatible &#x3D; &quot;winstar,wf35ltiacd&quot;,</span><br><span class="line">.data &#x3D; &amp;winstar_wf35ltiacd,</span><br><span class="line">&#125;, &#123;&#x2F;&#x2F; modify by kashine</span><br><span class="line">.compatible &#x3D; &quot;alientek,alientek_4p3_inch&quot;,</span><br><span class="line">.data &#x3D; &amp;alientek_4p3_inch,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">&#x2F;* Must be the last entry *&#x2F;</span><br><span class="line">.compatible &#x3D; &quot;panel-dpi&quot;,</span><br><span class="line">.data &#x3D; &amp;panel_dpi,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">&#x2F;* sentinel *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、内核驱动修改"><a href="#3、内核驱动修改" class="headerlink" title="3、内核驱动修改"></a>3、内核驱动修改</h3><p>以下为核心内容，本人尝试了<strong>坑网、CSDN、荔枝派、芒果派</strong>等的众多教程，历经多次内核修改与编译，最终整理出<strong>关于F1C200s在**Linux5.7.1内核**下的RGB驱动修改方法**如下。主要修改文件为内核目录</strong>&#x2F;drivers&#x2F;gpu&#x2F;drm&#x2F;sun4i&#x2F;<strong>文件夹下的三个文件，分别为</strong>sun4i_tcon.c、sun4i_drv.c、sun4i_backend.c。**以下修改内容主要是为了使驱动适配F1C200s这款芯片。</p><p><strong>可以根据代码中注释及前后内容，定位三个文件需要修改的地方。</strong></p><p><strong>&#x2F;&#x2F; sun4i_backend.c文件修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kashine </span><br><span class="line">static const struct sun4i_backend_quirks suniv_backend_quirks &#x3D; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun4i_backend_quirks &#x3D; &#123;</span><br><span class="line">.needs_output_muxing &#x3D; true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun5i_backend_quirks &#x3D; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun6i_backend_quirks &#x3D; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun7i_backend_quirks &#x3D; &#123;</span><br><span class="line">.needs_output_muxing &#x3D; true,</span><br><span class="line">.supports_lowest_plane_alpha &#x3D; true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun8i_a33_backend_quirks &#x3D; &#123;</span><br><span class="line">.supports_lowest_plane_alpha &#x3D; true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_backend_quirks sun9i_backend_quirks &#x3D; &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct of_device_id sun4i_backend_of_table[] &#x3D; &#123;</span><br><span class="line">&#123;&#x2F;&#x2F; modify by kashine</span><br><span class="line">.compatible &#x3D; &quot;allwinner,suniv-f1c100s-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;suniv_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun4i-a10-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun4i_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun5i-a13-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun5i_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun6i-a31-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun6i_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun7i-a20-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun7i_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun8i-a23-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun8i_a33_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun8i-a33-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun8i_a33_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.compatible &#x3D; &quot;allwinner,sun9i-a80-display-backend&quot;,</span><br><span class="line">.data &#x3D; &amp;sun9i_backend_quirks,</span><br><span class="line">&#125;,</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F; sun4i_drv.c文件修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static bool sun4i_drv_node_is_frontend(struct device_node *node)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">return of_device_is_compatible(node, &quot;allwinner,suniv-f1c100s-display-frontend&quot;) ||</span><br><span class="line">    of_device_is_compatible(node, &quot;allwinner,sun4i-a10-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun5i-a13-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun6i-a31-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun7i-a20-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun8i-a23-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun8i-a33-display-frontend&quot;) ||</span><br><span class="line">of_device_is_compatible(node, &quot;allwinner,sun9i-a80-display-frontend&quot;);</span><br><span class="line">&#125;</span><br><span class="line">static const struct of_device_id sun4i_drv_of_table[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,suniv-f1c100s-display-engine&quot; &#125;,&#x2F;&#x2F; modify by kashine</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun4i-a10-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun5i-a10s-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun5i-a13-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31s-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun7i-a20-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a23-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a33-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a83t-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-h3-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-r40-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-v3s-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun9i-a80-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun50i-a64-display-engine&quot; &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun50i-h6-display-engine&quot; &#125;,</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> <strong>&#x2F;&#x2F; sun4i_tcon.c文件修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">static const struct sun4i_tcon_quirks suniv_f1c100s_quirks &#x3D; &#123;</span><br><span class="line">&#x2F;*</span><br><span class="line"> * The F1C100s SoC has a second channel in TCON, but the clock input of</span><br><span class="line"> * it is not documented.</span><br><span class="line"> *&#x2F;</span><br><span class="line">.has_channel_0&#x3D; true,</span><br><span class="line">&#x2F;&#x2F;.has_channel_1&#x3D; true,</span><br><span class="line">.dclk_min_div&#x3D; 1,&#x2F;&#x2F; Linux5.2不需要加，5.7.1不加该代码会白屏</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct sun4i_tcon_quirks sun4i_a10_quirks &#x3D; &#123;</span><br><span class="line">.has_channel_0&#x3D; true,</span><br><span class="line">.has_channel_1&#x3D; true,</span><br><span class="line">.dclk_min_div&#x3D; 4,</span><br><span class="line">.set_mux&#x3D; sun4i_a10_tcon_set_mux,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;* sun4i_drv uses this list to check if a device node is a TCON *&#x2F;</span><br><span class="line">const struct of_device_id sun4i_tcon_of_table[] &#x3D; &#123;</span><br><span class="line">&#123;.compatible &#x3D; &quot;allwinner,suniv-f1c100s-tcon&quot;, .data &#x3D; &amp;suniv_f1c100s_quirks &#125;,&#x2F;&#x2F; modify by kashine</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun4i-a10-tcon&quot;, .data &#x3D; &amp;sun4i_a10_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun5i-a13-tcon&quot;, .data &#x3D; &amp;sun5i_a13_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31-tcon&quot;, .data &#x3D; &amp;sun6i_a31_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31s-tcon&quot;, .data &#x3D; &amp;sun6i_a31s_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun7i-a20-tcon&quot;, .data &#x3D; &amp;sun7i_a20_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun7i-a20-tcon0&quot;, .data &#x3D; &amp;sun7i_a20_tcon0_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun7i-a20-tcon1&quot;, .data &#x3D; &amp;sun7i_a20_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a23-tcon&quot;, .data &#x3D; &amp;sun8i_a33_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a33-tcon&quot;, .data &#x3D; &amp;sun8i_a33_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a83t-tcon-lcd&quot;, .data &#x3D; &amp;sun8i_a83t_lcd_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a83t-tcon-tv&quot;, .data &#x3D; &amp;sun8i_a83t_tv_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-r40-tcon-tv&quot;, .data &#x3D; &amp;sun8i_r40_tv_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-v3s-tcon&quot;, .data &#x3D; &amp;sun8i_v3s_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun9i-a80-tcon-lcd&quot;, .data &#x3D; &amp;sun9i_a80_tcon_lcd_quirks &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun9i-a80-tcon-tv&quot;, .data &#x3D; &amp;sun9i_a80_tcon_tv_quirks &#125;,</span><br><span class="line">&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="4、开机logo显示"><a href="#4、开机logo显示" class="headerlink" title="4、开机logo显示"></a>4、开机logo显示</h3><p>使用<strong>make menuconfig</strong>打开图形化配置界面，打开Bootup logo，其中的<strong>三个选项全部选中。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Device Drivers</span><br><span class="line"> -&gt; Graphics support </span><br><span class="line"> -&gt; Bootup logo (LOGO [&#x3D;y]) </span><br><span class="line"> -&gt; Standard black and white Linux logo </span><br><span class="line"> -&gt; Standard 16-color Linux logo </span><br><span class="line"> -&gt; Standard 224-color Linux logo</span><br></pre></td></tr></table></figure><img src="/posts/undefined/74b3b4970c6753717f3bb64136e14546.png" class="" title="img"><p><strong>背光选项</strong>记得勾上（其实不勾也可以）。</p><img src="/posts/undefined/4ba183fcb645e81a0055b540cdbd00e8.png" class="" title="img"><hr><h2 id="三、RGB屏幕显示功能测试"><a href="#三、RGB屏幕显示功能测试" class="headerlink" title="三、RGB屏幕显示功能测试"></a>三、RGB屏幕显示功能测试</h2><p>修改完上述内核文件后，<strong>重新编译，</strong>编译所需的时间相比于初次编译要短很多。在uboot的<strong>bootargs参数</strong>中添加如下内容****可使内核输出更多drm相关信息，****便于调试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drm.debug&#x3D;0x1f debug</span><br></pre></td></tr></table></figure><p>如图所示为开发板<strong>上电启动</strong>过程中<strong>RGB屏幕显示的内容，</strong>启动时左上角<strong>显示Linux logo，</strong>符合我们的预期。</p><img src="/posts/undefined/40078685723141a92e1f0690baad9ec0.jpeg" class="" title="img"><img src="/posts/undefined/e7ce14f948df141a0cf540516d52c95a.jpeg" class="" title="img"><img src="/posts/undefined/b6b9a37ad3171b4367a49ad6e24b5767.jpeg" class="" title="img"><p>进入Debian文件系统后，可以使用如下命令<strong>查看日志的输出级别</strong>（在Linux中日志一共分为8个等级，数值越小，优先级越高）下面的四个数字是由<strong>kernel&#x2F;printk.c</strong>文件中定义的一个数组决定的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</span><br><span class="line"># 默认输出7 4 1 7</span><br></pre></td></tr></table></figure><p>上面四个数字的<strong>含别如下：</strong></p><blockquote><p><strong>控制台日志级别：</strong>优先级高于该值的消息将被打印至控制台<br><strong>默认的消息日志级别：</strong>将用该优先级来打印没有优先级的消息<br><strong>最低的控制台日志级别：</strong>控制台日志级别可被设置的最小值(最高优先级)<br><strong>默认的控制台日志级别：</strong>控制台日志级别的缺省值</p></blockquote><p>如果觉得开机之后输出的<strong>日志信息太多</strong>，可以使用如下命令修改打印的日志信息级别，减少不必要的信息干扰。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 屏蔽掉所有的内核printk打印</span><br><span class="line">echo 0 4 1 7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk </span><br></pre></td></tr></table></figure><hr><h2 id="四、屏幕背光调节功能测试"><a href="#四、屏幕背光调节功能测试" class="headerlink" title="四、屏幕背光调节功能测试"></a>四、屏幕背光调节功能测试</h2><img src="/posts/undefined/2d6e05c914c3bd9742a6da2c13f15b0f.png" class="" title="img"><p>通过<strong>PE6管脚</strong>输出PWM波，控制屏幕<strong>背光引脚</strong>，进而控制屏幕亮度，本文在设备树中设置了<strong>八个亮度等级，</strong>通过在<strong>脚本（.sh文件，并chomd权限）</strong>中输入以下代码可以<strong>控制亮度变化。</strong>（这里有个小问题，输入零的时候并没有熄屏，留个小坑吧）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">        for i in &#123;7..1&#125;</span><br><span class="line">        do</span><br><span class="line">                sleep 0.2</span><br><span class="line">                echo $i &gt; &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;backlight&#x2F;brightness</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">        for j in &#123;1..7&#125;</span><br><span class="line">        do</span><br><span class="line">                echo $j &gt; &#x2F;sys&#x2F;class&#x2F;backlight&#x2F;backlight&#x2F;brightness</span><br><span class="line">                sleep 0.2</span><br><span class="line">        done</span><br><span class="line">done</span><br></pre></td></tr></table></figure><hr><h2 id="五、主要参考内容"><a href="#五、主要参考内容" class="headerlink" title="五、主要参考内容"></a>五、主要参考内容</h2><p>1.<a href="https://blog.csdn.net/qq_27350133/article/details/124602894">RGB接口 LCD驱动适配</a>；</p><p>2.<a href="https://blog.csdn.net/GJF712/article/details/126446054">Lctech Pi(F1C200S)4.3寸(480*272)16位RGB565LCD屏驱动适配</a> ；</p><p>3.<a href="https://whycan.com/t_2896.html">解决f1c100s 主线Linux 升级到 4.19 之后的版本没有 framebuffer(fb0)设备问题(Linux5.2)</a>；</p><p>4.<a href="https://blog.csdn.net/GUOYIHONEY/article/details/46928317">修改Linux kernel中打印的级别</a>；</p><p>5.<a href="https://whycan.com/t_7627.html">f1c100s驱动rgb屏求助</a>；</p><p>6.<a href="https://whycan.com/t_8630.html">更换正点原子7寸RGB LCD(1024*600)，启动失败</a></p><p>7.<a href="https://blog.csdn.net/qq_21792169/article/details/51034165">ttyS、ttySAC、tty、ttyn的区别_HeroKern的博客-CSDN博客_ttytcu0和ttyths0的区别</a>。</p><h1 id="GT1151触摸屏驱动"><a href="#GT1151触摸屏驱动" class="headerlink" title="GT1151触摸屏驱动"></a>GT1151触摸屏驱动</h1><h2 id="一、AT4384-RGB屏幕触摸芯片"><a href="#一、AT4384-RGB屏幕触摸芯片" class="headerlink" title="一、AT4384 RGB屏幕触摸芯片"></a>一、AT4384 RGB屏幕触摸芯片</h2><p>使用正点原子屏幕的朋友<strong>一定要注意</strong>，<strong>以前原子的触摸屏的触摸芯片是gt9147的</strong>，教程里的也是gt9147的驱动，后来，大概在2021年5月份前后，原子的4.3寸屏<strong>更换了触摸芯片</strong>了，触摸芯片型号是<strong>gt1151</strong>的。所以，后期买屏幕的朋友可能拿到屏幕的芯片不是gt9147的了，所以按照教程或者前面的帖子来改的话，可能是无法触摸的。<strong>所以说，一定要先确定自己触摸屏幕的触摸芯片型号。</strong></p><img src="/posts/undefined/91b0d9622140496ef88ccd5382568427.png" class="" title="img"><img src="/posts/undefined/34162a1faf92c78e40ba0e92dd99a3b8.png" class="" title="img"><hr><h2 id="二、设备树修改"><a href="#二、设备树修改" class="headerlink" title="二、设备树修改"></a>二、设备树修改</h2><h3 id="1、-dtsi文件修改"><a href="#1、-dtsi文件修改" class="headerlink" title="1、.dtsi文件修改"></a>1、.dtsi文件修改</h3><p>dtsi文件中添加如下内容，在<strong>pio结点</strong>下对本次实验所用到的管脚进行<strong>功能复用</strong>，所用到的功能为<strong>I2C通信功能、GPIO输出复位功能、中断检测功能。</strong>其中，I2C选择i2c0，也就是PE11、PE12，复位管脚选择PE4，中断检测管脚选择PE3，这是我们的<strong>硬件决定</strong>的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pio: pinctrl@1c20800 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-f1c100s-pinctrl&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c20800 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;38&gt;, &lt;39&gt;, &lt;40&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu 37&gt;, &lt;&amp;osc24M&gt;, &lt;&amp;osc32k&gt;;</span><br><span class="line">clock-names &#x3D; &quot;apb&quot;, &quot;hosc&quot;, &quot;losc&quot;;</span><br><span class="line">gpio-controller;</span><br><span class="line">interrupt-controller;</span><br><span class="line">#interrupt-cells &#x3D; &lt;3&gt;;</span><br><span class="line">#gpio-cells &#x3D; &lt;3&gt;;</span><br><span class="line"></span><br><span class="line">uart0_pe_pins: uart0-pe-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PE0&quot;, &quot;PE1&quot;;</span><br><span class="line">function &#x3D; &quot;uart0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">lcd_rgb666_pins: lcd-rgb666-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PD0&quot;, &quot;PD1&quot;, &quot;PD2&quot;, &quot;PD3&quot;, &quot;PD4&quot;,</span><br><span class="line">   &quot;PD5&quot;, &quot;PD6&quot;, &quot;PD7&quot;, &quot;PD8&quot;, &quot;PD9&quot;,</span><br><span class="line">   &quot;PD10&quot;, &quot;PD11&quot;, &quot;PD12&quot;, &quot;PD13&quot;, &quot;PD14&quot;,</span><br><span class="line">   &quot;PD15&quot;, &quot;PD16&quot;, &quot;PD17&quot;, &quot;PD18&quot;, &quot;PD19&quot;,</span><br><span class="line">   &quot;PD20&quot;, &quot;PD21&quot;;</span><br><span class="line">function &#x3D; &quot;lcd&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine</span><br><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine 2</span><br><span class="line">i2c0_pins: i2c0_pins &#123;</span><br><span class="line">pins &#x3D; &quot;PE11&quot;, &quot;PE12&quot;;</span><br><span class="line">function &#x3D; &quot;i2c0&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine 2</span><br><span class="line">ts_reset_pin: ts_reset_pin &#123;</span><br><span class="line">pins &#x3D; &quot;PE4&quot;;</span><br><span class="line">function &#x3D; &quot;gpio_out&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">ts_int_pin: ts_int_pin &#123;</span><br><span class="line">pins &#x3D; &quot;PE3&quot;;</span><br><span class="line">function &#x3D; &quot;gpio_in&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<strong>soc结点</strong>下添加<strong>i2c0结点</strong>， 描述了i2c0对应的驱动、时钟和所用管脚等信息，在.dtsi文件中该结点的状态属性值为disabled，这意味着需要在.dts文件中<strong>使能</strong>该结点功能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i2c0: i2c@1C27000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,sun6i-a31-i2c&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01C27000 0x400&gt;;</span><br><span class="line">interrupts &#x3D; &lt;7&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_I2C0&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_I2C0&gt;;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;i2c0_pins&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、-dts文件修改"><a href="#2、-dts文件修改" class="headerlink" title="2、.dts文件修改"></a>2、.dts文件修改</h3><p>dts文件添加以下内容，<strong>gt1151触摸屏</strong>对应的驱动为<strong>**goodix,gt1151ATK4384，*<em><strong>对于该驱动的编写，我们将在下一节进行描述。</strong>注意：gt1151器件地址和gt9147相同，都是0x14。</em>*每个I2C器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个I2C器件。</strong>I2C设备的读写地址和I2C设备地址不同<strong>，I2C设备的读写地址是一个</strong>8位的数据，<strong>其中高7位是</strong>设备地址，<strong>最后1位是</strong>读写位，**为1的话表示这是一个读操作，为0的话表示这是一个写操作。 I2C设备的写地址 &#x3D; I2C设备地址 &lt;&lt; 1，I2C设备的读地址 &#x3D; (I2C设备地址 &lt;&lt; 1) + 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&amp;i2c0 &#123;</span><br><span class="line">    status &#x3D; &quot;okay&quot;;</span><br><span class="line"></span><br><span class="line">    gt1151: touchscreen@14 &#123;</span><br><span class="line">        compatible &#x3D; &quot;goodix,gt1151ATK4384&quot;;&#x2F;&#x2F; &quot;goodix,gt1151&quot;;</span><br><span class="line">        reg &#x3D; &lt;0x14&gt;;&#x2F;&#x2F; gt1151器件地址，器件地址是I2C器件固有的地址编码，器件出厂时已经给定，不可更改</span><br><span class="line">        interrupt-parent &#x3D; &lt;&amp;pio&gt;;</span><br><span class="line">        interrupts &#x3D; &lt;4 3 IRQ_TYPE_EDGE_FALLING&gt;; &#x2F;* (PE3) *&#x2F;</span><br><span class="line">        pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;ts_int_pin&gt;;</span><br><span class="line">        reset-gpios &#x3D; &lt;&amp;pio 4 4 GPIO_ACTIVE_LOW&gt;; &#x2F;* RST (PE4) *&#x2F;</span><br><span class="line">        interrupt-gpios &#x3D; &lt;&amp;pio 4 3 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">touchscreen-size-x &#x3D; &lt;800&gt;;</span><br><span class="line">touchscreen-size-y &#x3D; &lt;480&gt;;</span><br><span class="line">touchscreen-swapped-x-y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="三、驱动编写"><a href="#三、驱动编写" class="headerlink" title="三、驱动编写"></a>三、驱动编写</h2><h3 id="1、驱动分析"><a href="#1、驱动分析" class="headerlink" title="1、驱动分析"></a>1、驱动分析</h3><p>驱动程序编写主要参考《正点原子开发指南》，在裸机开发中进行触摸屏的驱动，主要流程如下：</p><blockquote><p> ①、电容触摸屏是<strong>IIC接口的</strong>，需要触摸 IC，以正点原子的 ATK4384 为例，其所使用的触<br>摸屏控制 IC 为GT1151，因此所谓的电容触摸驱动就是 IIC设备驱动。<br> ②、触摸IC提供了<strong>中断信号引脚(INT)，</strong>可以通过中断来获取触摸信息。<br> ③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。<br> ④、电容触摸屏不需要校准，当然了，这只是理论上的，如果电容触摸屏质量比较差，或<br>者触摸玻璃和 TFT 之间没有完全对齐，那么也是需要校准的。 </p></blockquote><p> 那么电容触摸屏的Linux驱动主要需要以下<strong>几个驱动框架的组合：</strong></p><blockquote><p> ①、IIC 设备驱动，因为电容触摸IC基本<strong>都是IIC接口的</strong>，因此大框架就是<em><strong>*IIC设备驱动。*</strong></em><br> ②、<strong>通过中断引脚(INT)<strong>向linux内核上报触摸信息，因此需要用到linux</strong>中断驱动框架。</strong>坐<br>标的上报在中断服务函数中完成。<br> ③、触摸屏的<strong>坐标信息、屏幕按下和抬起信息</strong>都属于linux的<strong>input子系统</strong>，因此向 linux 内<br>核上报触摸屏坐标信息就得使用input子系统。</p></blockquote><h3 id="2、驱动代码"><a href="#2、驱动代码" class="headerlink" title="2、驱动代码"></a>2、驱动代码</h3><p>我们根据上面的分析编写了如下的<strong>gt1151的触摸屏驱动程序，</strong>至于代码的的<strong>详细解释</strong>，请参考正点原子官方文档，或者代码中注释，不在此处赘述。<strong>设备（设备树结点）和驱动匹配成功之后，gt1151probe函数就会执行，</strong>在该函数内部获取设备树终端和复位引脚、复位并初始化gt1151、获取设备信息后注册input设备，最后初始化中断。<strong>注意：设备树匹配表gt1151_of_match_table中的.compatible &#x3D; “goodix,gt1151ATK4384”用来连接设备树和驱动，在设备树中的compatible一定要于此处完全相同！</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; gt1151驱动代码</span><br><span class="line">#include &lt;linux&#x2F;module.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;regmap.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;gpio&#x2F;consumer.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;of_irq.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;interrupt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input&#x2F;mt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;debugfs.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;delay.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;slab.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;gpio.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;of_gpio.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input&#x2F;mt.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;input&#x2F;touchscreen.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;i2c.h&gt;</span><br><span class="line">#include &lt;asm&#x2F;unaligned.h&gt;</span><br><span class="line"></span><br><span class="line">#define GT_CTRL_REG         0X8040  &#x2F;* GT1151控制寄存器         *&#x2F;</span><br><span class="line">#define GT_MODSW_REG         0X804D  &#x2F;* GT1151模式切换寄存器        *&#x2F;</span><br><span class="line">#define GT_9xx_CFGS_REG     0X8047  &#x2F;* GT1151配置起始地址寄存器    *&#x2F;</span><br><span class="line">#define GT_1xx_CFGS_REG     0X8050  &#x2F;* GT1151配置起始地址寄存器    *&#x2F;</span><br><span class="line">#define GT_CHECK_REG         0X80FF  &#x2F;* GT1151校验和寄存器       *&#x2F;</span><br><span class="line">#define GT_PID_REG         0X8140  &#x2F;* GT1151产品ID寄存器       *&#x2F;</span><br><span class="line"></span><br><span class="line">#define GT_GSTID_REG         0X814E  &#x2F;* GT1151当前检测到的触摸情况 *&#x2F;</span><br><span class="line">#define GT_TP1_REG         0X814F  &#x2F;* 第一个触摸点数据地址 *&#x2F;</span><br><span class="line">#define GT_TP2_REG         0X8157&#x2F;* 第二个触摸点数据地址 *&#x2F;</span><br><span class="line">#define GT_TP3_REG         0X815F  &#x2F;* 第三个触摸点数据地址 *&#x2F;</span><br><span class="line">#define GT_TP4_REG         0X8167  &#x2F;* 第四个触摸点数据地址  *&#x2F;</span><br><span class="line">#define GT_TP5_REG         0X816F&#x2F;* 第五个触摸点数据地址   *&#x2F;</span><br><span class="line">#define MAX_SUPPORT_POINTS      5       &#x2F;* 最多5点电容触摸 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存放电容触摸设备相关属性信息</span><br><span class="line">struct gt1151_dev &#123;</span><br><span class="line">int irq_pin,reset_pin;&#x2F;* 中断和复位IO*&#x2F;</span><br><span class="line">int irqnum;&#x2F;* 中断号    *&#x2F;</span><br><span class="line">int irqtype;&#x2F;* 中断类型         *&#x2F;</span><br><span class="line">int max_x;&#x2F;* 最大横坐标   *&#x2F;</span><br><span class="line">int max_y; &#x2F;* 最大纵坐标*&#x2F;</span><br><span class="line">void *private_data;&#x2F;* 私有数据 *&#x2F;</span><br><span class="line">struct input_dev *input;&#x2F;* input结构体 *&#x2F;</span><br><span class="line">struct i2c_client *client;&#x2F;* I2C客户端 *&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">struct gt1151_dev gt1151;</span><br><span class="line"></span><br><span class="line">const u8 irq_table[] &#x3D; &#123;IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH&#125;;  &#x2F;* 触发方式 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 复位GT1151</span><br><span class="line">static int gt1151_ts_reset(struct i2c_client *client, struct gt1151_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 申请复位IO*&#x2F;</span><br><span class="line">if (gpio_is_valid(dev-&gt;reset_pin)) &#123;  </span><br><span class="line">&#x2F;* 申请复位IO，并且默认输出高电平 *&#x2F;</span><br><span class="line">ret &#x3D; devm_gpio_request_one(&amp;client-&gt;dev,</span><br><span class="line">dev-&gt;reset_pin, GPIOF_OUT_INIT_HIGH,</span><br><span class="line">&quot;gt1151 reset&quot;);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 初始化GT1151，要严格按照GT1151时序要求 *&#x2F;</span><br><span class="line">    gpio_set_value(dev-&gt;reset_pin, 0); &#x2F;* 复位GT1151 *&#x2F;</span><br><span class="line">    msleep(10);</span><br><span class="line"></span><br><span class="line">    gpio_set_value(dev-&gt;reset_pin, 1); &#x2F;* 停止复位GT1151 *&#x2F;</span><br><span class="line">    msleep(10);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; gpio_set_value(dev-&gt;irq_pin, 0);    &#x2F;* 拉低INT引脚 *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; msleep(50);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; gpio_direction_input(dev-&gt;irq_pin); &#x2F;* INT引脚设置为输入 *&#x2F;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 从GT1151读取多个寄存器数据</span><br><span class="line">static int gt1151_read_regs(struct gt1151_dev *dev, u16 reg, u8 *buf, int len)</span><br><span class="line">&#123;</span><br><span class="line">int ret;</span><br><span class="line">    u8 regdata[2];</span><br><span class="line">struct i2c_msg msg[2];</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line">    </span><br><span class="line">    &#x2F;* GT1151寄存器长度为2个字节 *&#x2F;</span><br><span class="line">    regdata[0] &#x3D; reg &gt;&gt; 8;</span><br><span class="line">    regdata[1] &#x3D; reg &amp; 0xFF;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 别和SPI通信方式搞混了</span><br><span class="line">&#x2F;* msg[0]为发送要读取的首地址 *&#x2F;</span><br><span class="line">msg[0].addr &#x3D; client-&gt;addr;&#x2F;* gt1151地址 应该是设备树中的器件地址 *&#x2F;</span><br><span class="line">msg[0].flags &#x3D; !I2C_M_RD;&#x2F;* 标记为发送数据 *&#x2F;</span><br><span class="line">msg[0].buf &#x3D; &amp;regdata[0];&#x2F;* 读取的首地址 *&#x2F;</span><br><span class="line">msg[0].len &#x3D; 2;&#x2F;* reg长度*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;* msg[1]读取数据 *&#x2F;</span><br><span class="line">msg[1].addr &#x3D; client-&gt;addr;&#x2F;* gt1151地址 *&#x2F;</span><br><span class="line">msg[1].flags &#x3D; I2C_M_RD;&#x2F;* 标记为读取数据*&#x2F;</span><br><span class="line">msg[1].buf &#x3D; buf;&#x2F;* 读取数据缓冲区 *&#x2F;</span><br><span class="line">msg[1].len &#x3D; len;&#x2F;* 要读取的数据长度*&#x2F;</span><br><span class="line"></span><br><span class="line">ret &#x3D; i2c_transfer(client-&gt;adapter, msg, 2);</span><br><span class="line">if(ret &#x3D;&#x3D; 2) &#123;</span><br><span class="line">ret &#x3D; 0;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ret &#x3D; -EREMOTEIO;</span><br><span class="line">&#125;</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 向GT1151多个寄存器写入数据</span><br><span class="line">static s32 gt1151_write_regs(struct gt1151_dev *dev, u16 reg, u8 *buf, u8 len)</span><br><span class="line">&#123;</span><br><span class="line">u8 b[256];</span><br><span class="line">struct i2c_msg msg;</span><br><span class="line">struct i2c_client *client &#x3D; (struct i2c_client *)dev-&gt;client;</span><br><span class="line"></span><br><span class="line">b[0] &#x3D; reg &gt;&gt; 8;&#x2F;* 寄存器首地址低8位 *&#x2F;</span><br><span class="line">    b[1] &#x3D; reg &amp; 0XFF;&#x2F;* 寄存器首地址高8位 *&#x2F;</span><br><span class="line">memcpy(&amp;b[2],buf,len);&#x2F;* 将要写入的数据拷贝到数组b里面 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.addr &#x3D; client-&gt;addr;&#x2F;* gt1151地址 *&#x2F;</span><br><span class="line">msg.flags &#x3D; 0;&#x2F;* 标记为写数据 *&#x2F;</span><br><span class="line"></span><br><span class="line">msg.buf &#x3D; b;&#x2F;* 要写入的数据缓冲区 *&#x2F;</span><br><span class="line">msg.len &#x3D; len + 2;&#x2F;* 要写入的数据长度 *&#x2F;</span><br><span class="line"></span><br><span class="line">return i2c_transfer(client-&gt;adapter, &amp;msg, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中断服务函数</span><br><span class="line">static irqreturn_t gt1151_irq_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    int touch_num &#x3D; 0;</span><br><span class="line">    int input_x, input_y;</span><br><span class="line">    int id &#x3D; 0;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    u8 data;</span><br><span class="line">    u8 touch_data[5];</span><br><span class="line">    struct gt1151_dev *dev &#x3D; dev_id;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; printk(&quot;enter irq handler!\r\n&quot;);</span><br><span class="line"></span><br><span class="line">    ret &#x3D; gt1151_read_regs(dev, GT_GSTID_REG, &amp;data, 1);&#x2F;&#x2F; GT1151当前检测到的触摸情况</span><br><span class="line">    if (data &#x3D;&#x3D; 0x00)  &#123;     &#x2F;* 没有触摸数据，直接返回 *&#x2F;</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125; else &#123;                 &#x2F;* 统计触摸点数据 *&#x2F;</span><br><span class="line">        touch_num &#x3D; data &amp; 0x0f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 由于GT1151没有硬件检测每个触摸点按下和抬起，因此每个触摸点的抬起和按</span><br><span class="line">     * 下不好处理，尝试过一些方法，但是效果都不好，因此这里暂时使用单点触摸 </span><br><span class="line">     *&#x2F;</span><br><span class="line">    if(touch_num) &#123;         &#x2F;* 单点触摸按下 *&#x2F;</span><br><span class="line">        gt1151_read_regs(dev, GT_TP1_REG, touch_data, 5);</span><br><span class="line">        id &#x3D; touch_data[0] &amp; 0x0F;</span><br><span class="line">        if(id &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;读取成功</span><br><span class="line">            input_x  &#x3D; touch_data[1] | (touch_data[2] &lt;&lt; 8);</span><br><span class="line">            input_y  &#x3D; touch_data[3] | (touch_data[4] &lt;&lt; 8);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单点id一直等于0即可</span><br><span class="line">            input_mt_slot(dev-&gt;input, 0);</span><br><span class="line">    input_mt_report_slot_state(dev-&gt;input, MT_TOOL_FINGER, true);</span><br><span class="line">    input_report_abs(dev-&gt;input, ABS_MT_POSITION_X, input_x);</span><br><span class="line">    input_report_abs(dev-&gt;input, ABS_MT_POSITION_Y, input_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if(touch_num &#x3D;&#x3D; 0)&#123;                &#x2F;* 单点触摸释放 *&#x2F;</span><br><span class="line">        input_mt_slot(dev-&gt;input, id);</span><br><span class="line">        input_mt_report_slot_state(dev-&gt;input, MT_TOOL_FINGER, false);&#x2F;&#x2F; 删除触摸点</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">input_mt_report_pointer_emulation(dev-&gt;input, true);&#x2F;&#x2F; 没有出现硬件检测到的点比上报的触摸点多的情况</span><br><span class="line">    input_sync(dev-&gt;input);</span><br><span class="line"></span><br><span class="line">    data &#x3D; 0x00;                &#x2F;* 向0X814E寄存器写0 *&#x2F;</span><br><span class="line">    gt1151_write_regs(dev, GT_GSTID_REG, &amp;data, 1);</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; GT1151中断初始化</span><br><span class="line">static int gt1151_ts_irq(struct i2c_client *client, struct gt1151_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; 由于触摸IC复位需要用到两个IO 在前面已经request了</span><br><span class="line">&#x2F;* 2，申请中断,client-&gt;irq就是IO中断， *&#x2F;</span><br><span class="line">ret &#x3D; devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,</span><br><span class="line">gt1151_irq_handler, irq_table[dev-&gt;irqtype] | IRQF_ONESHOT,</span><br><span class="line">client-&gt;name, &amp;gt1151);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev, &quot;Unable to request touchscreen IRQ.\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;else</span><br><span class="line">&#123;</span><br><span class="line">printk(&quot;irq init!\r\n&quot;);</span><br><span class="line">printk(&quot;dev-&gt;irqtype &#x3D; %d\r\n&quot;, dev-&gt;irqtype);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; GT1151读取固件</span><br><span class="line">static int gt1151_read_firmware(struct i2c_client *client, struct gt1151_dev *dev)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0, version &#x3D; 0;</span><br><span class="line">u16 id &#x3D; 0;</span><br><span class="line">u8 data[7]&#x3D;&#123;0&#125;;</span><br><span class="line">char id_str[5];</span><br><span class="line">ret &#x3D; gt1151_read_regs(dev, GT_PID_REG, data, 6);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev, &quot;Unable to read PID.\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">memcpy(id_str, data, 4);</span><br><span class="line">id_str[4] &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    if (kstrtou16(id_str, 10, &amp;id))id &#x3D; 0x1001;</span><br><span class="line"></span><br><span class="line">version &#x3D; get_unaligned_le16(&amp;data[4]);</span><br><span class="line"></span><br><span class="line">dev_info(&amp;client-&gt;dev, &quot;ID %d, version: %04x\n&quot;, id, version);</span><br><span class="line">switch (id) &#123;    &#x2F;* 由于不同的芯片配置寄存器地址不一样需要判断一下  *&#x2F;</span><br><span class="line">    case 1151:</span><br><span class="line">    case 1158:</span><br><span class="line">    case 5663:</span><br><span class="line">    case 5688:    &#x2F;* 读取固件里面的配置信息  *&#x2F;</span><br><span class="line">        ret &#x3D; gt1151_read_regs(dev, GT_1xx_CFGS_REG, data, 7);  </span><br><span class="line">break;</span><br><span class="line">    default:</span><br><span class="line">        ret &#x3D; gt1151_read_regs(dev, GT_1xx_CFGS_REG, data, 7);</span><br><span class="line">break;</span><br><span class="line">    &#125;</span><br><span class="line">if (ret) &#123;</span><br><span class="line">dev_err(&amp;client-&gt;dev, &quot;Unable to read Firmware.\n&quot;);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line">dev-&gt;max_x &#x3D; (data[2] &lt;&lt; 8) + data[1];</span><br><span class="line">dev-&gt;max_y &#x3D; (data[4] &lt;&lt; 8) + data[3];</span><br><span class="line">dev-&gt;irqtype &#x3D; data[6] &amp; 0x3;</span><br><span class="line">printk(&quot;X_MAX: %d, Y_MAX: %d, TRIGGER: 0x%02x&quot;, dev-&gt;max_x, dev-&gt;max_y, dev-&gt;irqtype);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; probe函数</span><br><span class="line">int gt1151_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br><span class="line">&#123;</span><br><span class="line">    u8 data, ret;</span><br><span class="line">    gt1151.client &#x3D; client;</span><br><span class="line">printk(&quot;Driver and device has mached!!!\r\n&quot;);</span><br><span class="line"></span><br><span class="line"> &#x2F;* 1，获取设备树中的中断和复位引脚 *&#x2F;</span><br><span class="line">gt1151.irq_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;interrupt-gpios&quot;, 0);</span><br><span class="line">gt1151.reset_pin &#x3D; of_get_named_gpio(client-&gt;dev.of_node, &quot;reset-gpios&quot;, 0);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; printk(&quot;irq_pin&#x3D;%d, reset_pin&#x3D;%d\r\n&quot;, gt1151.irq_pin, gt1151.reset_pin);</span><br><span class="line">&#x2F;* 2，复位GT1151 *&#x2F;</span><br><span class="line">ret &#x3D; gt1151_ts_reset(client, &amp;gt1151);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 3，初始化GT1151 *&#x2F;</span><br><span class="line">    data &#x3D; 0x02;</span><br><span class="line">    gt1151_write_regs(&amp;gt1151, GT_CTRL_REG, &amp;data, 1); &#x2F;* 软复位 *&#x2F;</span><br><span class="line">    mdelay(100);</span><br><span class="line">    data &#x3D; 0x0;</span><br><span class="line">    gt1151_write_regs(&amp;gt1151, GT_CTRL_REG, &amp;data, 1); &#x2F;* 停止软复位 *&#x2F;</span><br><span class="line">    mdelay(100);</span><br><span class="line"></span><br><span class="line">    &#x2F;* 4,初始化GT1151，读取固件 *&#x2F; &#x2F;&#x2F; 应该是读触摸设备的信息</span><br><span class="line">ret &#x3D; gt1151_read_firmware(client, &amp;gt1151);</span><br><span class="line">if(ret !&#x3D; 0) &#123;</span><br><span class="line">printk(&quot;Fail !!! check !!\r\n&quot;);</span><br><span class="line">goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 5，input设备注册 *&#x2F;</span><br><span class="line">gt1151.input &#x3D; devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line">if (!gt1151.input) &#123;</span><br><span class="line">ret &#x3D; -ENOMEM;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line">gt1151.input-&gt;name &#x3D; client-&gt;name;</span><br><span class="line">gt1151.input-&gt;id.bustype &#x3D; BUS_I2C;</span><br><span class="line">gt1151.input-&gt;dev.parent &#x3D; &amp;client-&gt;dev;</span><br><span class="line"></span><br><span class="line">__set_bit(EV_KEY, gt1151.input-&gt;evbit);</span><br><span class="line">__set_bit(EV_ABS, gt1151.input-&gt;evbit);</span><br><span class="line">__set_bit(BTN_TOUCH, gt1151.input-&gt;keybit);</span><br><span class="line"></span><br><span class="line">input_set_abs_params(gt1151.input, ABS_X, 0, gt1151.max_x, 0, 0);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_Y, 0, gt1151.max_y, 0, 0);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_MT_POSITION_X,0, gt1151.max_x, 0, 0);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_MT_POSITION_Y,0, gt1151.max_y, 0, 0);     </span><br><span class="line">ret &#x3D; input_mt_init_slots(gt1151.input, MAX_SUPPORT_POINTS, 0);</span><br><span class="line">if (ret) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret &#x3D; input_register_device(gt1151.input);</span><br><span class="line">if (ret)</span><br><span class="line">goto fail;</span><br><span class="line"></span><br><span class="line">    &#x2F;* 6，最后初始化中断 *&#x2F;</span><br><span class="line">ret &#x3D; gt1151_ts_irq(client, &amp;gt1151);</span><br><span class="line">if(ret &lt; 0) &#123;</span><br><span class="line">goto fail;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; i2c驱动的remove函数</span><br><span class="line">int gt1151_remove(struct i2c_client *client)</span><br><span class="line">&#123;</span><br><span class="line">    input_unregister_device(gt1151.input);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 传统驱动匹配表</span><br><span class="line">const struct i2c_device_id gt1151_id_table[] &#x3D; &#123;</span><br><span class="line">&#123; &quot;goodix,gt1151ATK4384&quot;, 0, &#125;,</span><br><span class="line">    &#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设备树匹配表 </span><br><span class="line">const struct of_device_id gt1151_of_match_table[] &#x3D; &#123;</span><br><span class="line">    &#123;.compatible &#x3D; &quot;goodix,gt1151ATK4384&quot; &#125;,</span><br><span class="line">    &#123; &#x2F;* sentinel *&#x2F; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;* i2c驱动结构体 *&#x2F;</span><br><span class="line">struct i2c_driver gt1151_i2c_driver &#x3D; &#123;</span><br><span class="line">    .driver &#x3D; &#123;</span><br><span class="line">        .name  &#x3D; &quot;gt1151&quot;,</span><br><span class="line">        .owner &#x3D; THIS_MODULE,</span><br><span class="line">        .of_match_table &#x3D; gt1151_of_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table &#x3D; gt1151_id_table,</span><br><span class="line">    .probe  &#x3D; gt1151_probe,</span><br><span class="line">    .remove &#x3D; gt1151_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module_i2c_driver(gt1151_i2c_driver);&#x2F;&#x2F; 展开后和module_init module_exit一样，类似于module_platform_driver</span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(&quot;GPL&quot;);</span><br><span class="line">MODULE_AUTHOR(&quot;kashine&quot;);</span><br></pre></td></tr></table></figure><hr><h2 id="四、内核配置"><a href="#四、内核配置" class="headerlink" title="四、内核配置"></a>四、内核配置</h2><h3 id="1、IIC设备使能"><a href="#1、IIC设备使能" class="headerlink" title="1、IIC设备使能"></a>1、IIC设备使能</h3><p>首先<strong>使能IIC控制器和设备树对i2c设备的支持，</strong>使用<strong>make menuconfig</strong>命令打开<strong>图形化配置界面</strong>，打开以下路径的<strong>Marvell mv64xxx I2C Controller：</strong></p><blockquote><p>Device Drivers</p><p>​    -&gt; I2C support</p><p>​        -&gt; I2C Hardware Bus support</p></blockquote><p>全志芯片使用的是<strong>marvell的i2c控制器</strong>（参考Documentation&#x2F;devicetree&#x2F;bindings&#x2F;i2c&#x2F;i2c-mv64xxx.txt），该选项默认处于使能状态。 </p><img src="/posts/undefined/597b49a9dcfaffd23160e6b51144785b.png" class="" title="img"><p>打开以下路径中的<strong>I2C device interface</strong>选项： </p><blockquote><p>Device Drivers</p><p>​    -&gt; I2C support</p></blockquote><img src="/posts/undefined/b1640941b2ca41e308d31c6a9960ba88.png" class="" title="img"><h3 id="2、内核驱动添加"><a href="#2、内核驱动添加" class="headerlink" title="2、内核驱动添加"></a>2、内核驱动添加</h3><p>将上一节编写的驱动代码<strong>命名为gt1151.c，</strong>并放在<strong>linux-5.7.1&#x2F;drivers&#x2F;input&#x2F;touchscreen</strong>目录下，如下图所示，可以看到touchscreen内有很多屏幕的适配驱动。其实<strong>gt1151官方也有适配的驱动</strong>，就是gt1151.c上方的<strong>goodix.c，</strong>这是汇顶触摸IC对应的<strong>gt系列驱动，</strong>那为什么我们还要自己编写呢？因为对于本文所用的硬件接线以及正点原子屏幕的定义，导致使用该驱动对正点原子屏幕的识别出错，得到的x、y坐标是反着的，因此需要对goodix.c进行修改，那就不如自己写喽。</p><img src="/posts/undefined/85b1bb6ce4b6c32441fa9bc2e7d925e6.png" class="" title="img"><p> 仅仅将驱动文件放到对应的文件夹下面并不可以，因为内核不知道有这么个tg1151驱动文件，我们需要在<strong>touchscreen文件夹</strong>下的<strong>Makfile</strong>进行修改，在最后方添加对gt1151.c的<strong>编译请求。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_TOUCHSCREEN_GT1151)+&#x3D; gt1151.o</span><br></pre></td></tr></table></figure><img src="/posts/undefined/3e2b6f9557e47974ece39c2eece5a407.png" class="" title="img"><p>我们都知道在make menuconfig图形化配置界面可以<strong>对驱动进行使能、关闭、编译为模块的配置，</strong>如果想要我们的gt1151驱动编译选项能够在make menuconfig调出的<strong>图形化配置界面中配置</strong>，还需要在<strong>touchscreen文件夹</strong>下的<strong>Kconfig文件</strong>中添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">config TOUCHSCREEN_GT1151</span><br><span class="line">tristate &quot;GT1151 touchscreen controller&quot;</span><br><span class="line">depends on I2C</span><br><span class="line"></span><br><span class="line">help</span><br><span class="line">  Say Y to enable support for the GT1151</span><br><span class="line">  family of trackpad&#x2F;touchscreen controllers.</span><br><span class="line"></span><br><span class="line">  To compile this driver as a module, choose M here: the</span><br><span class="line">  module will be called gt1151.</span><br><span class="line"></span><br><span class="line">endif #非添加内容！！！</span><br></pre></td></tr></table></figure><img src="/posts/undefined/a48f61e19b4af5b95b20f54690d0ca5c.png" class="" title="img"><h3 id="3、gt1151驱动使能"><a href="#3、gt1151驱动使能" class="headerlink" title="3、gt1151驱动使能"></a>3、gt1151驱动使能</h3><p>添加完驱动，并提供了图形化界面配置信息后，我们还要在make menuconfig提供的图形化配置界面中<strong>使能</strong>我们添加的<strong>gt1151驱动。</strong>如下图所示，我们需要<strong>使能GT1151 touchscreen controller选项</strong><strong>(将驱动编译进内核)，</strong>也就是我们上面添加的选项。</p><img src="/posts/undefined/c59eeb7f0e38a5cfd0e736612c76a17a.png" class="" title="img"><p>我们<strong>自定义了gt1151的驱动，</strong>因此<strong>goodix.c</strong>中的驱动我们就不需要了，所以在相同路径中，<strong>失能goodix</strong>驱动选项****Goodix I2C touchscreen，****如下图所示：</p><img src="/posts/undefined/afb9c565f89070a49cfe3dd5e0244bb1.png" class="" title="img"><hr><h2 id="五、触摸测试"><a href="#五、触摸测试" class="headerlink" title="五、触摸测试"></a>五、触摸测试</h2><h3 id="1、启动与文件检查"><a href="#1、启动与文件检查" class="headerlink" title="1、启动与文件检查"></a>1、启动与文件检查</h3><p>经过前几节的配置，我们<strong>重新对内核和设备树进行编译，</strong>然后上电运行开发板，<strong>查看输出信息，</strong>发现内核启动时<strong>先后加载了i2c驱动和gt1151驱动，并且初始化中断功能</strong>，Debian系统启动后直接进入<strong>root用户空间。*<em>注意：输出Driver and device has mached!!!代表设备树设备和驱动匹配成功，这是由驱动probe函数中的printk决定的！*</em></strong></p><img src="/posts/undefined/637c4769d13d097bf7faed6aa195ad1f.png" class="" title="img"><p>下面这张图是我们在 <strong>“Debian根文件系统制作”</strong>这一小节中<strong>安装的一些组件，</strong>其中evtest是为本节安装的触摸屏测试软件，当时大家可能比较疑惑，现在我们<strong>使用该软件测试触摸屏触摸是否正常，</strong>当然大家也可以使用hexdump、<strong>tslib</strong>（非常直观，我移植了两天，宣告失败，有兴趣的尝试尝试，做出来记得@我，F1C200s下tslib移植到Debian文件系统哦）。</p><img src="/posts/undefined/3f8a5d5f3ef993114787db9286812d74.png" class="" title="img"><p>进入root用户空间后，首先查看路径**&#x2F;dev&#x2F;input&#x2F;event0、&#x2F;dev&#x2F;fb0<strong>中是否存在对应的文件，其中</strong>event0代表我们的电容触摸屏，<strong>不同的平台 event 序号不同，</strong>也可能是 event3，event4 等，**一切以实际情况为准！我的是event0，如下图所示。</p><img src="/posts/undefined/9b9672ac4dcaea034118c22adcf8ec13.png" class="" title="img"><p>如果<strong>不存在event0，</strong>或者<strong>不存在input文件夹，</strong>首先检查**&#x2F;driver&#x2F;input&#x2F;touchscreen<strong>文件夹下面有没有产生</strong>gt1151.o文件，<strong>如果没有说明</strong>没有编译，<strong>检查</strong>Kconfig、Makfile、图形化配置使能<strong>；如果有检查</strong>compatible属性值，<strong>或是检查启动log有无输出</strong>Driver and device has mached!!!**。</p><h3 id="2、触摸测试"><a href="#2、触摸测试" class="headerlink" title="2、触摸测试"></a>2、触摸测试</h3><p>很幸运你能看到这里，应该庆幸欣慰，给你点赞👍👍👍👍👍👍。在顺利完成上述操作后，我们使用evtest软件对触摸屏进行测试，使用如下命令进入测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">evtest &#x2F;dev&#x2F;input&#x2F;event0</span><br></pre></td></tr></table></figure><img src="/posts/undefined/78e49afd32be59bef0a53187aae46727.png" class="" title="img"><p> 从上面的图中可以看出，该软件<strong>正确识别</strong>到了我们的屏幕，<strong>分辨率为800*480，上报X坐标事件码为53，上报Y坐标事件码为54，</strong>现在我们来分别触摸屏幕的<strong>右下角、右上角、左下角、中间：</strong></p><img src="/posts/undefined/4dfe9a5038cc90f37f09503b06a7a93b.png" class="" title="img"><img src="/posts/undefined/a815bb3dc48a93c1696c23a1f86815f3.png" class="" title="img"><p>通过串口打印的坐标基本符合我们的触摸位置，至此，触摸IC驱动移植结束，恭喜完成本节，离offer又进一步！ 🎉🎉🎉</p><hr><h2 id="六、主要参考内容"><a href="#六、主要参考内容" class="headerlink" title="六、主要参考内容"></a>六、主要参考内容</h2><p>1.[【f1c200s&#x2F;f1c100s】FT5426触摸屏驱动适配_Liangtao&#96;的博客-CSDN博客_ft5426](<a href="https://blog.csdn.net/qq_27350133/article/details/124974526?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124974526-blog-127501970.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124974526-blog-127501970.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1)%EF%BC%9B">https://blog.csdn.net/qq_27350133/article/details/124974526?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124974526-blog-127501970.pc_relevant_multi_platform_whitelistv3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-124974526-blog-127501970.pc_relevant_multi_platform_whitelistv3&amp;utm_relevant_index=1)；</a></p><p>2.<a href="https://blog.csdn.net/qq_34440409/article/details/122994396"> linux设备适配触摸屏（gt1151）_星星-点灯的博客-CSDN博客</a>；</p><p>3.<a href="http://47.111.11.73/docs/boards/arm-linux/zdyz-i.mx6ull.html">《正点原子驱动开发指南》</a></p><h1 id="USB驱动"><a href="#USB驱动" class="headerlink" title="USB驱动"></a>USB驱动</h1><h2 id="一、前言-1"><a href="#一、前言-1" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1、USB-host和USB-device的区别"><a href="#1、USB-host和USB-device的区别" class="headerlink" title="1、USB host和USB device的区别"></a>1、USB host和USB device的区别</h3><p>不知道你能否<strong>区分什么是USB host、什么是USB device？</strong>下面做一些简单的介绍，用<strong>最简单的语言</strong>描述大致的原理：</p><ul><li><strong>USB Host（主设备）：</strong>字面意思为<strong>USB主机，</strong>****类似于电脑的USB接口，****可以连接移动硬盘、鼠标、键盘等等；</li><li><strong>USB Device（从设备）****：</strong>字面意思是<strong>USB设备，</strong>概念与USB host<strong>相对</strong>，类似于我们的<strong>移动硬盘。</strong></li><li><strong>注意：只有USB host和USB device连接时，数据才能正确传输。</strong></li></ul><p>那什么是<strong>USB otg</strong>呢？ <strong>USB otg既可以做USB host也可以做USB device，</strong>通过ID信号来控制<strong>主、从切换。</strong>otg技术就是实现host设备不存的的情况下，设备间的数据传输。</p><h3 id="2、硬件解析"><a href="#2、硬件解析" class="headerlink" title="2、硬件解析"></a>2、硬件解析</h3><blockquote><p>F1C200s芯片支持USB的<strong>OTG模式，</strong>也就是可以通过更改<strong>usbid</strong>拉低或拉高方式定义当前的开发板可以作为<strong>host还是device。</strong></p></blockquote><ul><li><strong>usbid 拉高</strong>时，开发板作为<strong>外设方式。</strong></li><li><strong>usbid 拉低</strong>时，开发板作为<strong>主机方式。</strong></li></ul><p>F1C200s中<strong>PE2引脚</strong>具有usbid功能，来决定开发板作为<strong>外设方式或是主机方式，</strong>本文直接将PE2拉高，也即将<strong>开发板作为外设方式（device），</strong>有的朋友可能会问，<em><strong>*我们写USB驱动是为了外接键鼠、U盘等设备，但此处为什么作为外设方式呢？*</strong></em></p><p>墨云说 ”<strong>是为了利用****sunxi-tool烧录工具，并且硬件电路里面把PE2拉高了，也就是默认是otg模式。</strong>“（本系统硬件电路主要参考墨云和稚辉君，至于这里为什么设置为外设方式，说下我的理解，大概是因为需要通过sunxi-tool将编译后的文件下载到RAM或者flash中，需要将板子作为从机，关于sunxi-tool详见<a href="https://blog.csdn.net/u012577474/article/details/103346601">sunxi-tools工具的使用</a>）。</p><blockquote><p>后记：在询问过晕哥之后，得知这个引脚其实不用拉高也可以，所以这里大家不用care，因为我们可以使用软件设置otg方式。<a href="https://debugdump.com/topic/2889/sunxi-tool%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-f1c200s-sd%E5%8D%A1-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7?_=1673762240401">sunxi-tool具体作用是什么？F1C200s &amp; SD卡，能否使用这个工具？</a></p></blockquote><p>那我们就不能将开发板<strong>作为host外接其他设备</strong>了嘛？不是。因为我们不仅可以通过<strong>硬件修改</strong>OTG模式，还可以通过<strong>软件修改。</strong></p><img src="/posts/undefined/c9633039194d873361ede34a037bee87.png" class="" title="img"><hr><h2 id="二、设备树修改-1"><a href="#二、设备树修改-1" class="headerlink" title="二、设备树修改"></a>二、设备树修改</h2><h3 id="1、-dtsi文件修改-1"><a href="#1、-dtsi文件修改-1" class="headerlink" title="1、.dtsi文件修改"></a>1、.dtsi文件修改</h3><p>在soc结点下<strong>添加</strong>如下两个结点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">usb_otg: usb@1c13000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-musb&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c13000 0x0400&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_OTG&gt;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_OTG&gt;;</span><br><span class="line">interrupts &#x3D; &lt;26&gt;;</span><br><span class="line">interrupt-names &#x3D; &quot;mc&quot;;</span><br><span class="line">phys &#x3D; &lt;&amp;usbphy 0&gt;;</span><br><span class="line">phy-names &#x3D; &quot;usb&quot;;</span><br><span class="line">extcon &#x3D; &lt;&amp;usbphy 0&gt;;</span><br><span class="line">allwinner,sram &#x3D; &lt;&amp;otg_sram 1&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">usbphy: phy@1c13400 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-usb-phy&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c13400 0x10&gt;;</span><br><span class="line">reg-names &#x3D; &quot;phy_ctrl&quot;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_USB_PHY0&gt;;</span><br><span class="line">clock-names &#x3D; &quot;usb0_phy&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_USB_PHY0&gt;;</span><br><span class="line">reset-names &#x3D; &quot;usb0_reset&quot;;</span><br><span class="line">#phy-cells &#x3D; &lt;1&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、-dts文件修改-1"><a href="#2、-dts文件修改-1" class="headerlink" title="2、.dts文件修改"></a>2、.dts文件修改</h3><p>使能一些功能，**USB otg设置为**主机方式，*<em><strong>因为我们要连接类似</strong>鼠标、键盘、U盘等的外设，</em>*也就是开发板作为主机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kahsine 3</span><br><span class="line">&amp;otg_sram &#123;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kahsine 3</span><br><span class="line">&amp;usb_otg &#123;</span><br><span class="line">        dr_mode &#x3D; &quot;host&quot;; &#x2F;* 三个可选项: otg &#x2F; host &#x2F; peripheral  我在这里指定为host模式*&#x2F;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; modify by kahsine 3</span><br><span class="line">&amp;usbphy &#123;</span><br><span class="line">        usb0_id_det-gpio &#x3D; &lt;&amp;pio 4 2 GPIO_ACTIVE_HIGH&gt;; &#x2F;* PE2 *&#x2F;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="三、驱动修改"><a href="#三、驱动修改" class="headerlink" title="三、驱动修改"></a>三、驱动修改</h2><h3 id="1、phy-sun4i-usb-c文件修改"><a href="#1、phy-sun4i-usb-c文件修改" class="headerlink" title="1、phy-sun4i-usb.c文件修改"></a>1、phy-sun4i-usb.c文件修改</h3><p><strong>&#x2F;&#x2F; 枚举变量修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum sun4i_usb_phy_type &#123;</span><br><span class="line">suniv_phy,&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">sun4i_a10_phy,</span><br><span class="line">sun6i_a31_phy,</span><br><span class="line">sun8i_a33_phy,</span><br><span class="line">sun8i_a83t_phy,</span><br><span class="line">sun8i_h3_phy,</span><br><span class="line">sun8i_r40_phy,</span><br><span class="line">sun8i_v3s_phy,</span><br><span class="line">sun50i_a64_phy,</span><br><span class="line">sun50i_h6_phy,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F; 结构体声明</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">static const struct sun4i_usb_phy_cfg suniv_cfg &#x3D; &#123;</span><br><span class="line">    .num_phys &#x3D; 1,</span><br><span class="line">    .type &#x3D; suniv_phy,</span><br><span class="line">    .disc_thresh &#x3D; 3,</span><br><span class="line">    .phyctl_offset &#x3D; REG_PHYCTL_A10,</span><br><span class="line">    .dedicated_clocks &#x3D; true,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F; compatible驱动匹配表属性修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static const struct of_device_id sun4i_usb_phy_of_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,suniv-usb-phy&quot;, .data &#x3D; &amp;suniv_cfg &#125;, &#x2F;&#x2F; modify by kashine 3</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun4i-a10-usb-phy&quot;, .data &#x3D; &amp;sun4i_a10_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun5i-a13-usb-phy&quot;, .data &#x3D; &amp;sun5i_a13_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31-usb-phy&quot;, .data &#x3D; &amp;sun6i_a31_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun7i-a20-usb-phy&quot;, .data &#x3D; &amp;sun7i_a20_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a23-usb-phy&quot;, .data &#x3D; &amp;sun8i_a23_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a33-usb-phy&quot;, .data &#x3D; &amp;sun8i_a33_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a83t-usb-phy&quot;, .data &#x3D; &amp;sun8i_a83t_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-h3-usb-phy&quot;, .data &#x3D; &amp;sun8i_h3_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-r40-usb-phy&quot;, .data &#x3D; &amp;sun8i_r40_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-v3s-usb-phy&quot;, .data &#x3D; &amp;sun8i_v3s_cfg &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun50i-a64-usb-phy&quot;,</span><br><span class="line">  .data &#x3D; &amp;sun50i_a64_cfg&#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun50i-h6-usb-phy&quot;, .data &#x3D; &amp;sun50i_h6_cfg &#125;,</span><br><span class="line">&#123; &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、sunxi-c文件修改"><a href="#2、sunxi-c文件修改" class="headerlink" title="2、sunxi.c文件修改"></a>2、sunxi.c文件修改</h3><p><strong>&#x2F;&#x2F; sunxi_musb_probe函数修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static int sunxi_musb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">struct musb_hdrc_platform_datapdata;</span><br><span class="line">struct platform_device_infopinfo;</span><br><span class="line">struct sunxi_glue*glue;</span><br><span class="line">struct device_node*np &#x3D; pdev-&gt;dev.of_node;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">glue-&gt;dev &#x3D; &amp;pdev-&gt;dev;</span><br><span class="line">INIT_WORK(&amp;glue-&gt;work, sunxi_musb_work);</span><br><span class="line">glue-&gt;host_nb.notifier_call &#x3D; sunxi_musb_host_notifier;</span><br><span class="line"></span><br><span class="line">if (of_device_is_compatible(np, &quot;allwinner,sun4i-a10-musb&quot;) || of_device_is_compatible(np, &quot;allwinner,suniv-musb&quot;))&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">set_bit(SUNXI_MUSB_FL_HAS_SRAM, &amp;glue-&gt;flags);</span><br><span class="line"></span><br><span class="line">if (of_device_is_compatible(np, &quot;allwinner,sun6i-a31-musb&quot;))</span><br><span class="line">set_bit(SUNXI_MUSB_FL_HAS_RESET, &amp;glue-&gt;flags);</span><br><span class="line"></span><br><span class="line">if (of_device_is_compatible(np, &quot;allwinner,sun8i-a33-musb&quot;) ||</span><br><span class="line">    of_device_is_compatible(np, &quot;allwinner,sun8i-h3-musb&quot;) || </span><br><span class="line">of_device_is_compatible(np, &quot;allwinner,suniv-musb&quot;) ) &#123;&#x2F;&#x2F; modify by kashine 3</span><br><span class="line">set_bit(SUNXI_MUSB_FL_HAS_RESET, &amp;glue-&gt;flags);</span><br><span class="line">set_bit(SUNXI_MUSB_FL_NO_CONFIGDATA, &amp;glue-&gt;flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>&#x2F;&#x2F; 驱动匹配表修改</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const struct of_device_id sunxi_musb_match[] &#x3D; &#123;</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,suniv-musb&quot;, &#125;, &#x2F;&#x2F; modify by kashine 3</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun4i-a10-musb&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun6i-a31-musb&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-a33-musb&quot;, &#125;,</span><br><span class="line">&#123; .compatible &#x3D; &quot;allwinner,sun8i-h3-musb&quot;, &#125;,</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="四、驱动使能"><a href="#四、驱动使能" class="headerlink" title="四、驱动使能"></a>四、驱动使能</h2><p>通过make menuconfig图形化配置界面，进入下方路径中<strong>使能驱动。</strong></p><blockquote><p>Device Drivers</p><p>​    -&gt; USB support</p></blockquote><img src="/posts/undefined/1f8a2dd127da50f8c80bf5cc140a49f4.png" class="" title="img"><img src="/posts/undefined/c4eeef35e790c50e5ed7799ea97cb62c.png" class="" title="img"><img src="/posts/undefined/6a87b2bd1be09cb7b7eeb4f711b1352b.png" class="" title="img"><h2 id="五、U盘读取测试"><a href="#五、U盘读取测试" class="headerlink" title="五、U盘读取测试"></a>五、U盘读取测试</h2><p><strong>重新编译，</strong>得到新的zImage、设备树，上电启动，观察输出信息，</p><img src="/posts/undefined/6d1bd6f966bcc6cd22a25ab0b2bb9fd4.png" class="" title="img"><p>进入Debian系统后，<strong>将U盘插入到任意一个USB接口</strong>，串口打印出下面的信息，可以看到，我们插入的<strong>3.0接口</strong>的<strong>U盘容量</strong>和<strong>可用大小</strong>，还需要注意一个重要的信息，我们的<strong>U盘在系统下面盘符为sda，只有一个分区sda1。</strong>  </p><img src="/posts/undefined/c0c66cdd50fd5d7a96737c27558de581.png" class="" title="img"><p>使用<strong>df -h命令</strong>查看<strong>Debian系统磁盘占用情况：</strong></p><img src="/posts/undefined/7af2a87480324ba026a3ed3cdb0031f2.png" class="" title="img"><p>咦，怎么没有我们的U盘？因为<strong>没有挂载</strong>，😂😂😂。使用如下命令将我们的U盘挂载在**&#x2F;media&#x2F;UPan<strong>目录下，UPan文件夹是我们</strong>新建<strong>的哈。挂载完成重新使用</strong>df -h命令<strong>查看磁盘状况，发现了我们的U盘，也就是</strong>红色箭头**指向的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &#x2F;dev&#x2F;sda1 &#x2F;media&#x2F;UPan&#x2F;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/219c6b3e6e1d11a08a34fefc4c771d0f.png" class="" title="img"><p>进入U盘内部，<strong>测试能否正常查看其中的文件，</strong>如下图所示，U盘内的确为我备份的一些文件，一切正常。</p><img src="/posts/undefined/f2714fbdf456ef1a5a6de98990c8b18f.png" class="" title="img"><p>在<strong>拔出</strong>U盘之前最好先将<strong>U盘卸载（umount）</strong>，使用如下命令卸载U盘后拔出即可。</p><img src="/posts/undefined/eb3546810ec7561f09c59703a6dd1c65.png" class="" title="img"><p>有关USB驱动我们就不详细分析了（其实我不会，哈哈哈），先照葫芦画个瓢吧。USB驱动是一门很庞大、很复杂的内容，后面有时间多了解下。</p><hr><h2 id="六、主要参考内容-1"><a href="#六、主要参考内容-1" class="headerlink" title="六、主要参考内容"></a>六、主要参考内容</h2><p>1.<a href="https://blog.csdn.net/xzongyuan/article/details/25209465">USB device 和 USB host区别</a>；</p><p>2.<a href="https://blog.csdn.net/qq_34440409/article/details/122994396"> </a><a href="https://www.cnblogs.com/twzy/p/15243838.html">小白自制Linux开发板 七. USB驱动配置 - 淡墨青云 - 博客园</a>；（本文主要参bai考piao）</p><p>\3. <a href="https://javonpeng.blog.csdn.net/article/details/112719638?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-112719638-blog-103346601.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1-112719638-blog-103346601.pc_relevant_default&utm_relevant_index=1">全志sunxi-tools烧录工具安装和使用</a>；</p><p>\4. <a href="https://debugdump.com/topic/2889/sunxi-tool%E5%85%B7%E4%BD%93%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88-f1c200s-sd%E5%8D%A1-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%B7%A5%E5%85%B7">sunxi-tool具体作用是什么？F1C200s &amp; SD卡，能否使用这个工具？</a>；</p><p>\5. <a href="https://blog.csdn.net/u011329967/article/details/106756242">USB PHY芯片_时光-易逝的博客-CSDN博客_usb phy</a>。</p><h1 id="音频驱动"><a href="#音频驱动" class="headerlink" title="音频驱动"></a>音频驱动</h1><h2 id="一、前言-2"><a href="#一、前言-2" class="headerlink" title="一、前言"></a>一、前言</h2><blockquote><p>F1C200s是全志的一款高度集成、低功耗的移动应用处理器，可用于<strong>多种多媒体音视频设备中。</strong></p><p>全志F1C200s基于ARM 9架构，集成了DDR。它支持<strong>高清视频解码</strong>，包括<strong>H.264、H.263、MPEG 1&#x2F;2&#x2F;4等。</strong>它还集成了<strong>音频编解码器和I2S&#x2F;PCM接口，</strong>以增强用户体验。</p></blockquote><p>由上面的介绍可以看出，F1C200s具有<strong>高清视频解码功能，</strong>因此本文使用F1C200s<strong>完成音视频播放功能。</strong>由于本文<strong>对输出音频的品质没有要求，</strong>因此本文<strong>未采用I2S声卡</strong>（ I2S总线有时候也写作 IIS，I2S 是飞利浦公司提出的一种用于数字音频设备之间进行音频数据传输的总线），直接使用F1C200s自带的声卡，<strong>注意，F1C200s自带的声卡比较差劲，对声音品质要求较高请勿采用此方案。</strong></p><blockquote><p>既然<strong>音频CODEC的本质是ADC和DAC，</strong>那么<strong>采样率和采样位数</strong>就是衡量一款音频CODEC最重要的指标。比如常见音频采样率有8K、44.1K、48K、192K甚至384K和768K，采样位数常见的有8位、16位、24位、32位。</p><p>– 正点原子</p></blockquote><p>理解一下上面的概念，后面会提到：</p><p><strong>采样位数</strong>——可以理解数字音频设备处理声音的解析度，即<strong>对声音的辨析度</strong>。就像表示颜色的位数一样（8位表示256种颜色，16位表示65536种颜色），有8位，16位，24位等。这个数值越大，解析度就越高，录制和回放的声音就越真实。</p><p><strong>采样频率</strong>——就是对声音信息<strong>1秒钟采样多少次</strong>，以记录成数字信息。如CD音频是44.1KHz采样率，它对声音以每秒44100次的频率来记录信息。原则上采样率越高，声音的质量越好。</p><hr><h2 id="二、驱动修改"><a href="#二、驱动修改" class="headerlink" title="二、驱动修改"></a><strong>二、驱动修改</strong></h2><blockquote><p>接下来在Linux内核目录中替换下面<strong>补丁包</strong>中的代码，本补丁包在Linux5.7.1下测试成功，其他版本请<strong>备份源码</strong>后尝试，这里的代码是通过<strong>改造sun4i-codec解码方案而来。</strong></p><p>– 墨云</p></blockquote><p><strong>具体修改内容详见</strong><a href="https://lkml.org/lkml/2018/12/2/259%EF%BC%8C%E6%88%96%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E5%A2%A8%E4%BA%91%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E6%A0%B8%E8%A1%A5%E4%B8%81%E5%8C%85%EF%BC%88%E8%BF%99%E6%98%AFAllwinner">https://lkml.org/lkml/2018/12/2/259，或直接使用墨云提供的内核补丁包（这是Allwinner</a> suniv F1C100s支持DMA和音频解码器的RFC补丁），相关讨论详见此处<a href="https://whycan.com/t_2041.html">请问有没有大神搞定了f1c100s的主线kernel4.19下的声卡驱动？</a>，本文直接使用墨云提供的补丁包。</p><p>Suniv F1C100s具有与sun4i<strong>非常相似的DMA。</strong>但也有一些不同之处。 Suniv在时钟控制单元中有一个DMA复位位。它有更小的DMA通道数。几个寄存器有不同的地址。 它的<strong>最大突发大小是 4而不是8，添加一个 quirk 字段以区分它们。</strong>DMA端点编号也不同。</p><hr><h2 id="三、设备树修改"><a href="#三、设备树修改" class="headerlink" title="三、设备树修改"></a>三、设备树修改</h2><h3 id="1、-dtsi文件修改-2"><a href="#1、-dtsi文件修改-2" class="headerlink" title="1、.dtsi文件修改"></a>1、.dtsi文件修改</h3><p>首先在.dtsi文件中添加头文件的引用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings&#x2F;dma&#x2F;sun4i-a10.h&gt; </span><br></pre></td></tr></table></figure><p>然后在<strong>soc结点</strong>下添加如下结点，F1C200s利用<strong>DMA通道</strong>发送和接收ADC-DAC样本，所以需要DMA支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dma: dma-controller@1c02000 &#123;</span><br><span class="line">    compatible &#x3D; &quot;allwinner,suniv-f1c100s-dma&quot;;</span><br><span class="line">    reg &#x3D; &lt;0x01c02000 0x1000&gt;;</span><br><span class="line">    interrupts &#x3D; &lt;18&gt;;</span><br><span class="line">    clocks &#x3D; &lt;&amp;ccu CLK_BUS_DMA&gt;;</span><br><span class="line">    resets &#x3D; &lt;&amp;ccu RST_BUS_DMA&gt;;</span><br><span class="line">    #dma-cells &#x3D; &lt;2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">codec: codec@1c23c00 &#123;</span><br><span class="line">    compatible &#x3D; &quot;allwinner,suniv-f1c100s-codec&quot;;</span><br><span class="line">    reg &#x3D; &lt;0x01c23c00 0x400&gt;;</span><br><span class="line">    interrupts &#x3D; &lt;21&gt;;</span><br><span class="line">    clocks &#x3D; &lt;&amp;ccu CLK_BUS_CODEC&gt;,</span><br><span class="line">         &lt;&amp;ccu CLK_CODEC&gt;;</span><br><span class="line">    clock-names &#x3D; &quot;apb&quot;, &quot;codec&quot;;</span><br><span class="line">    resets &#x3D; &lt;&amp;ccu RST_BUS_CODEC&gt;;</span><br><span class="line">    dmas &#x3D; &lt;&amp;dma SUN4I_DMA_NORMAL 0x0c&gt;, </span><br><span class="line">         &lt;&amp;dma SUN4I_DMA_NORMAL 0x0c&gt;;</span><br><span class="line">    dma-names &#x3D; &quot;rx&quot;, &quot;tx&quot;;</span><br><span class="line">    status &#x3D; &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2、-dts文件修改-2"><a href="#2、-dts文件修改-2" class="headerlink" title="2、.dts文件修改"></a>2、.dts文件修改</h3><p>Allwinner suniv F1C200s 现在具有<strong>基本的音频编解码器支持</strong>，在设备树dts文件中为Lichee Pi Nano开发板激活它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;codec &#123;</span><br><span class="line">    allwinner,audio-routing &#x3D;</span><br><span class="line">    &quot;Headphone&quot;, &quot;HP&quot;,</span><br><span class="line">    &quot;Headphone&quot;, &quot;HPCOM&quot;,</span><br><span class="line">    &quot;MIC&quot;, &quot;Mic&quot;;</span><br><span class="line">    status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="四、驱动使能-1"><a href="#四、驱动使能-1" class="headerlink" title="四、驱动使能"></a>四、驱动使能</h2><p>使用<strong>make menuconfig</strong>图形化配置驱动，进入如下路径，<strong>使能</strong>对应的驱动。<strong>注意：这两个驱动默认处于使能状态。</strong></p><blockquote><p>Device Drivers</p><p>​    -&gt; Sound card support</p><p>​        -&gt; Advanced Linux Sound Architecture</p><p>​            -&gt; ALSA for SoC audio support     </p><p>​                -&gt; Allwinner SoC Audio support<strong>（使能该驱动）</strong></p></blockquote><blockquote><p> Device Drivers</p><p>​    -&gt; DMA Engine support<strong>（使能）</strong></p></blockquote><hr><h2 id="五、启动测试与配置"><a href="#五、启动测试与配置" class="headerlink" title="五、启动测试与配置"></a>五、启动测试与配置</h2><h3 id="1、启动与检查"><a href="#1、启动与检查" class="headerlink" title="1、启动与检查"></a>1、启动与检查</h3><p>重新编译，并上电，可以看到<strong>F1c100s Audio Codec 的声卡配置</strong>如下：</p><img src="/posts/undefined/0f712e64062355b7dbc61aa660337370.png" class="" title="img"><p>使用如下命令<strong>检查声卡，</strong>确实是否正确启动，如下图所示为正常启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;proc&#x2F;asound&#x2F;cards</span><br></pre></td></tr></table></figure><img src="/posts/undefined/30f72be22bfdd73b62e793fbdfb38131.png" class="" title="img"><h3 id="2、默认声卡配置"><a href="#2、默认声卡配置" class="headerlink" title="2、默认声卡配置"></a>2、默认声卡配置</h3><p>使用如下命令<strong>打开asound.conf文件</strong>输入下方内容，Debian文件系统中<strong>可能不存在</strong>这个文件，自行创建即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;asound.conf</span><br><span class="line">defaults.ctl.card 1</span><br><span class="line">defaults.pcm.card 1</span><br><span class="line">defaults.timer.card 1</span><br></pre></td></tr></table></figure><p>如果<strong>未正确配置默认声卡，</strong>在<strong>播放mp3文件</strong>的时候<strong>可能报错</strong>如下：</p><img src="/posts/undefined/d09a930149599441fa133b5cbc4ed84e.png" class="" title="img"><hr><h2 id="六、音频视频播放测试"><a href="#六、音频视频播放测试" class="headerlink" title="六、音频视频播放测试"></a>六、音频视频播放测试</h2><h3 id="1、mplayer与alsa-utils安装"><a href="#1、mplayer与alsa-utils安装" class="headerlink" title="1、mplayer与alsa-utils安装"></a>1、mplayer与alsa-utils安装</h3><p>使用如下命令在我们的开发板中（如果已经配置好无线网卡），或者是qemu模拟器中<strong>安装</strong>两个软件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mplayer</span><br><span class="line">sudo apt-get install alsa-utils</span><br></pre></td></tr></table></figure><p>在<strong>qemu模拟器中</strong>安装<strong>mplayer</strong>报错如下，经过后续测试<strong>并不影响使用。</strong></p><img src="/posts/undefined/66378e67d0fa7c516112411c0612b2c7.png" class="" title="img"><h3 id="2、音频播放测试"><a href="#2、音频播放测试" class="headerlink" title="2、音频播放测试"></a>2、音频播放测试</h3><p>使用如下命令播放准备好的mp3文件，等待<strong>输出以下内容</strong>后开始播放音乐，<strong>按0键增加音量，按9键减小音量。</strong>经测试，音频播放正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer audio.mp3</span><br></pre></td></tr></table></figure><img src="/posts/undefined/96aaa0fd0158ab996a47840b6c4a0f93.png" class="" title="img"><h3 id="3、视频播放测试"><a href="#3、视频播放测试" class="headerlink" title="3、视频播放测试"></a>3、视频播放测试</h3><p>本文使用mplayer进行视频播放测试，使用以下命令查看驱mplayer的帮助信息，从帮助信息中可以看出，**<em>*-vo选项*<em>是用来选择*<em>视频输出驱动的。*</em></em></em></p><img src="/posts/undefined/5eee8f8650ccceebc5bedab12e131acd.png" class="" title="img"><p>使用<strong>命令mplayer -vo help</strong>显示支持的视频驱动，本文使用<strong>fbdev2</strong>进行播放（因为只有fbdev2才能播放，不清楚墨云为什么使用fbdev可以播放）。</p><img src="/posts/undefined/9922c9416356a3945a7ad0e5c26c873b.png" class="" title="img"><p>由于F1C200s的<strong>性能有限</strong>（实在是太有限了），<strong>视频的分辨率和帧率</strong>已经很低很低了，仍然提示系统性能<strong>不支持播放较高分辨率的视频</strong>，如果在项目中使用，建议直接I2S，外接音频解码芯片。如果你<strong>所使用的芯片性能比较差的话mplayer会给你提示如下：</strong></p><img src="/posts/undefined/d695224105c18a43899e3396eec95f99.png" class="" title="img"><p>本文选用<strong>分辨率400x240、帧率5帧</strong>的视频，其<strong>音频采样率为24000，音频质量为64k，****注意视频分辨率不能大于800x480，也就是屏幕分辨率，</strong>使用如下命令播放，同样是<strong>按0键增加音量，按9键减小音量。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -vo fbdev2 400x240_5_24000_64k.mp4 </span><br></pre></td></tr></table></figure><p>经测试视频正常播放，视频<strong>正常播放时</strong>日志输出如下： </p><img src="/posts/undefined/b56b80e2d282662a3f6639418a5e2b35.png" class="" title="img"><hr><h2 id="七、音频输入测试"><a href="#七、音频输入测试" class="headerlink" title="七、音频输入测试"></a>七、音频输入测试</h2><p>输入<strong>alsamixer</strong>命令得到以下图形界面配置，<strong>**（这里还有一点需要补充，按说应该在上一小节说明的，第二个Headphone选项一定要选择DAC，否则无法正常输出音视频），**按下F4**进入</strong>Capture**配置。（F1是帮助）</p><img src="/posts/undefined/c813d5c7c5aeeab17fcfde9a5c8115a6.png" class="" title="img"><p><strong>Mic Boost设置为100，ADC Mixer Mic捕获使能，</strong>或者通过<strong>amixer -c 1 cset numid&#x3D;14 on命令</strong>使能捕获。</p><img src="/posts/undefined/2a2b1cba90b2d48e04052c2635e94f4a.png" class="" title="img"><p>使用<strong>areconrd -l</strong>命令列出捕获<strong>硬件设备列表</strong>，很明显我们要使用<strong>card 1。</strong></p><img src="/posts/undefined/281eb6326cd006f52ada208bf0e17776.png" class="" title="img"><p>根据<a href="https://blog.csdn.net/zkw_1998/article/details/104540239">arecord录音_zkw_1998的博客-CSDN博客_arecord没有声音</a>所说的内容，并参考<a href="https://whycan.com/t_5996.html">如何测试音频驱动比如录音，播放声音？</a>，如下图所示，<strong>指定设备为card 1，设置录音格式为wav，录音10秒。</strong></p><img src="/posts/undefined/9365fb23d240edbde5adb84209a64eb3.png" class="" title="img"><p>根据上面分析得到录音指令为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arecord -D &quot;plughw:1,0&quot; -f S16_LE -r 16000 -d 10 -t wav file.wav</span><br></pre></td></tr></table></figure><p>录音完毕，使用<strong>mplay file.wav</strong>进行播放。经测试，一切正常。</p><p>注：音频播放延迟问题解决方法：**#27楼解决**</p><p><a href="https://whycan.com/t_1791.html">V3s linux 4.13 音频播放延迟了,开始以为是线程同步问题，纠结了很久</a></p><hr><h2 id="八、主要参考内容"><a href="#八、主要参考内容" class="headerlink" title="八、主要参考内容"></a>八、主要参考内容</h2><p>1.<a href="https://whycan.com/t_6113.html">为了精华特意制作F1c200s-MP4播放器，支持硬件H264（开源板子和原理给个精华） &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>\2. <a href="https://whycan.com/t_2891.html">荔枝派音频驱动 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>3.<a href="https://whycan.com/t_5779.html">探讨一下全志芯片的音频接口硬件电路连接应该怎么使用最好 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>4.<a href="https://whycan.com/t_2686.html">请教一下V3S怎么外接扬声器 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a> </p><p>5.<a href="https://whycan.com/t_7583.html">白嫖党的胜利！开源F1C200S桌面小音箱！【验证通过】 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>6.<a href="https://whycan.com/t_6376.html">V3S CODEC的使用及驱动测试（声音播放功能） &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a> </p><p>\7. [请问有没有大神搞定了f1c100s的主线kernel4.19下的声卡驱动？<a href="https://whycan.com/t_2041.html">13楼@wammaw1314搞定声卡驱动,欢迎测试] &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>8.[<a href="https://whycan.com/t_5793.html">慢更]小白探索如何使用V3s播放音乐 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a> </p><p>9.<a href="https://www.cnblogs.com/tankiii/p/13172007.html">mplayer 移植 - Tankiii - 博客园</a></p><p>10.<a href="https://whycan.com/t_1791.html">V3s linux 4.13 音频播放延迟了,开始以为是线程同步问题，纠结了很久 （问题由 @Andy1234 解决，欢迎大家验证） &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>11.<a href="https://www.cnblogs.com/twzy/p/15356109.html">小白自制Linux开发板 八. Linux音频驱动配置 - 淡墨青云 - 博客园</a></p><p>12.<a href="https://whycan.com/t_5996.html">各侠大神，v3s BSP内核 如何测试音频驱动比如录音，播放声音？ &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>13.<a href="https://blog.csdn.net/zkw_1998/article/details/104540239">arecord录音_zkw_1998的博客-CSDN博客_arecord没有声音</a></p><p>14.<a href="https://lkml.org/lkml/2018/12/2/259%E3%80%82">https://lkml.org/lkml/2018/12/2/259。</a></p><h1 id="WiFi驱动"><a href="#WiFi驱动" class="headerlink" title="WiFi驱动"></a>WiFi驱动</h1><h2 id="一、ESP-12F作无线网卡"><a href="#一、ESP-12F作无线网卡" class="headerlink" title="一、ESP-12F作无线网卡"></a>一、ESP-12F作无线网卡</h2><p>本文重点参考<a href="https://whycan.com/viewtopic.php?id=4149&action=onlyshowauthor">众人拾柴-F1C200S通过SPI使用ESP8089或ESP8266做无线网卡</a>和<a href="https://www.cnblogs.com/twzy/p/15160808.html">四. 通过SPI使用ESP8266做无线网卡</a>。通过使用<strong>去掉Flash的ESP-12F</strong>作为F1C200s的无线网卡，使F1C200s获得访问外网的能力。本文配置无线网卡驱动，在对ESP-12F<strong>复位</strong>之后，利用F1C200s通过SPI通信将**固件**下载*<em><strong>到ESP-12F，并通过SPI接口进行</strong>网络数据传输</em>*（我的理解，如有错误，欢迎评论区指正）。至于本文的硬件电路，详见本专栏的第一篇文章。</p><blockquote><p>Linux驱动有<strong>两种运行方式</strong>，第一种就是将驱动<strong>编译进Linux内核</strong>中，这样当Linux内核启动的时候就会自动运行驱动程序。第二种就是将驱动<strong>编译成模块</strong>(Linux下模块扩展名为.ko)，在Linux内核启动以后使用<strong>“insmod”命令或“modprobe”命令</strong>加载驱动模块。在调试驱动的时候一般都选择将其编译为模块，这样我们修改驱动以后只需要编译一下驱动代码即可，不需要编译整个 Linux 代码。</p></blockquote><blockquote><p><strong>再次强调：如果使用ESP-12F模块，请务必去掉模块中的Flash芯片！</strong></p></blockquote><hr><h2 id="二、模块化WiFi驱动"><a href="#二、模块化WiFi驱动" class="headerlink" title="二、模块化WiFi驱动"></a>二、模块化WiFi驱动</h2><p>本节首先<strong>下载ESP8089无线驱动源码（ESP12-F同样适用）</strong>，对源码进行修改后编译生成模块化驱动（.ko文件）,在<strong>Debian文件系统</strong>中加载该驱动，解决加载过程中出现的<strong>一系列问题，</strong>最终配置网络，成功<strong>ping通百度。</strong></p><p><strong>驱动的移植工作主要是：</strong></p><ul><li><strong>配置复位引脚，完成对ESP-12F的复位；</strong></li><li><strong>配置SPI通信，完成固件下载与网络通信；</strong></li><li><strong>配置中断引脚，辅助通信。</strong></li></ul><h3 id="1、无线驱动源码下载"><a href="#1、无线驱动源码下载" class="headerlink" title="1、无线驱动源码下载"></a>1、无线驱动源码下载</h3><p>在此处<a href="https://github.com/notabucketofspam/ESP8089-SPI/blob/master/README.md">ESP8089-SPI&#x2F;README.md at master · notabucketofspam&#x2F;ESP8089-SPI · GitHub</a>下载<strong>esp8089无线网卡驱动，</strong>（是的我们又是用的别人写好的驱动，慢慢来吧，先按照步骤做出来现象，后面理解原理），并在Linux5.7.1<strong>源码根目录</strong>下<strong>创建spiwifi</strong>文件夹，将下载的源码放到该文件夹中。</p><img src="/posts/undefined/754348c5f01983dea6ce74f684309a9e.png" class="" title="img"><h3 id="2、无线驱动源码适配"><a href="#2、无线驱动源码适配" class="headerlink" title="2、无线驱动源码适配"></a>2、无线驱动源码适配</h3><p>首先修改<strong>无线驱动项目的**KBUILD*<em>*<em><strong>，</strong>使其指向 <strong>Linux-5.7.1</strong>内核构建树的路径（</em>*内核源码目录</em>*）。KBUILD变量主要用来</strong>生成<strong>一些和</strong>汇编有关<strong>的文件（Kconfig是图形界面的描述文件）。并且添加架构和交叉编译器信息，至于本文为何使用</strong>arm-linux-gnueabi-编译器，**怎么和迪卡、墨云等人的不同，原因见这里<a href="https://debugdump.com/topic/2894/f1c200s%E6%97%A0%E7%BA%BF%E7%BD%91%E5%8D%A1%E9%97%AE%E9%A2%98%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91?_=1674179508025">F1C200s无线网卡问题源码编译？</a>。</p><img src="/posts/undefined/784df72c8dbf40ba5ab9c61283328f40.png" class="" title="img"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># modify by kashine 5</span><br><span class="line"># KBUILD ?&#x3D; $(shell readlink -f &#x2F;lib&#x2F;modules&#x2F;$(KVERS_UNAME)&#x2F;build)</span><br><span class="line">KBUILD ?&#x3D; &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;</span><br><span class="line">ARCH ?&#x3D; arm</span><br><span class="line">CROSS_COMPILE ?&#x3D; arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>修改<strong>KBUILD、ARCH、CROSS_COMPILE</strong>之后，使用<strong>make命令</strong>进行编译。然而并没有像迪卡那样报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** WARNING: This kernel lacks wireless extensions.</span><br><span class="line">Wireless drivers will not work properly.</span><br></pre></td></tr></table></figure><p>为了不影响后续的操作，我们同样进行对****内核源码目录*<em><strong>中的</strong></em>*&#x2F;net&#x2F;wireless&#x2F;Kconfig文件*<em><strong>开头部分进行以下</strong>修改</em>*：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config WIRELESS_EXT</span><br><span class="line">    bool</span><br><span class="line">    #更改为</span><br><span class="line">    def_bool y</span><br></pre></td></tr></table></figure><p>前面我们提到需要对<strong>ESP12F进行复位</strong>，并且需要<strong>中断支持，</strong>一方面需要<strong>配置设备树，</strong>另一方面需要对<strong>驱动源码</strong>进行修改。在无线驱动源码目录中的<strong>spi_stub.c文件</strong>中进行如下修改，<strong>管脚编号对应关系为：PA0 – 0；PB0 – 32；PC0 – 64；PD0 – 96；PE0 – 128。</strong></p><img src="/posts/undefined/6ccf45352c2b1a7fb850d7adfff14a03.png" class="" title="img"><img src="/posts/undefined/b3983e2121a1feeb3f5ec56e9e0ae9f2.png" class="" title="img"><img src="/posts/undefined/00fb17896fc1226c497e61e654047049.png" class="" title="img"><p>修改完成以后，使用<strong>重新编译，</strong>编译<strong>输出log</strong>如下，警告可以忽略（变量声明位置不合适）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">make -C &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F; M&#x3D;&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#39;</span><br><span class="line">  AR      &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;built-in.a</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_debug.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;sdio_sif_esp.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_io.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_file.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_main.o</span><br><span class="line">In file included from .&#x2F;include&#x2F;linux&#x2F;mm_types.h:12:0,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;mmzone.h:21,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;gfp.h:6,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;slab.h:15,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;crypto.h:19,</span><br><span class="line">                 from .&#x2F;include&#x2F;crypto&#x2F;hash.h:11,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;uio.h:10,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;socket.h:8,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;compat.h:15,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;ethtool.h:17,</span><br><span class="line">                 from .&#x2F;include&#x2F;linux&#x2F;netdevice.h:37,</span><br><span class="line">                 from &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_main.c:17:</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_main.c: In function ‘esp_pub_init_all’:</span><br><span class="line">.&#x2F;include&#x2F;linux&#x2F;completion.h:54:2: warning: ISO C90 forbids mixed declarations and code [-Wdeclaration-after-statement]</span><br><span class="line">  struct completion work &#x3D; COMPLETION_INITIALIZER(work)</span><br><span class="line">  ^</span><br><span class="line">.&#x2F;include&#x2F;linux&#x2F;completion.h:74:43: note: in expansion of macro ‘DECLARE_COMPLETION’</span><br><span class="line"> # define DECLARE_COMPLETION_ONSTACK(work) DECLARE_COMPLETION(work)</span><br><span class="line">                                           ^~~~~~~~~~~~~~~~~~</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_main.c:81:2: note: in expansion of macro ‘DECLARE_COMPLETION_ONSTACK’</span><br><span class="line">  DECLARE_COMPLETION_ONSTACK(complete);</span><br><span class="line">  ^~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">In file included from &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_main.c:221:0:</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;eagle_fw1.h: In function ‘esp_download_fw’:</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;eagle_fw1.h:8:1: warning: ISO C90 forbids mixed declarations and code [-Wdeclaration-after-statement]</span><br><span class="line"> static u8 eagle_fw1[] &#x3D;</span><br><span class="line"> ^~~~~~</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_sip.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ext.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.o</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.c: In function ‘sip_send_ampdu_action’:</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.c:479:29: warning: this statement may fall through [-Wimplicit-fallthrough&#x3D;]</span><br><span class="line">                 action-&gt;ssn &#x3D; ssn;</span><br><span class="line">                 ~~~~~~~~~~~~^~~~~</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.c:480:9: note: here</span><br><span class="line">         case SIP_AMPDU_RX_STOP:</span><br><span class="line">         ^~~~</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.c:481:31: warning: this statement may fall through [-Wimplicit-fallthrough&#x3D;]</span><br><span class="line">                 action-&gt;index &#x3D; index;</span><br><span class="line">                 ~~~~~~~~~~~~~~^~~~~~~</span><br><span class="line">&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_ctrl.c:482:9: note: here</span><br><span class="line">         case SIP_AMPDU_TX_OPERATIONAL:</span><br><span class="line">         ^~~~</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_mac80211.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_utils.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp_pm.o</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;testmode.o</span><br><span class="line">  LD [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp8089-spi.o</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp8089-spi.mod.o</span><br><span class="line">  LD [M]  &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;esp8089-spi.ko</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#39;</span><br></pre></td></tr></table></figure><h3 id="3、设备树修改"><a href="#3、设备树修改" class="headerlink" title="3、设备树修改"></a>3、设备树修改</h3><p>添加<strong>SPI管脚复用</strong>与<strong>spi0结点</strong>，注意在dtsi中<strong>未对spi0进行使能。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在pio分组添加</span><br><span class="line">spi0_pc_pins: spi0-pc-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PC0&quot;,&quot;PC1&quot;,&quot;PC2&quot;,&quot;PC3&quot;;</span><br><span class="line">                function &#x3D; &quot;spi0&quot;;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在soc分组下添加</span><br><span class="line">spi0:spi@1c05000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-spi&quot;,</span><br><span class="line">&quot;allwinner,sun8i-h3-spi&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c05000 0x1000&gt;;</span><br><span class="line">interrupts &#x3D; &lt;10&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_SPI0&gt;, &lt;&amp;ccu CLK_BUS_SPI0&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;, &quot;mod&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_SPI0&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;spi0_pc_pins&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在dts文件中对<strong>spi0结点进行使能，**为什么没有添加中断复位引脚呢？*<em><strong>因为我们下载的源码是</strong>板级描述文件</em>*（</strong>大概意思是，驱动源码和设备树没有关系，直接在代码中获取硬件信息**），直接在源码中指定即可，也就是上一小节指定的中断和复位引脚。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;spi0 &#123;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，我们需要在<strong>使能SPI驱动配置，</strong>在.config中保证如下驱动处于<strong>使能状态：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_SPI&#x3D;y</span><br><span class="line">CONFIG_SPI_MASTER&#x3D;y</span><br><span class="line">CONFIG_SPI_SUN4I&#x3D;y</span><br><span class="line">CONFIG_SPI_SPIDEV&#x3D;y</span><br><span class="line">CONFIG_SPI_SUN6I&#x3D;y</span><br></pre></td></tr></table></figure><p>此处有个坑，我们在配置.config文件的时候，<strong>一定要删除对应的注释，</strong>比如我们要配置使能<strong>CONFIG_SPI_ALTERA</strong>，那么一定要将对应的注释<strong>“CONIFG_SPI_ALTERA is not set”<strong>删除，否则</strong>可能无法成功使能</strong>对应驱动。详见<a href="https://blog.csdn.net/whahu1989/article/details/86516233">warning: override: reassigning to symbol 问题解决。</a></p><img src="/posts/undefined/40f69e9cc9fd74c7656d9cedcd943308.png" class="" title="img"><h3 id="4、模块驱动加载"><a href="#4、模块驱动加载" class="headerlink" title="4、模块驱动加载"></a>4、模块驱动加载</h3><p>将编译产生的<strong>esp8089-spi.ko驱动文件</strong>拷贝到<strong>Debian根文件系统</strong>（TF卡rootfs分区）的**&#x2F;lib&#x2F;*<em><strong>modules&#x2F;5.7.1</strong>文件夹下，如果</em><em>文件夹路径不存在<strong>需要</strong>手动创建<strong>对应的文件夹，文件夹名字一定要下配置正确，5.7.1是</strong>内核版本号，<strong>需要根据实际情况修改，当然，重新编译过的Linux</strong>内核镜像文件<strong>与</strong>设备树文件<strong>也需要更新。</strong>注意：本文直接使用的Debian根文件系统，因为buildroot制作的根文件系统各种命令都缺，而buildroot编译过于繁琐耗时。*</em></p><h4 id="📌-模块驱动加载命令"><a href="#📌-模块驱动加载命令" class="headerlink" title="📌 模块驱动加载命令"></a>📌 模块驱动加载命令</h4><p>更新对应的文件之后，上电启动，使用<strong>ls命令</strong>可以看到我们编译产生的驱动文件。我们首先说明模块驱动的加载方式：</p><blockquote><p>驱动编译完成以后<strong>扩展名为.ko，</strong>有两种命令可以**加载驱动模块：*<em>insmod和modprobe。*</em> **insmod 命令不能解决模块的依赖关系，*<em><strong>比如 drv.ko 依赖 first.ko 这个模块，就必须先使用insmod 命令加载 first.ko 这个模块，然后再加载 drv.ko 这个模块。</strong>而modprobe 会分析模块的依赖关系，</em>*然后会将所有的依赖模块都加载到内核中，modprobe 命令默认会去&#x2F;lib&#x2F;modules&#x2F;<kernel-version>目录中查找模块。</p></blockquote><blockquote><p>另外有一点需要注意，<strong>使用modprobe命令之前需要使用depmod命令，</strong>depmod命令可检测<strong>模块的相依性</strong>，供modprobe在安装模块时使用。</p></blockquote><h4 id="📌-驱动加载、遇到的问题、解决方法"><a href="#📌-驱动加载、遇到的问题、解决方法" class="headerlink" title="📌 驱动加载、遇到的问题、解决方法"></a>📌 驱动加载、遇到的问题、解决方法</h4><p>进入**&#x2F;lib&#x2F;modules&#x2F;5.7.1<strong>文件夹，使用</strong>depmod**命令检测驱动模块相依性，但是会报错如下，提示没有对应的文件（挠头，怎么会没有文件呢？）。</p><img src="/posts/undefined/e27805be29ea570cbf35e07e2504ce30.png" class="" title="img"><p>参考这个博客<a href="https://blog.csdn.net/linfengXBB/article/details/122511860">depmod: ERROR: could not open directory &#x2F;lib&#x2F;modules&#x2F;5.2.0-licheepi-zero+: No such file or dir</a>，将内核中的<strong>modules.order和modules.builtin</strong>这两个文件拷贝到根文件系统的**&#x2F;lib&#x2F;modules&#x2F;5.7.1**文件夹中，这两个文件在内核源码根目录下，如下图所示：</p><img src="/posts/undefined/e78f2e8c42996fbc06648dfbd1f69060.png" class="" title="img"><p>复制完成，重新上电启动，在**&#x2F;lib&#x2F;modules&#x2F;5.7.1<strong>文件夹使用</strong>depmod命令<strong>不再出现报错，使用depmod完成模块相依性检测后，通过</strong>modprobe命令<strong>加载驱动，需注意的是，以下两个命令只有</strong>后者才可以正常执行。**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">modprobe esp-8089.ko # 无法正常运行</span><br><span class="line">modprobe esp-8089    # 可正常运行</span><br></pre></td></tr></table></figure><img src="/posts/undefined/f32915e272ac25a1119383ac4e4dd52f.png" class="" title="img"><h4 id="📌-驱动问题解决"><a href="#📌-驱动问题解决" class="headerlink" title="📌 驱动问题解决"></a>📌 驱动问题解决</h4><p><strong>modprobe执行成功，</strong>但是我们的<strong>驱动并没有正确加载</strong>，细心的朋友可以发现在加载完驱动之后，打印出以下信息，这说明我们的<strong>驱动代码既没有找到SPI主设备，有没有创建SPI从设备，</strong>这显然是不允许的，因为<strong>SPI是我们进行无线通信的基础。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esp8089_spi: FAILED to find master</span><br><span class="line">esp8089_spi: FAILED to create slave</span><br></pre></td></tr></table></figure><p> 经过迪卡大佬的排查，发现是无线驱动代码中<strong>spi_stub.c文件</strong>出错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct spi_device* sif_platform_new_device(void) &#123;</span><br><span class="line">  master &#x3D; spi_busnum_to_master(esp_board_spi_devices[0].bus_num);</span><br><span class="line">  if(!master)</span><br><span class="line">    printk(&quot;esp8089_spi: FAILED to find master\n&quot;);&#x2F;&#x2F; 报错</span><br><span class="line">  spi &#x3D; spi_new_device( master, esp_board_spi_devices );</span><br><span class="line">  if(!spi)</span><br><span class="line">    printk(&quot;esp8089_spi: FAILED to create slave\n&quot;);&#x2F;&#x2F; 报错</span><br><span class="line">  printk(&quot;esp8089_spi: I will go dead\n&quot;);</span><br><span class="line">  if(spi_setup(spi))</span><br><span class="line">    printk(&quot;esp8089_spi: FAILED to setup slave\n&quot;); </span><br><span class="line">  printk(&quot;esp8089_spi: I am OK\n&quot;);</span><br><span class="line">  return spi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说下面的代码出了问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master &#x3D; spi_busnum_to_master(esp_board_spi_devices[0].bus_num);</span><br></pre></td></tr></table></figure><p>其中，<strong>esp_board_spi_devices[]<strong>为</strong>spi_stub.c文件</strong>前面定义的结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct spi_board_info esp_board_spi_devices[] &#x3D; &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    .modalias &#x3D; &quot;ESP8089_0&quot;,</span><br><span class="line">    .max_speed_hz &#x3D; MAX_SPEED_HZ,</span><br><span class="line">    .bus_num &#x3D; 1,</span><br><span class="line">    .chip_select &#x3D; 0,</span><br><span class="line">    .mode &#x3D; 0,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>迪卡分析：</strong></p><p>bus_num就是1；spi_busnum_to_master(1)研究一下；每个master都对应一个bus num。<br><strong>注册spi slave设备（ESP-12F SPI），由dts解析得到，dts会指定spi slave挂载在哪个bus num下，由bus num就可以得到对应的spi master 了。（可能不合理，但能跑）</strong></p></blockquote><p> ****将bus_num改为0后，**重新编译无线驱动代码并上电运行，**打印信息如下：</p><img src="/posts/undefined/7c86865c8be03390097858ca76f248a0.png" class="" title="img"><p>奇怪不奇怪，我们的<strong>spi0</strong>分明<strong>没有作为其他设备</strong>的通信接口，但是报错信息提示我们<strong>片选地址已被使用。</strong> </p><blockquote><p><strong>墨云分析：</strong></p><p>可见<strong>spi_master已经注册成功</strong>，但是<strong>chipselect 0 already in use</strong>，说明当前配置SPI0，中<strong>片选为0的地址已经被使用，</strong>实时上我们并未链接其他设备，所以怀疑是其他问题，通过查找资料SPI通信模式分为4中模式，经过逐一测试发现SPI_MODE_3也就是(4)可用。</p></blockquote><p>根据墨云的分析对<strong>无线驱动代码spi_stub.c文件</strong>中的代码进行修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct spi_board_info esp_board_spi_devices[] &#x3D; &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    .modalias &#x3D; &quot;ESP8089_0&quot;,</span><br><span class="line">    .max_speed_hz &#x3D; MAX_SPEED_HZ,</span><br><span class="line">    .bus_num &#x3D; 0,&#x2F;&#x2F; modify by kashine 5</span><br><span class="line">    .chip_select &#x3D; 0,</span><br><span class="line">    .mode &#x3D; SPI_MODE_3,&#x2F;&#x2F; modify by kashine 5</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改后重新编译，上电后加载esp-8089驱动。****注意，如果使用我的硬件电路，一定要注意，如果屏幕较大，并且同时使用无线模块，可能导致供电不足，现象是屏幕熄灭、串口关闭，解决办法是除串口USB之外，利用USB HUB扩展的USB接口增加一个USB供电。**模块驱动加载日志**如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">root@likaiqin-virtual-machine:&#x2F;lib&#x2F;modules&#x2F;5.7.1# modprobe esp8089-spi</span><br><span class="line">[  128.493238] esp8089_spi: loading out-of-tree module taints kernel.</span><br><span class="line">[  128.508273] esp8089_spi: EAGLE DRIVER VER bdf5087c3deb</span><br><span class="line">[  129.114478] esp8089_spi: esp_spi_dummy_probe enter</span><br><span class="line">[  129.120111] esp8089_spi: register board OK</span><br><span class="line">[  129.124623] esp8089_spi: sem_timeout &#x3D; 0</span><br><span class="line">[  129.340023] esp8089_spi: ESP8089 power up OK</span><br><span class="line">[  129.345448] esp8089_spi: esp_spi_probe ENTER</span><br><span class="line">[  129.350322] esp8089_spi: esp_setup_spi</span><br><span class="line">[  129.354477] esp8089_spi: sif_spi_protocol_init</span><br><span class="line">[  129.359437] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1559</span><br><span class="line">[  129.370920] esp8089_spi: fail_count &#x3D; 0</span><br><span class="line">[  129.498009] rx:[0x00],[0x00],[0x00],[0x00],[0x00],[0x00],[0x00],[0x00],[0x00],[0x00]</span><br><span class="line">[  129.606625] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1559</span><br><span class="line">[  129.618134] esp8089_spi: fail_count &#x3D; 1</span><br><span class="line">[  129.733228] rx:[0x3f],[0x09],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  129.841860] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1559</span><br><span class="line">[  129.853379] esp8089_spi: fail_count &#x3D; 2</span><br><span class="line">[  130.054228] rx:[0xff],[0xff],[0x01],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  130.661815] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1578</span><br><span class="line">[  130.679097] rx:[0xff],[0xff],[0x01],[0x10],[0xff],[0xff],[0x00],[0xff],[0xff],[0xff]</span><br><span class="line">[  131.186870] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1591</span><br><span class="line">[  131.230265] rx:[0xff],[0xff],[0x00],[0x90],[0xff],[0xff],[0x00],[0xff],[0xff],[0xff]</span><br><span class="line">[  131.751505] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1603</span><br><span class="line">[  131.795833] rx:[0xff],[0x00],[0x02],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  132.317567] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1617</span><br><span class="line">[  132.363805] rx:[0xff],[0x00],[0x03],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  132.886662] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1630</span><br><span class="line">[  132.935628] rx:[0xff],[0x00],[0x02],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  133.459909] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1643</span><br><span class="line">[  133.512035] rx:[0xff],[0x00],[0x03],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  134.037354] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  134.091882] rx:[0xff],[0xff],[0x00],[0x00],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  134.617589] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  134.672142] rx:[0xff],[0xff],[0x00],[0x25],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  135.198185] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  135.254763] rx:[0xff],[0xff],[0x00],[0x10],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  135.780766] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  135.834891] rx:[0xff],[0xff],[0x00],[0x12],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  136.361421] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  136.416215] rx:[0xff],[0xff],[0x00],[0x00],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  136.942723] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  136.997550] rx:[0xff],[0xff],[0x00],[0x06],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  137.523992] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  137.578214] rx:[0xff],[0xff],[0x00],[0x00],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  138.104701] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1655</span><br><span class="line">[  138.159169] rx:[0xff],[0xff],[0x00],[0x00],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  138.685676] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1668</span><br><span class="line">[  138.740390] rx:[0xff],[0x00],[0x00],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  138.767739] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1681</span><br><span class="line">[  138.834001] rx:[0xff],[0x00],[0x02],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  138.861304] esp8089_spi: &#x2F;home&#x2F;project01&#x2F;pro01&#x2F;new_kernel&#x2F;linux-5.7.1&#x2F;spiwifi&#x2F;ESP8089-SPI-github&#x2F;spi_sif_esp.c, 1694</span><br><span class="line">[  138.963902] rx:[0xff],[0x00],[0x01],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff],[0xff]</span><br><span class="line">[  139.998233] esp8089_spi: esp_pub_init_all</span><br><span class="line">[  140.021398] esp8089_spi: esp_download_fw</span><br><span class="line">[  140.459848] esp8089_spi: sif_platform_irq_init enter</span><br><span class="line">[  150.889369] resetting event timeout</span><br><span class="line">[  150.910574] esp8089_spi: esp_init_all failed: -110</span><br><span class="line">[  150.932966] esp8089_spi: first error exit</span><br><span class="line">[  150.954067] esp8089_spi: esp_spi_probe EXIT</span><br><span class="line">[  150.975268] esp8089_spi: sem_timeout &#x3D; 0</span><br><span class="line">[  150.995481] esp8089_spi: esp_spi_init err 0</span><br><span class="line">root@likaiqin-virtual-machine:&#x2F;lib&#x2F;modules&#x2F;5.7.1# </span><br></pre></td></tr></table></figure><p>从上面的驱动加载日志中可以就看出<strong>两个信息</strong>，<strong>一个是固件下载成功，一个是超时问题。</strong></p><img src="/posts/undefined/8305e8218100d01d981566e9b5374900.png" class="" title="img"><p>针对<strong>超时问题，</strong>采用迪卡的<strong>屏蔽操作</strong>，相当于强制跳过超时警告执行。修改<strong>无线驱动源码的****esp_sip.c文件</strong>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">extern struct task_struct *sif_irq_thread;&#x2F;&#x2F; 声明变量</span><br><span class="line">sip_poll_bootup_event(struct esp_sip *sip)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        esp_dbg(ESP_DBG_TRACE, &quot;polling bootup event... \n&quot;);</span><br><span class="line"></span><br><span class="line">if (gl_bootup_cplx)</span><br><span class="line">ret &#x3D; wait_for_completion_timeout(gl_bootup_cplx, 2 * HZ);</span><br><span class="line"></span><br><span class="line">esp_dbg(ESP_DBG_TRACE, &quot;******time remain****** &#x3D; [%d]\n&quot;, ret);</span><br><span class="line">if (ret &lt;&#x3D; 0) &#123;</span><br><span class="line">esp_dbg(ESP_DBG_ERROR, &quot;bootup event timeout\n&quot;);</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; modify by kashine 5</span><br><span class="line">                &#x2F;&#x2F; return -ETIMEDOUT;</span><br><span class="line">                sip-&gt;epub-&gt;wait_reset &#x3D; 0;</span><br><span class="line">                wake_up_process(sif_irq_thread);</span><br><span class="line">                esp_dbg(ESP_DBG_ERROR, &quot;for unknow reason,we may not be informed the boot&#x2F;rst complete event, assume it completed and continue here\n&quot;);</span><br><span class="line">                msleep(50);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">if(sif_get_ate_config() &#x3D;&#x3D; 0)&#123;</span><br><span class="line">ret &#x3D; esp_register_mac80211(sip-&gt;epub);</span><br><span class="line">&#125;</span><br><span class="line">sip_poll_resetting_event(struct esp_sip *sip)</span><br><span class="line">&#123;</span><br><span class="line">int ret &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        esp_dbg(ESP_DBG_TRACE, &quot;polling resetting event... \n&quot;);</span><br><span class="line"></span><br><span class="line">if (gl_bootup_cplx)</span><br><span class="line">ret &#x3D; wait_for_completion_timeout(gl_bootup_cplx, 10 * HZ);</span><br><span class="line"></span><br><span class="line">esp_dbg(ESP_DBG_TRACE, &quot;******time remain****** &#x3D; [%d]\n&quot;, ret);</span><br><span class="line">if (ret &lt;&#x3D; 0) &#123;</span><br><span class="line">esp_dbg(ESP_DBG_ERROR, &quot;resetting event timeout\n&quot;);</span><br><span class="line">                &#x2F;&#x2F; modify by kashine 5</span><br><span class="line">                &#x2F;&#x2F; return -ETIMEDOUT;</span><br><span class="line">                sip-&gt;epub-&gt;wait_reset &#x3D; 0;</span><br><span class="line">                wake_up_process(sif_irq_thread);</span><br><span class="line">                esp_dbg(ESP_DBG_ERROR, &quot;for unknow reason,we may not be informed the boot&#x2F;rst complete event, assume it completed and continue here\n&quot;);</span><br><span class="line">                msleep(50);</span><br><span class="line">        &#125;    </span><br><span class="line">      </span><br><span class="line">        esp_dbg(ESP_DBG_TRACE, &quot;target resetting %d %p\n&quot;, ret, gl_bootup_cplx);</span><br></pre></td></tr></table></figure><p>修改完成，<strong>重新编译</strong>上电启动，加载驱动后， 输出日志如下（部分）：</p><img src="/posts/undefined/f1ff4f1747002bf4b78843013292919e.png" class="" title="img"><h3 id="5、启动网卡"><a href="#5、启动网卡" class="headerlink" title="5、启动网卡"></a>5、启动网卡</h3><p>至此，<strong>需要加载esp8089无线驱动，</strong>然后使用命令<strong>ifconfig wlan0 up启动网卡：</strong></p><img src="/posts/undefined/9ab34caf5e587aae741b42db241e4333.png" class="" title="img"><p>使用<strong>ifconfig查看网卡：</strong></p><img src="/posts/undefined/0d96788e43d1f051a6ef6ee28a559bf8.png" class="" title="img"><h3 id="6、连接互联网"><a href="#6、连接互联网" class="headerlink" title="6、连接互联网"></a>6、连接互联网</h3><p>在<strong>Debian根文件系统制作</strong>的时候，我们已经<strong>安装了对应的网络组件，</strong>此处我们<strong>使用组件wpa_supplicant连接wifi，</strong>wifi为我的手机热点。在<strong>Debian根文件系统的&#x2F;etc目录下</strong>创建配置文件，并按照以下格式<strong>输入wifi信息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;wpa_supplicant.conf</span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">  ssid&#x3D;&quot;wifi名称&quot;</span><br><span class="line">  psk&#x3D;&quot;wifi密码&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行如下指令进行wifi连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -B -d -i wlan0 -c &#x2F;etc&#x2F;wpa_supplicant.conf</span><br></pre></td></tr></table></figure><img src="/posts/undefined/415f08b0f8898fe9f9e972bd6a8d27a6.png" class="" title="img"><img src="/posts/undefined/06398bad6c8f654fe38d6a772551ad1d.png" class="" title="img"><p>**执行*<em>udhcpc -i wlan0*<em>命令，获取IP地址：</em></em></p><img src="/posts/undefined/794f0909dd796e97df91aab2f9966498.png" class="" title="img"><p> <strong>ping一下百度试试：</strong></p><img src="/posts/undefined/73618b5b0db458276fc4f2e15f3247a9.png" class="" title="img"><h3 id="7、apt-get命令测试"><a href="#7、apt-get命令测试" class="headerlink" title="7、apt-get命令测试"></a>7、apt-get命令测试</h3><p>之前我们在<strong>制作Debian根文件系统</strong>的时候，安装过<strong>evtest触摸屏测试</strong>软件，现在我们把它<strong>卸载</strong>掉，然后<strong>重新安装</strong>，以此测试<strong>apt-get安装软件</strong>是否正常。首先使用<strong>dpkg –list</strong>查看是否安装了evtest软件。</p><img src="/posts/undefined/62328a4b6ccd62e329e47006ed64e4b4.png" class="" title="img"><p>如果安装了evtest软件，使用<strong>apt-get remove命令卸载</strong>，在卸载过程中，弹出了一堆的<strong>报错信息</strong>如下，我们来分析一下，<strong>systemd-journal invoked oom-killer，</strong>提示进程被杀掉，OOM killer(Out Of Memory killer)，该机制会<strong>监控那些占用内存过大</strong>，尤其是<strong>瞬间占用内存很快</strong>的进程，<strong>防止内存耗尽</strong>而自动把该进程杀掉。<em><strong>*这样看应该是内核检测到系统内存不足、挑选并杀掉某个进程。*</strong></em></p><img src="/posts/undefined/c9706b3f11c0e6b56170f5ddd8ff0930.png" class="" title="img"><p>为什么会内存不足呢？DDR有64M，我们在<strong>制作根文件系统</strong>的时候添加了<strong>swap分区，</strong>将一部分硬盘作为<strong>虚拟内存，</strong>使用<strong>free命令</strong>查看一下内存的使用情况，咦，<strong>swap分区怎么是0？</strong>后来发现我多次制作根文件系统，在<strong>重新制作根文件系统</strong>的时候没有添加swap分区。</p><img src="/posts/undefined/07c45a78f0a6f6efe93c11f7a6b1c513.png" class="" title="img"><p>按照Debian根文件系统制作博客的教程<strong>重新建立swap分区</strong>，如下：</p><img src="/posts/undefined/19961f5e53be6a00c7cb9fa794a0aec0.png" class="" title="img"><p>重新卸载<strong>evtest软件，</strong>不再报错。</p><img src="/posts/undefined/66acc46d39339cac4323bbe8ef531589.png" class="" title="img"><p> 使用<strong>dpkg –list命令</strong>查看是否成功卸载，发现不存在evtest软件，<strong>正常卸载。</strong></p><img src="/posts/undefined/4413562f035878e54fb627b2099f5e5f.png" class="" title="img"><p>重新安装evtest软件，正常安装。<strong>至此，F1C200s无线网卡驱动完成，可以直接使用apt-get命令安装软件了，不必在Ubuntu下使用qemu模拟器安装。</strong></p><img src="/posts/undefined/85766069075a43d5023e943d00b0ba8d.png" class="" title="img"><h3 id="8、文件传输"><a href="#8、文件传输" class="headerlink" title="8、文件传输"></a>8、文件传输</h3><p><strong>如何在虚拟机中的Ubuntu和我们的开发板之间传输文件呢？</strong></p><p>首先保证我们的<strong>物理机、Ubuntu虚拟机、开发板</strong>在同一个热点的<strong>同一个网段</strong>下，可以<strong>相互ping通，</strong>如下图所示，这里我就不再赘述，详细内容参考<a href="https://blog.csdn.net/qq_41709234/article/details/124175809">linux开发板访问互联网 笔记本win10中虚拟机_Kashine的博客-CSDN博客</a>。</p><img src="/posts/undefined/2942c4ace6cf53540457d3da7e5752fe.png" class="" title="img"><img src="/posts/undefined/35c919fd794327e327748acc463b4711.png" class="" title="img"><p>为了防止混淆，使用<strong>vi &#x2F;etc&#x2F;hostname</strong>命令<strong>修改主机名，</strong>将主机Ubuntu命名为<strong>Ubuntu，</strong>开发板命名为：<strong>Debian。</strong></p><img src="/posts/undefined/1cad0dbef099f5553835ffe36282b131.png" class="" title="img"><img src="/posts/undefined/018c548b52fae84450114d94df2aef5d.png" class="" title="img"><p>Debian和Ubuntu都要打开允许ssh以root登录， 使用 <strong>vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config命令</strong>打开文件写入<strong>PermitRootLogin yes，</strong>如果未使能<strong>服务端SSH服务配置了root用户登录策略，</strong>会产生<strong>“Permission denied, please try again.”</strong>的报错提示。</p><img src="/posts/undefined/801e11fa7c01f03f101394c6e166eac7.png" class="" title="img"><img src="/posts/undefined/34a2a195a4c466a779cf4e36f3ed44ae.png" class="" title="img"><img src="/posts/undefined/cbed3e023d55d1ab7f7cf45f6dfecc13.png" class="" title="img"><p>配置完成后，使用如下命令<strong>进入Debian:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ssh root@Debian ip</span><br><span class="line">ssh root@192.168.180.164</span><br></pre></td></tr></table></figure><img src="/posts/undefined/ccaffc285cf97b06a558cef85f5580c7.png" class="" title="img"><p> 可以<strong>在Ubuntu中控制Debian</strong>播放<strong>mp3文件或者是mp4文件：</strong></p><img src="/posts/undefined/0983e83d806329002b5ef0e544de2154.png" class="" title="img"><img src="/posts/undefined/a5a1ef096faeb64864904c5b981e3ba2.png" class="" title="img"><p>跑题了，跑题了，怎么放音乐看视频去了，大年初一可以放松一下，哈哈。来看<strong>文件传输，</strong>首先使用<strong>exit命令</strong>退出上面的<strong>远程访问。</strong>如果<strong>欲将Ubuntu中的文件复制到Debian中，</strong>应该怎么操作呢？在Debian中使用指令<strong>scp <a href="mailto:&#114;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#56;&#x30;&#46;&#49;&#54;&#52;">&#114;&#x6f;&#x6f;&#x74;&#x40;&#x31;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#46;&#49;&#56;&#x30;&#46;&#49;&#54;&#52;</a>(Ubuntu的ip):&#x2F;Ubuntu中文件路径 &#x2F;拷贝到Debian中的位置</strong>可以将Ubuntu中文件拷贝到Debian中。可以看到<strong>传输速度为734.4KB&#x2F;s</strong>还可以吧，说的过去，<strong>整个过程不消耗流量哦（我是用的手机热点）。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.180.59:&#x2F;mnt&#x2F;hgfs&#x2F;Desktop&#x2F;opencv3.4.13bit32.rar .&#x2F;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/c94fffc8e38119212c1577af33f8ca0b.png" class="" title="img"><img src="/posts/undefined/902bfc1914286dcd5d2ae62b36db2f1d.png" class="" title="img"><p>至此， 本文的需求全部解决，至于墨云所说开发板<strong>只要大量发送数据，</strong>比如作为Web服务器被访问，<strong>wifi就挂了，</strong>本文测试了在Ubuntu下<strong>将Debian中的文件拷贝到Ubuntu，</strong>也就是<strong>开发板发送数据，</strong>并未出现报错或者wifi断开的情况。</p><img src="/posts/undefined/35803ad1bd3fcc7a0cf1c0bf9c7458da.png" class="" title="img"><p>我错了我错了，又试了一次，<strong>wifi挂了。</strong></p><img src="/posts/undefined/4c80941c372d773fd1ef9eeb2afe26db.png" class="" title="img"><p>Debian<strong>接收数据</strong>经过<strong>连续多次测试正常。</strong></p><img src="/posts/undefined/d542b963d5f70286bf8ffff6bd1246cb.png" class="" title="img"><p>经连<strong>续多次测试</strong>发现<strong>发送数据</strong>也没有问题，bug无法复现，可能是发送的文件太小，随缘解决吧。</p><img src="/posts/undefined/d6f032538e17aef39fcaa34a8fdef281.png" class="" title="img"><p>至此，无线网卡功能全部实现，但我们发现<strong>每次上电之后都需要加载驱动，</strong>很是麻烦，能不能直接<strong>将驱动编译到内核</strong>呢？当然可以。 </p><hr><h2 id="三、内核WiFi驱动"><a href="#三、内核WiFi驱动" class="headerlink" title="三、内核WiFi驱动"></a>三、内核WiFi驱动</h2><h3 id="1、内核驱动代码下载"><a href="#1、内核驱动代码下载" class="headerlink" title="1、内核驱动代码下载"></a>1、内核驱动代码下载</h3><p>首先在<a href="https://whycan.com/t_5870.html">F1C200S修改ESP8089源码，由原来板极描述文件改为设备树，一键配置</a></p><p>或者墨云提供的下载链接<a href="https://files.cnblogs.com/files/twzy/esp8089.zip%EF%BC%88%E5%A4%8D%E5%88%B6%E5%88%B0%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%B8%8B%E8%BD%BD%EF%BC%89%E4%B8%8B%E8%BD%BD**%E5%86%85%E6%A0%B8wifi%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E6%BA%90%E7%A0%81%EF%BC%8C**%E5%85%B6%E5%AE%9E%E6%AD%A4%E6%BA%90%E7%A0%81**%E5%A4%A7%E9%83%A8%E5%88%86%E5%92%8C%E4%B8%8A%E9%9D%A2%E6%A8%A1%E5%9D%97%E5%8C%96%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%90%8C%EF%BC%8C**%E5%8F%AA%E6%98%AF%E6%AD%A4%E5%A4%84%E4%BD%BF%E7%94%A8%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8E%B7%E5%8F%96%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B0%86%E9%A9%B1%E5%8A%A8%E6%96%87%E4%BB%B6**%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%AF%91%E5%88%B0%E5%86%85%E6%A0%B8%E3%80%82**%E4%B8%8B%E8%BD%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B9%9F%E6%98%AF%E5%9C%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E4%BF%AE%E6%94%B9%E8%80%8C%E6%9D%A5%E7%9A%84%EF%BC%8C%E8%AF%A6%E8%A7%81%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%93%BE%E6%8E%A5%E3%80%82">https://files.cnblogs.com/files/twzy/esp8089.zip（复制到地址栏下载）下载**内核wifi驱动代码源码，**其实此源码**大部分和上面模块化驱动相同，**只是此处使用设备树获取设备信息，将驱动文件**直接编译到内核。**下载的代码也是在上面的基础上修改而来的，详见第一个链接。</a></p><h3 id="2、设备树修改"><a href="#2、设备树修改" class="headerlink" title="2、设备树修改"></a>2、设备树修改</h3><p>设备树修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&amp;spi0 &#123;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;   </span><br><span class="line">        esp8089@0 &#123;</span><br><span class="line">            status &#x3D; &quot;okay&quot;;</span><br><span class="line">            compatible &#x3D; &quot;boss,esp8089&quot;;</span><br><span class="line">            spi-cpol;</span><br><span class="line">            spi-cpha;</span><br><span class="line">            reg &#x3D; &lt;0&gt;;</span><br><span class="line">            spi-max-frequency &#x3D; &lt;30000000&gt;;</span><br><span class="line">            reset&#x3D; &lt;135&gt;; &#x2F;&#x2F;PE7</span><br><span class="line">            interrupt&#x3D; &lt;136&gt;; &#x2F;&#x2F;PE8</span><br><span class="line">            debug&#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;; </span><br><span class="line">&#125;;</span><br><span class="line">spi0:spi@1c05000 &#123;</span><br><span class="line">compatible &#x3D; &quot;allwinner,suniv-spi&quot;,</span><br><span class="line">&quot;allwinner,sun8i-h3-spi&quot;;</span><br><span class="line">reg &#x3D; &lt;0x01c05000 0x1000&gt;;</span><br><span class="line">interrupts &#x3D; &lt;10&gt;;</span><br><span class="line">clocks &#x3D; &lt;&amp;ccu CLK_BUS_SPI0&gt;, &lt;&amp;ccu CLK_BUS_SPI0&gt;;</span><br><span class="line">clock-names &#x3D; &quot;ahb&quot;, &quot;mod&quot;;</span><br><span class="line">resets &#x3D; &lt;&amp;ccu RST_BUS_SPI0&gt;;</span><br><span class="line">status &#x3D; &quot;disabled&quot;;</span><br><span class="line">#address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">#size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">pinctrl-0 &#x3D; &lt;&amp;spi0_pc_pins&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3、内核无线驱动源码修改"><a href="#3、内核无线驱动源码修改" class="headerlink" title="3、内核无线驱动源码修改"></a>3、内核无线驱动源码修改</h3><p>首先将内核无线驱动源码<strong>复制到内核源码的&#x2F;drivers&#x2F;sta****ging&#x2F;<strong>目录下，因为我们</strong>使用的是SPI0，</strong>因此<strong>无线驱动源码中的spi_stub.c文件</strong>需要修改如上一小节所示。</p><img src="/posts/undefined/323216bba976a2e6e8ede3d258d2a2e9.png" class="" title="img"><p>然后在<strong>spi_stub.c文件</strong>对我们使用的<strong>管脚进行修改，</strong>需要修改吗？是不需要的，我们之前对管脚进行修改是因为我们用的<strong>spi_stub.c文件</strong>中的变量描述硬件信息，现在我们使用<strong>设备树描述硬件设备信息，</strong>我们下载的代码中已经<strong>集成设备树解析函数，</strong>因此我们无需再次在代码中指定硬件信息。</p><p>加入防止超时的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern struct task_struct *sif_irq_thread;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/03fe130cfe4945726596d2d09f3a4f0c.png" class="" title="img"><img src="/posts/undefined/39a904febda051e93bec2f3e16cb7b40.png" class="" title="img"><p>修改完成使用<strong>make命令进行编译，</strong>发现以下<strong>错误，</strong>提示的意思是<strong>函数本来是void类型，结果我们按照有返回值的形式使用函数，</strong>对<strong>esp_debug.c文件</strong>中的内容进行修改：</p><img src="/posts/undefined/2f47d747e17d6a1f4685698e3160472c.png" class="" title="img"><p> <strong>esp_debug.c文件</strong>修改完成如下所示，重新使用<strong>make命令</strong>编译内核，不再报错。</p><img src="/posts/undefined/55b9ffbe2a3374d2ab4074d66a6267e3.png" class="" title="img"><img src="/posts/undefined/b3ae7632b63333909b6cb4315f7f229a.png" class="" title="img"><h3 id="4、无线网卡测试"><a href="#4、无线网卡测试" class="headerlink" title="4、无线网卡测试"></a>4、无线网卡测试</h3><p><strong>编译完成，</strong>更新内核镜像文件，上电启动，内核<strong>自动加载</strong>无线驱动，<strong>无需</strong>手动modprobe esp8089.ko，进入Debian系统后，依次输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0 up #启动网卡</span><br><span class="line">ifconfig #查看现有网卡</span><br><span class="line"></span><br><span class="line">vi &#x2F;etc&#x2F;wpa_supplicant.conf # 配置WiFi信息</span><br><span class="line"></span><br><span class="line">network&#x3D;&#123;</span><br><span class="line">  ssid&#x3D;&quot;热点&quot;</span><br><span class="line">  psk&#x3D;&quot;密码&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wpa_supplicant -B -i wlan0 -c &#x2F;etc&#x2F;wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line">udhcpc -i wlan0</span><br><span class="line"></span><br><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p><strong>成功ping通百度，</strong>此次连接的不是手机热点，而是WiFi，延迟略微降低。对于文件传输等请自行测试，本文不再赘述。</p><img src="/posts/undefined/7b18af4e15dac9559c239faba439a3c6.png" class="" title="img"><hr><h2 id="四、参考内容"><a href="#四、参考内容" class="headerlink" title="四、参考内容"></a>四、参考内容</h2><p>\1. <a href="https://whycan.com/viewtopic.php?id=4149&action=onlyshowauthor">众人拾柴-F1C200S通过SPI使用ESP8089或ESP8266做无线网卡 &#x2F; 全志 SOC &#x2F; WhyCan Forum(哇酷开发者社区)</a></p><p>\2. <a href="https://www.cnblogs.com/twzy/p/15160808.html">小白自制Linux开发板 四. 通过SPI使用ESP8266做无线网卡 - 淡墨青云 - 博客园</a></p><p>\3. [<a href="https://whycan.com/t_5870.html">ESP8089-SPI移植支持设备树]F1C200S修改ESP8089源码，由原来板极描述文件改为设备树，一键配置。</a></p><p>4.<a href="http://47.111.11.73/docs/boards/arm-linux/zdyz-i.mx6ull.html">i.MX6ULL Linux阿尔法开发板 — 正点原子资料下载中心 1.0.0 文档</a></p><p>\5. <a href="https://blog.csdn.net/linfengXBB/article/details/122511860">depmod: ERROR: could not open directory &#x2F;lib&#x2F;modules&#x2F;5.2.0-licheepi-zero+: No such file or dir</a></p><p>6.<a href="https://blog.csdn.net/jazzsoldier/article/details/70053495">modprobe: FATAL: Module xxx.ko not found in directory &#x2F;lib&#x2F;modules&#x2F;$(uname -r)_SoldierJazz2021的博客-CSDN博客</a></p><p>7.<a href="https://blog.csdn.net/whahu1989/article/details/86516233">warning: override: reassigning to symbol 问题解决_爱就是恒久忍耐的博客-CSDN博客_reassigning to symbol</a></p><p>8.<a href="https://zhuanlan.zhihu.com/p/372994818">腾讯云的轻量应用服务器修改主机名hostname的方法 - 知乎</a></p><p>9.<a href="https://blog.csdn.net/mainmaster/article/details/124317752">使用ssh 连接linux 并传送文件_SIXTOME的博客-CSDN博客_linux ssh 传文件</a></p><h1 id="NES游戏移植"><a href="#NES游戏移植" class="headerlink" title="NES游戏移植"></a>NES游戏移植</h1><h2 id="一、前言-3"><a href="#一、前言-3" class="headerlink" title="一、前言"></a>一、前言</h2><p>经过前面<strong>十篇文章，</strong>我们的小电脑现拥有自己的<strong>Debian系统，</strong>可以进行<strong>屏幕显示与触摸，</strong>可以播放<strong>音频、视频，</strong>可以<strong>连接键盘、U盘</strong>等设备，也可以连接<strong>无线络</strong>下载软件、<strong>远程访问</strong>与<strong>文件传输</strong>等等。虽然小电脑功能已经非常齐全了，但是我们它还是个空空荡荡的小电脑，<strong>我们是不是应该娱乐一下、放松一下呢？必须滴啊，开始整活。</strong></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><hr><h3 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h3><h3 id="1、GCC、G-编译器安装"><a href="#1、GCC、G-编译器安装" class="headerlink" title="1、GCC、G++编译器安装"></a>1、GCC、G++编译器安装</h3><p>通过上一篇文章的学习，我们可以使用<strong>无线网进行软件安装，</strong>使用<strong>apt-get命令****安装gcc、g++编译器：</strong></p><img src="/posts/undefined/a6f8f951ac5885bd8ca334401b115127.png" class="" title="img"><p>安装完成，使用<strong>gcc -v验证是否安装成功，</strong>如下图所示为安装成功输出日志。</p><img src="/posts/undefined/967b3890f32c2be550c9427662ba9208.png" class="" title="img"><img src="/posts/undefined/0f9dc3fe557f4ff8f5fc30099ffa2725.png" class="" title="img"><h3 id="2、音频组件alsa-utils安装"><a href="#2、音频组件alsa-utils安装" class="headerlink" title="2、音频组件alsa-utils安装"></a>2、音频组件alsa-utils安装</h3><p>移植NES<strong>游戏机模拟器程序</strong>，这里使用InfoNes，<strong>InfoNES音频部分</strong>需要<strong>alsa相关的组件。</strong></p><p>前面我们已经安装过<strong>alsa-utils，</strong>此处就无需安装，如果前面没有安装，使用如下指令<strong>安装组件。</strong></p><img src="/posts/undefined/1d7352fd4d4b255ff48bb9217219be7b.png" class="" title="img"><h2 id="3、其他组件安装"><a href="#3、其他组件安装" class="headerlink" title="3、其他组件安装"></a>3、其他组件安装</h2><p>make组件安装，安装完成后</p><img src="/posts/undefined/b8cbfd5c97c971f85bded2c279bc3555.png" class="" title="img"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libsdl1.2-dev # 漫长的等待</span><br><span class="line">apt-get install libasound2-dev # 可能不需要安装</span><br></pre></td></tr></table></figure><hr><h2 id="三、NES模拟器编译"><a href="#三、NES模拟器编译" class="headerlink" title="三、NES模拟器编译"></a>三、NES模拟器编译</h2><p>编译NES，进入NES源码&#x2F;arm-NES-linux-master&#x2F;linux&#x2F;文件夹下（使用墨云提供的源码，详细修改时内容详见墨云），使用make命令进行编译，然后是漫长的等待。编译完成后，在当前目录下生成InfoNES文件，这便是我们的模拟器。</p><img src="/posts/undefined/4971460ba1b2e36f4c4910907a607b03.png" class="" title="img"><p>自行准备.nes后缀的游戏文件，想必能够做到此处的朋友们找个nes游戏应该不成问题，将NES游戏复制到Debian的&#x2F;home&#x2F;用户名目录中，使用如下命令启动模拟器打开游戏：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;InfoNES ..&#x2F;..&#x2F;hundouluo.nes # &#x2F;arm-NES-linux-master&#x2F;linux所在目录</span><br></pre></td></tr></table></figure><p>然后就是娱乐时刻：</p><img src="/posts/undefined/12b830c1b3e8148e67b273a896b50c30.png" class="" title="img"><img src="/posts/undefined/96a74ab3c02f9a5188326a3d8d5356e8.png" class="" title="img"><img src="/posts/undefined/a61a80dd5170a6d55c601158bb441f24.png" class="" title="img"><img src="/posts/undefined/d1e4877dba2bb572aa28fb267f5b063d.png" class="" title="img"><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><hr><h2 id="四、参考内容-1"><a href="#四、参考内容-1" class="headerlink" title="四、参考内容"></a>四、参考内容</h2><p>\1. <a href="https://www.cnblogs.com/twzy/p/15356127.html">小白自制Linux开发板 十. NES游戏玩起来 - 淡墨青云 - 博客园</a></p><h1 id="【项目原理】多点触摸屏驱动原理"><a href="#【项目原理】多点触摸屏驱动原理" class="headerlink" title="【项目原理】多点触摸屏驱动原理"></a>【项目原理】多点触摸屏驱动原理</h1><h2 id="一、屏幕介绍"><a href="#一、屏幕介绍" class="headerlink" title="一、屏幕介绍"></a>一、屏幕介绍</h2><p>ATK-7016 这款屏幕其实是由 TFT LCD+触摸屏组合起来的。底下是 LCD 面板，上面是触摸面板，将两个封装到一起就成了带有触摸屏的 LCD 屏幕。电容触摸屏也是需要一个驱动 IC的，驱动 IC 一般会提供一个 I2C 接口给主控制器，主控制器可以通过 I2C 接口来读取驱动 IC里面的触摸坐标数据。ATK-7016、ATK-7084 这两款屏幕使用的触摸控制 IC 是 FT5426，ATK-4342 使用的驱动 IC 是 GT9147，<strong>ATK-4384 使用的驱动 IC 是 GT1151。</strong>这些电容屏触摸 IC 都是 I2C 接口的，使用方法基本一样。</p><p>ATK-4384 的电容触摸屏部分有 4 个 IO 用于连接主控制器：SCL、SDA、RST 和 INT，SCL 和 SDA 是 I2C 引脚，RST 是复位引脚，INT 是中断引脚。<strong>一般通过 INT 引脚来通知主控制器有触摸点按下，然后在 INT 中断服务函数中读取触摸数据。</strong>也可以不使用中断功能，采用轮询的方式不断查询是否有触摸点按下，本章实验我们使用中断方式来获取触摸数据。</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><hr><h2 id="二、触摸驱动分析"><a href="#二、触摸驱动分析" class="headerlink" title="二、触摸驱动分析"></a>二、触摸驱动分析</h2><h3 id="1、驱动框架分析"><a href="#1、驱动框架分析" class="headerlink" title="1、驱动框架分析"></a>1、驱动框架分析</h3><p>按照<a href="https://blog.csdn.net/qq_41709234/article/details/128661071%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%9A">https://blog.csdn.net/qq_41709234/article/details/128661071的说法：</a></p><p>驱动程序编写主要参考《正点原子开发指南》，在裸机开发中进行触摸屏的驱动，主要流程如下：</p><blockquote><p> ①、电容触摸屏是<strong>IIC接口的，</strong>需要触摸 IC，以正点原子的 ATK4384 为例，其所使用的触摸屏控制 IC 为GT1151，因此所谓的电容触摸驱动就是 IIC设备驱动。<br> ②、触摸IC提供了<strong>中断信号引脚(INT)，</strong>可以通过中断来获取触摸信息。<br> ③、电容触摸屏得到的是触摸位置绝对信息以及触摸屏是否有按下。<br> ④、电容触摸屏不需要校准，当然了，这只是理论上的，如果电容触摸屏质量比较差，或者触摸玻璃和 TFT 之间没有完全对齐，那么也是需要校准的。 </p></blockquote><p>那么电容触摸屏的Linux驱动主要需要以下<strong>几个驱动框架的组合：</strong></p><blockquote><p> ①、IIC 设备驱动，因为电容触摸IC基本都是<strong>IIC接口的，</strong>因此大框架就是<strong>IIC设备驱动。</strong><br> ②、<strong>通过中断引脚(INT)<strong>向linux内核上报触摸信息，因此需要用到</strong>linux中断驱动框架。</strong>坐标的上报在中断服务函数中完成。<br> ③、触摸屏的坐标信息、屏幕按下和抬起信息都属于<strong>linux的input子系统，</strong>因此向 linux 内核上报触摸屏坐标信息就得使用input子系统。</p></blockquote><h3 id="2、多点触摸-MT-协议详解"><a href="#2、多点触摸-MT-协议详解" class="headerlink" title="2、多点触摸(MT)协议详解"></a>2、多点触摸(MT)协议详解</h3><p><strong>MT 协议隶属于 linux的 input 子系统，</strong>驱动通过大量的 ABS_MT 事件向 linux 内核上报多点触摸坐标数据。<strong>根据触摸 IC 的不同，分为 Type A 和 Type B 两种类型，</strong>目前使用最多的是 Type B 类型。</p><p>老版本的 linux 内核是不支持多点电容触摸的(Multi-touch，简称 MT)，MT 协议是后面加入的，因此如果使用 2.x 版本 linux 内核的话可能找不到 MT 协议。</p><p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有ABS_MT 事件是用于多点触摸的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">852 #define ABS_MT_SLOT        0x2f &#x2F;* MT slot being modified *&#x2F; </span><br><span class="line">853 #define ABS_MT_TOUCH_MAJOR  0x30 &#x2F;* Major axis of touching ellipse *&#x2F; </span><br><span class="line">854 #define ABS_MT_TOUCH_MINOR  0x31 &#x2F;* Minor axis (omit if circular) *&#x2F; </span><br><span class="line">855 #define ABS_MT_WIDTH_MAJOR  0x32 &#x2F;* Major axis of approaching ellipse *&#x2F; </span><br><span class="line">856 #define ABS_MT_WIDTH_MINOR  0x33 &#x2F;* Minor axis (omit if circular) *&#x2F; </span><br><span class="line">857 #define ABS_MT_ORIENTATION  0x34 &#x2F;* Ellipse orientation *&#x2F; </span><br><span class="line">858 #define ABS_MT_POSITION_X   0x35 &#x2F;* Center X touch position *&#x2F; </span><br><span class="line">859 #define ABS_MT_POSITION_Y   0x36 &#x2F;* Center Y touch position *&#x2F; </span><br><span class="line">860 #define ABS_MT_TOOL_TYPE    0x37 &#x2F;* Type of touching device *&#x2F; </span><br><span class="line">861 #define ABS_MT_BLOB_ID       0x38 &#x2F;* Group a set of packets as a blob *&#x2F; </span><br><span class="line">862 #define ABS_MT_TRACKING_ID  0x39 &#x2F;* Unique ID of initiated contact *&#x2F; </span><br><span class="line">863 #define ABS_MT_PRESSURE     0x3a &#x2F;* Pressure on contact area *&#x2F; </span><br><span class="line">864 #define ABS_MT_DISTANCE      0x3b &#x2F;* Contact hover distance *&#x2F; </span><br><span class="line">865 #define ABS_MT_TOOL_X        0x3c &#x2F;* Center X tool position *&#x2F; </span><br><span class="line">866 #define ABS_MT_TOOL_Y        0x3d &#x2F;* Center Y tool position *&#x2F; </span><br></pre></td></tr></table></figure><h4 id="🎍-TypeA"><a href="#🎍-TypeA" class="headerlink" title="🎍 TypeA"></a>🎍 TypeA</h4><p>对于 Type A 类型的设备，通过 <strong>input_mt_sync()函数来隔离不同的触摸点数据信息：</strong></p><blockquote><p>void input_mt_sync(struct input_dev *dev) </p></blockquote><p><strong>该函数会触发 SYN_MT_REPORT 事件，此事件会通知接收者获取当前触摸数据，并且准备接收下一个触摸点数据。</strong> </p><p>不管是哪个类型的设备，<strong>最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</strong></p><p>对于 Type A 类型的设备，发送触摸点信息的时序如下所示，<strong>这里以 2 个触摸点为例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_POSITION_X x[0]&#x2F;&#x2F; ABS_MT_POSITION_X 、 ABS_MT_POSITION_Y事件</span><br><span class="line">ABS_MT_POSITION_Y y[0]&#x2F;&#x2F; input_report_abs来完成坐标上报</span><br><span class="line">SYN_MT_REPORT&#x2F;&#x2F; input_mt_sync()函数会触发SYN_MT_REPORT事件</span><br><span class="line">ABS_MT_POSITION_X x[1]</span><br><span class="line">ABS_MT_POSITION_Y y[1]</span><br><span class="line">SYN_MT_REPORT</span><br><span class="line">SYN_REPORT</span><br></pre></td></tr></table></figure><p> 实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">static irqreturn_t st1232_ts_irq_handler(int irq, void *dev_id)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 获取所有触摸点的信息</span><br><span class="line">    ret &#x3D; st1232_ts_read_data(ts);</span><br><span class="line">    if (ret &lt; 0)</span><br><span class="line">        goto end;</span><br><span class="line"></span><br><span class="line">    &#x2F;* multi touch protocol *&#x2F;</span><br><span class="line">    for (i &#x3D; 0; i &lt; MAX_FINGERS; i++) &#123;</span><br><span class="line">        if (!finger[i].is_valid)</span><br><span class="line">            continue;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; 按照TypeA时序上报所有触摸点的信息</span><br><span class="line">        input_report_abs(input_dev, ABS_MT_TOUCH_MAJOR, finger[i].t);&#x2F; ABS_MT_TOUCH_MAJOR常数用于表示触摸接触区域的主轴长度</span><br><span class="line">        input_report_abs(input_dev, ABS_MT_POSITION_X, finger[i].x);</span><br><span class="line">        input_report_abs(input_dev, ABS_MT_POSITION_Y, finger[i].y);</span><br><span class="line">        input_mt_sync(input_dev);</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;* SYN_REPORT *&#x2F;</span><br><span class="line">input_sync(input_dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">end: </span><br><span class="line">     return IRQ_HANDLED; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="🎍-TypeB"><a href="#🎍-TypeB" class="headerlink" title="🎍 TypeB"></a>🎍 TypeB</h4><p><strong>Type B 使用 slot 协议区分具体的触摸点，</strong>Type B 设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot 来上报触摸点信息。可以<strong>通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。</strong></p><blockquote><p><strong>ABS_MT_TRACKING_ID跟踪ID：</strong>一个非负数的 ID 表示一个有效的触摸点，-1 这个 ID 表示未使用 slot。一个以前不存在的 ID 表示这是一个新加的触摸点，一个 ID 如果再也不存在了就表示删除了。</p></blockquote><p>上报触摸点信息的时候需要通过 <strong>input_mt_slot()函数区分是哪一个触摸点：</strong></p><blockquote><p>void input_mt_slot(struct input_dev *dev, int slot) </p></blockquote><p><strong>该函数会触发 ABS_MT_SLOT 事件，此事件会告诉接收者当前正在更新的是哪个触摸点(slot)的数据。</strong> </p><p>不管是哪个类型的设备，<strong>最终都要调用 input_sync()函数来标识多点触摸信息传输完成，告诉接收者处理之前累计的所有消息，并且准备好下一次接收。</strong></p><p>对于 Type B 类型的设备，发送触摸点信息的时序如下所示，这里以 2 个触摸点为例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ABS_MT_SLOT 0&#x2F;&#x2F; 使用 input_mt_slot 函数上报当前触摸点的 ABS_MT_SLOT 事件,触摸IC提供</span><br><span class="line">ABS_MT_TRACKING_ID 45&#x2F;&#x2F; input_mt_report_slot_state完成 Type B 的要求，即每个 SLOT 必须关联一个ABS_MT_TRACKING_ID</span><br><span class="line">ABS_MT_POSITION_X x[0]</span><br><span class="line">ABS_MT_POSITION_Y y[0]</span><br><span class="line">ABS_MT_SLOT 1</span><br><span class="line">ABS_MT_TRACKING_ID 46</span><br><span class="line">ABS_MT_POSITION_X x[1]</span><br><span class="line">ABS_MT_POSITION_Y y[1]</span><br><span class="line">SYN_REPORT&#x2F;&#x2F; 当所有的触摸点坐标都上传完毕以后就得发送 SYN_REPORT 事件，使用 input_sync 函数来完成。 </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 当一个触摸点移除以后</span><br><span class="line">ABS_MT_TRACKING_ID -1 &#x2F;&#x2F; 负1表示这个ID不使用SLOT，同样使用input_mt_report_slot_state函数，第三个参数为false即可，无需手动置为-1</span><br><span class="line">SYN_REPORT&#x2F;&#x2F; 使用input_sync函数表示上报结束</span><br></pre></td></tr></table></figure><p>实例: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static void ili210x_report_events(struct input_dev *input, const struct touchdata *touchdata)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    bool touch;</span><br><span class="line">    unsigned int x, y;</span><br><span class="line">    const struct finger *finger;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 循环上报所有触摸点</span><br><span class="line">    for (i &#x3D; 0; i &lt; MAX_TOUCHES; i++) &#123;</span><br><span class="line">        input_mt_slot(input, i);&#x2F;&#x2F; ABS_MT_SLOT事件</span><br><span class="line"></span><br><span class="line">        finger &#x3D; &amp;touchdata-&gt;finger[i];</span><br><span class="line"></span><br><span class="line">        touch &#x3D; touchdata-&gt;status &amp; (1 &lt;&lt; i);</span><br><span class="line">        input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);&#x2F;&#x2F; 上报ABS_MT_TRACKING_ID事件，也就是给 SLOT 关联一个ABS_MT_TRACKING_ID。</span><br><span class="line">        if (touch) &#123;</span><br><span class="line">            x &#x3D; finger-&gt;x_low | (finger-&gt;x_high &lt;&lt; 8);</span><br><span class="line">            y &#x3D; finger-&gt;y_low | (finger-&gt;y_high &lt;&lt; 8);</span><br><span class="line"></span><br><span class="line">            input_report_abs(input, ABS_MT_POSITION_X, x);</span><br><span class="line">            input_report_abs(input, ABS_MT_POSITION_Y, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input_mt_report_pointer_emulation(input, false);</span><br><span class="line">    input_sync(input);&#x2F;&#x2F; 上报SYN_REPORT事件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="🎍-MT触摸协议A、B总结"><a href="#🎍-MT触摸协议A、B总结" class="headerlink" title="🎍 MT触摸协议A、B总结"></a>🎍 <strong>MT触摸协议A、B总结</strong></h4><img src="/posts/undefined/8cde1ed1a53290e61a515192c7d5b6d8.png" class="" title="img"><h4 id="🎍-疑问及解答"><a href="#🎍-疑问及解答" class="headerlink" title="🎍 疑问及解答"></a>🎍 疑问及解答</h4><p><strong>1.TypeA和TypeB两种类型的区别如下：</strong> </p><blockquote><p>Type A：适用于触摸点不能被区分或者追踪，此类型的设备上报原始数据<br>Type B：适用于有硬件追踪并能区分触摸点的触摸设备，此类型设备都通过slot更新某一个触摸点的信息</p></blockquote><p><strong>2.什么是slot？什么是ID？</strong></p><ol><li><strong>slot：是一个用于存储触摸点信息的<strong><strong>容器，</strong></strong>包括触摸点的ID和位置信息。</strong>每个触摸点都会被分配一个slot，以便系统能够追踪多个触摸点。</li><li><strong>ID：是触摸点的唯一标识符，用于区分不同的触摸点。</strong>系统可以通过ID来追踪触摸点的移动。</li></ol><blockquote><p>总之：</p><p>ID：用于跟踪触摸点的唯一标识符。当用户触摸屏幕时，系统会为每个触摸点分配一个唯一的 ID。</p><p>slot：每个 Slot 包含了触摸点的各种信息，如坐标（X 和 Y）、面积、压力等。</p></blockquote><p><strong>3.MT多点触摸协议中TypeB中的slot，按下屏幕上的按键，分配一个slot和一个唯一的ID，在不抬起的情况下移动这个点，slot和ID会发生什么变化？</strong></p><ol><li>该触摸点所占用的slot和ID不会发生改变。它会继续使用原来分配给它的那个slot和ID。</li><li>其他新的触摸点如果产生,会分配新的未使用的slot和新的唯一ID。</li><li>如果原来的某个触摸点被抬起,其所占用的slot和ID将被释放,供新触摸点使用。</li><li>如果某个触摸点由于移动越过屏幕边缘被结束,其所占用的slot和ID也将被释放。</li></ol><p><strong>4.MT多点触摸协议中TypeB，如果首先按下一个点，再按下一个点，再次按下一个点，然后抬起第二个按下的点，再按下一个新的点，slot和ID如何发生变化？</strong></p><ol><li>首先按下第一个点，分配slot 1和 ID 1；</li><li>按下第二个点，分配slot 2和 ID 2；</li><li>按下第三个点，如果slot 1和2都被占用,会分配slot 3和 ID 3；</li><li>抬起第二个点(ID 2)，释放其slot 2；</li><li>按下新的第四个点，由于slot 2已空闲，会分配slot 2和新的唯一ID，例如 ID 4。</li></ol><p><em><strong>*5.为什么需要ID和slot配合，单独使用slot或者ID为什么不能完成多点触摸功能呢？*</strong></em></p><ol><li>slot 数量是有限的，并且slot的使用可以确保每个触摸点都分配一个独占的通道来传输触摸相关信息<strong>。</strong>但是，<strong>（原因解释）</strong>，如果在同一帧内，其中4个点(A，B，C和D)持续活动，我们可能会分配slot1-4。如果我们增加了第5个和第6个点E和F，slot 5和6也可能被分配,超出原有范围，在这种情况下，slot冲突就可能发生。另一方面，如果在后续帧中，部分点(例如B和D)不再活动，但新的点(G和H)出现，我们会释放slot 2和4，并分配新的slot 5和6。此时，slot 映射会变得非常混乱和不直观。很难通过slot数来确定某个点的信息通道，也就是说，我想对第二个按下的点进行操作，但是slot2并不对应第二个按下的点。</li><li>ID只是用来标识每个触摸点的唯一标志符，并不能告诉我们这些触摸点的位置、状态或其他属性。为了实现多点触摸识别功能，我们需要使用ID和其他信息（如坐标、状态、时间戳等）来跟踪和识别每个触摸点，并进行相应的操作。</li></ol><p><strong>6.什么情况下需要使用 input_mt_report_pointer_emulation() 函数禁止指针模拟器？</strong></p><ol><li>硬件设备跟踪到的触摸点数量多于正在上报的触摸点数量，启用指针模拟器可能导致触摸点数量不匹配、误判触摸点位置等问题。</li><li>应用程序需要精确地跟踪多个触摸点的位置和状态，禁用指针模拟器可以确保触摸点信息能够准确地传递到应用程序中，而不受指针模拟器的影响。</li><li>一些应用程序需要使用指针模拟器来模拟单点触控，禁用指针模拟器可能会导致这些应用程序无法正常工作。</li><li>在特殊的应用场景下，例如绘图或游戏等需要高精度触摸控制的应用程序中，禁用指针模拟器可以提高触摸点的准确性和响应性。</li></ol><hr><h2 id="三、多点触摸API函数"><a href="#三、多点触摸API函数" class="headerlink" title="三、多点触摸API函数"></a>三、多点触摸API函数</h2><h4 id="1、input-mt-init-slots-函数"><a href="#1、input-mt-init-slots-函数" class="headerlink" title="1、input_mt_init_slots 函数"></a>1、input_mt_init_slots 函数</h4><p><strong>用于初始化 MT 的输入 slots，</strong>编写 MT 驱动的时候必须先调用此函数<strong>初始化 slots：</strong></p><blockquote><p><strong>int input_mt_init_slots(  struct input_dev   *dev,<br>                     unsigned int    num_slots,<br>                     unsigned int    flags)</strong><br>dev：  MT 设备对应的 input_dev，因为 MT 设备隶属于 input_dev。<br>num_slots：多点触控设备支持的最大触摸点数量。<br>flags：其他一些 flags 信息，可设置的 flags 如下所示： </p><p>#define INPUT_MT_POINTER   0x0001  &#x2F;* pointer device, e.g. trackpad <em>&#x2F;<br>#define INPUT_MT_DIRECT   0x0002  &#x2F;</em> direct device, e.g. touchscreen <em>&#x2F;<br>#define INPUT_MT_DROP_UNUSED 0x0004  &#x2F;</em> drop contacts not seen in frame <em>&#x2F;<br>#define INPUT_MT_TRACK   0x0008  &#x2F;</em> use in-kernel tracking <em>&#x2F;<br>#define INPUT_MT_SEMI_MT   0x0010  &#x2F;</em> semi-mt device, finger count handled manually *&#x2F; </p><p>可以采用‘|’运算来同时设置多个 flags 标识。<br>返回值：0，成功；负值，失败。 </p></blockquote><h4 id="2、input-mt-slot-函数"><a href="#2、input-mt-slot-函数" class="headerlink" title="2、input_mt_slot 函数"></a>2、input_mt_slot 函数</h4><p>此函数用于 Type B 类型，此函数用于<strong>产生 ABS_MT_SLOT 事件，</strong>告诉内核当前上报的是哪个触摸点的坐标数据：</p><blockquote><p><strong>void input_mt_slot(struct input_dev   *dev,<br>                 int      slot)</strong> </p><p>dev：  MT 设备对应的 input_dev。<br>slot：当前发送的是哪个 slot 的坐标信息，也就是哪个触摸点。<br>返回值：无。 </p></blockquote><h4 id="3、input-mt-report-slot-state-函数"><a href="#3、input-mt-report-slot-state-函数" class="headerlink" title="3、input_mt_report_slot_state 函数"></a>3、input_mt_report_slot_state 函数</h4><p>此函数用于 Type B 类型，用于<strong>产生 ABS_MT_TRACKING_ID 和 ABS_MT_TOOL_TYPE事 件</strong> ， ABS_MT_TRACKING_ID 事 件 给 slot 关 联 一 个 ABS_MT_TRACKING_ID ，ABS_MT_TOOL_TYPE 事件指定触摸 型（是笔还是手指等）：</p><blockquote><p><strong>void input_mt_report_slot_state(  struct input_dev   *dev,<br>                           unsigned int    tool_type,<br>                           bool     active)</strong><br>dev：  MT 设备对应的 input_dev。<br>tool_type：触摸类型，可以选择 MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或<br>MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。<br>active：true，连续触摸，input 子系统内核会自动分配一个 ABS_MT_TRACKING_ID 给slot。<br>false，触摸点抬起，表示某个触摸点无效了，input 子系统内核会分配一个-1 给 slot，表示触摸点溢出。<br>返回值：无。</p></blockquote><h4 id="4、input-report-abs-函数"><a href="#4、input-report-abs-函数" class="headerlink" title="4、input_report_abs 函数"></a>4、input_report_abs 函数</h4><p>Type A 和 Type B 类型都使用此函数上报触摸点坐标信息，通过 ABS_MT_POSITION_X 和ABS_MT_POSITION_Y 事件实现 X 和 Y 轴坐标信息上报。</p><blockquote><p>void input_report_abs( struct input_dev   *dev,<br>                   unsigned int    code,<br>                   int      value) </p><p>dev：  MT 设备对应的 input_dev。<br>code：要上报的是什么数据，可以设置为 ABS_MT_POSITION_X 或ABS_MT_POSITION_Y，也就是 X 轴或者 Y 轴坐标数据。<br>value：具体的 X 轴或 Y 轴坐标数据值。<br>返回值：无。 </p></blockquote><h4 id="5、input-mt-report-pointer-emulation-函数"><a href="#5、input-mt-report-pointer-emulation-函数" class="headerlink" title="5、input_mt_report_pointer_emulation 函数"></a>5、input_mt_report_pointer_emulation 函数</h4><p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量，然后调用 input_mt_report_pointer_emulation 函数将 use_count 参数设置为 false。否则的话将 use_count 参数设置为 true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)：</p><blockquote><p>void input_mt_report_pointer_emulation(struct input_dev  *dev,<br>                                 bool     use_count)<br>dev：  MT 设备对应的 input_dev。<br>use_count：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。<br>返回值：无。 </p></blockquote><hr><h2 id="四、多点电容触摸驱动框架分析"><a href="#四、多点电容触摸驱动框架分析" class="headerlink" title="四、多点电容触摸驱动框架分析"></a>四、多点电容触摸驱动框架分析</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>①、多点电容触摸芯片的接口，一般都为 I2C 接口，因此驱动主框架肯定是 I2C。<br>②、linux 里面一般都是通过中断来上报触摸点坐标信息，因此需要用到中断框架。<br>③、多点电容触摸属于 input 子系统，因此还要用到 input 子系统框架。<br>④、在中断处理程序中按照 linux 的 MT 协议上报坐标信息。 </p><h3 id="2、I2C框架"><a href="#2、I2C框架" class="headerlink" title="2、I2C框架"></a>2、I2C框架</h3><p>I2C框架类似于platform框架，比较好理解，如果实在是不明白请看正点原子驱动指南I2C部分。<strong>当设备树中触摸 IC的设备节点和驱动匹配以后，gt1151_probe 函数就会执行，我们可以在此函数中初始化触摸 IC，中断和 input 子系统等。</strong> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// probe函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt1151_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// i2c驱动的remove函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt1151_remove</span><span class="params">(struct i2c_client *client)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_unregister_device(gt1151.input);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传统驱动匹配表</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">i2c_device_id</span> <span class="title">gt1151_id_table</span>[] =</span> &#123;</span><br><span class="line">&#123; <span class="string">&quot;goodix,gt1151ATK4384&quot;</span>, <span class="number">0</span>, &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 设备树匹配表 </span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">gt1151_of_match_table</span>[] =</span> &#123;</span><br><span class="line">    &#123;.compatible = <span class="string">&quot;goodix,gt1151ATK4384&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="comment">/* sentinel */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* i2c驱动结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">i2c_driver</span> <span class="title">gt1151_i2c_driver</span> =</span> &#123;</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name  = <span class="string">&quot;gt1151&quot;</span>,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">        .of_match_table = gt1151_of_match_table,</span><br><span class="line">    &#125;,</span><br><span class="line">    .id_table = gt1151_id_table,</span><br><span class="line">    .probe  = gt1151_probe,</span><br><span class="line">    .remove = gt1151_remove,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">module_i2c_driver(gt1151_i2c_driver);<span class="comment">// 展开后和module_init module_exit一样，类似于module_platform_driver</span></span><br><span class="line"> </span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;kashine&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2、初始化触摸IC、中断、input子系统初始化"><a href="#2、初始化触摸IC、中断、input子系统初始化" class="headerlink" title="2、初始化触摸IC、中断、input子系统初始化"></a>2、初始化触摸IC、中断、input子系统初始化</h3><p>初始化触摸芯片，包括芯片的相关 IO，比如复位、中断等 IO 引脚，然后就是芯片本身的初始化，也就是配置触摸芯片的相关寄存器。 </p><p>设置 input_dev 需要上报的事件为 EV_ABS 和 BTN_TOUCH，因为多点电容屏的触摸坐标为绝对值，因此需要上报 EV_ABS 事件。触摸屏有按下和抬起之分，因此需要上报 BTN_TOUCH 按键。 </p><p>调用 input_set_abs_params 函数设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// probe函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gt1151_probe</span><span class="params">(struct i2c_client *client, <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u8 data, ret;</span><br><span class="line">    gt1151.client = client;</span><br><span class="line">printk(<span class="string">&quot;Driver and device has mached!!!\r\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 1、初始化触摸IC */</span></span><br><span class="line"> <span class="comment">/* 获取设备树中的中断和复位引脚 */</span></span><br><span class="line">gt1151.irq_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;interrupt-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line">gt1151.reset_pin = of_get_named_gpio(client-&gt;dev.of_node, <span class="string">&quot;reset-gpios&quot;</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// printk(&quot;irq_pin=%d, reset_pin=%d\r\n&quot;, gt1151.irq_pin, gt1151.reset_pin);</span></span><br><span class="line"><span class="comment">/* 复位GT1151 */</span></span><br><span class="line">ret = gt1151_ts_reset(client, &amp;gt1151);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 初始化GT1151 */</span></span><br><span class="line">    data = <span class="number">0x02</span>;</span><br><span class="line">    gt1151_write_regs(&amp;gt1151, GT_CTRL_REG, &amp;data, <span class="number">1</span>); <span class="comment">/* 软复位 */</span></span><br><span class="line">    mdelay(<span class="number">100</span>);</span><br><span class="line">    data = <span class="number">0x0</span>;</span><br><span class="line">    gt1151_write_regs(&amp;gt1151, GT_CTRL_REG, &amp;data, <span class="number">1</span>); <span class="comment">/* 停止软复位 */</span></span><br><span class="line">    mdelay(<span class="number">100</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 初始化GT1151，读取固件 */</span> <span class="comment">// 应该是读触摸设备的信息</span></span><br><span class="line">ret = gt1151_read_firmware(client, &amp;gt1151);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">printk(<span class="string">&quot;Fail !!! check !!\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2、input设备申请与初始化 */</span></span><br><span class="line">gt1151.input = devm_input_allocate_device(&amp;client-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (!gt1151.input) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line">gt1151.input-&gt;name = client-&gt;name;</span><br><span class="line">gt1151.input-&gt;id.bustype = BUS_I2C;</span><br><span class="line">gt1151.input-&gt;dev.parent = &amp;client-&gt;dev;</span><br><span class="line"> </span><br><span class="line">__set_bit(EV_KEY, gt1151.input-&gt;evbit);<span class="comment">// 支持按键事件</span></span><br><span class="line">    __set_bit(BTN_TOUCH, gt1151.input-&gt;keybit);<span class="comment">// 设置按键位图为抬起和按下之分的按键</span></span><br><span class="line">__set_bit(EV_ABS, gt1151.input-&gt;evbit);<span class="comment">// 支持绝对坐标事件</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 设置 EV_ABS 事件需要上报 ABS_X、ABS_Y、ABS_MT_POSITION_X 和 ABS_MT_POSITION_Y。 */</span></span><br><span class="line">input_set_abs_params(gt1151.input, ABS_X, <span class="number">0</span>, gt1151.max_x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_Y, <span class="number">0</span>, gt1151.max_y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_MT_POSITION_X,<span class="number">0</span>, gt1151.max_x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">input_set_abs_params(gt1151.input, ABS_MT_POSITION_Y,<span class="number">0</span>, gt1151.max_y, <span class="number">0</span>, <span class="number">0</span>);     </span><br><span class="line">ret = input_mt_init_slots(gt1151.input, MAX_SUPPORT_POINTS, <span class="number">0</span>);<span class="comment">// 初始化slot</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 注册input_dev */</span></span><br><span class="line">ret = input_register_device(gt1151.input);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 3、最后初始化中断 */</span></span><br><span class="line">ret = gt1151_ts_irq(client, &amp;gt1151);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、上报坐标信息"><a href="#3、上报坐标信息" class="headerlink" title="3、上报坐标信息"></a>3、上报坐标信息</h3><p>进入中断处理程序以后首先肯定是从触摸 IC 里面读取触摸坐标以及触摸点数量，假设触摸点数量保存到 num 变量，触摸点坐标存放到 x，y 数组里面。</p><p>每一轮触摸点坐标上报完毕以后就调用一次 input_sync 函数发送一个SYN_REPORT 事件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断服务函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">irqreturn_t</span> <span class="title">gt1151_irq_handler</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> touch_num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> input_x, input_y;</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    u8 data;</span><br><span class="line">    u8 touch_data[<span class="number">5</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gt1151_dev</span> *<span class="title">dev</span> =</span> dev_id;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// printk(&quot;enter irq handler!\r\n&quot;);</span></span><br><span class="line"> </span><br><span class="line">    ret = gt1151_read_regs(dev, GT_GSTID_REG, &amp;data, <span class="number">1</span>);<span class="comment">// GT1151当前检测到的触摸情况</span></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="number">0x00</span>)  &#123;     <span class="comment">/* 没有触摸数据，直接返回 */</span></span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                 <span class="comment">/* 统计触摸点数据 */</span></span><br><span class="line">        touch_num = data &amp; <span class="number">0x0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 由于GT1151没有硬件检测每个触摸点按下和抬起，因此每个触摸点的抬起和按</span></span><br><span class="line"><span class="comment">     * 下不好处理，尝试过一些方法，但是效果都不好，因此这里暂时使用单点触摸 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span>(touch_num) &#123;         <span class="comment">/* 单点触摸按下 */</span></span><br><span class="line">        gt1151_read_regs(dev, GT_TP1_REG, touch_data, <span class="number">5</span>);</span><br><span class="line">        id = touch_data[<span class="number">0</span>] &amp; <span class="number">0x0F</span>;</span><br><span class="line">        <span class="keyword">if</span>(id == <span class="number">0</span>) &#123; <span class="comment">//读取成功</span></span><br><span class="line">            input_x  = touch_data[<span class="number">1</span>] | (touch_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line">            input_y  = touch_data[<span class="number">3</span>] | (touch_data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单点id一直等于0即可</span></span><br><span class="line">            input_mt_slot(dev-&gt;input, <span class="number">0</span>);</span><br><span class="line">    input_mt_report_slot_state(dev-&gt;input, MT_TOOL_FINGER, <span class="literal">true</span>);</span><br><span class="line">    input_report_abs(dev-&gt;input, ABS_MT_POSITION_X, input_x);</span><br><span class="line">    input_report_abs(dev-&gt;input, ABS_MT_POSITION_Y, input_y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(touch_num == <span class="number">0</span>)&#123;                <span class="comment">/* 单点触摸释放 */</span></span><br><span class="line">        input_mt_slot(dev-&gt;input, id);</span><br><span class="line">        input_mt_report_slot_state(dev-&gt;input, MT_TOOL_FINGER, <span class="literal">false</span>);<span class="comment">// 删除触摸点</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">input_mt_report_pointer_emulation(dev-&gt;input, <span class="literal">true</span>);<span class="comment">// 没有出现硬件检测到的点比上报的触摸点多的情况</span></span><br><span class="line">    input_sync(dev-&gt;input);</span><br><span class="line"> </span><br><span class="line">    data = <span class="number">0x00</span>;                <span class="comment">/* 向0X814E寄存器写0 */</span></span><br><span class="line">    gt1151_write_regs(dev, GT_GSTID_REG, &amp;data, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">fail:</span><br><span class="line"><span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="项目原理】DRM驱动概念、组成、框架、源码分析"><a href="#项目原理】DRM驱动概念、组成、框架、源码分析" class="headerlink" title="项目原理】DRM驱动概念、组成、框架、源码分析"></a>项目原理】DRM驱动概念、组成、框架、源码分析</h1><h2 id="一、DRM与Framebuffer"><a href="#一、DRM与Framebuffer" class="headerlink" title="一、DRM与Framebuffer"></a>一、DRM与Framebuffer</h2><p>Linux 中的 <strong>DRM(Direct Rendering Manager)</strong> 驱动和 <strong>Framebuffer (fbdev)</strong> 驱动是两种不同的图形驱动方式，它们之间有一些区别。</p><p>Framebuffer驱动：</p><ul><li>直接控制显卡的帧缓冲区，提供基本的显卡输出功能；</li><li>使用一些内核数据结构和API来管理图形界面，并提供一组接口与用户空间的应用程序进行通信；</li><li>相对简单，适合于嵌入式系统或者不需要高性能图形的应用场景。</li></ul><p>DRM驱动：</p><ul><li>提供一种分离的图形驱动架构，<strong>将硬件驱动程序、内核模块和用户空间驱动程序进行分离；</strong></li><li>支持多个应用程序同时访问显卡，并提供了更丰富的图形功能，例如硬件加速和3D加速；</li><li>提供了一些内核接口，可以让用户空间应用程序与驱动程序进行交互；</li><li>支持多显示器和多GPU的配置。</li></ul><p>总之，一句话，DRM是Linux目前主流的图形显示框架，相比FB架构，DRM更能适应当前日益更新的显示硬件。<strong>尽管FB退出历史舞台，在DRM 中也并未将其遗弃，而是集合到DRM中，供部分嵌入式设备使用。</strong></p><hr><h2 id="二、DRM驱动"><a href="#二、DRM驱动" class="headerlink" title="二、DRM驱动"></a>二、DRM驱动</h2><p><a href="https://blog.csdn.net/zichuanning520/article/details/127047436">linux驱动系列学习之DRM（十）_linux drm_紫川宁520的博客-CSDN博客</a></p><h3 id="1、概述-1"><a href="#1、概述-1" class="headerlink" title="1、概述"></a>1、概述</h3><p>DRM从模块上划分，可以简单分为3部分：<strong>libdrm、KMS、GEM。</strong></p><h4 id="libdrm（DRM框架在用户空间的Lib）"><a href="#libdrm（DRM框架在用户空间的Lib）" class="headerlink" title="libdrm（DRM框架在用户空间的Lib）"></a><strong>libdrm（DRM框架在用户空间的Lib）</strong></h4><blockquote><p><strong>libdrm</strong>是一个用户空间的DRM库，<strong>提供了DRM驱动的用户空间接口。</strong>用户或应用程序在用户空间调用<strong>libdrm提供的库函数，</strong> 即可访问到显示的资源，并对显示资源进行管理和使用。</p></blockquote><h4 id="KMS（内核显示模式设置）"><a href="#KMS（内核显示模式设置）" class="headerlink" title="KMS（内核显示模式设置）"></a><strong>KMS（内核显示模式设置）</strong></h4><blockquote><p>KMS属于DRM框架下的一个大模块，<strong>主要负责两个功能：显示参数及显示控制。</strong> 这两个基本功能可以说是显示驱动必须具备的能力，在DRM框架下， 为了将这两部分适配得符合现代显示设备逻辑，又分出了几部分子模块配合框架（<strong>CRTC，ENCODER，CONNECTOR，PLANE，FB，VBLANK，property）</strong>。</p><p><strong>更新画面</strong>：显示buffer的切换，多图层的合成方式，以及每个图层的显示位置。<br><strong>设置显示参数</strong>：包括分辨率、刷新率、电源状态（休眠唤醒）等。</p></blockquote><h4 id="GMS（图形执行管理器）"><a href="#GMS（图形执行管理器）" class="headerlink" title="GMS（图形执行管理器）"></a><strong>GMS（图形执行管理器）</strong></h4><blockquote><p>它提供了一种<strong><em>*抽象的*</em>*<em>显存管理*</em>**方式**（主要负责显示buffer的分配和释放）**，使用户空间应用程序可以更方便地管理显存，而不需要了解底层硬件的细节。（</strong>DUMB、PRIME、fence）**</p></blockquote><img src="/posts/undefined/b8530def6ef20500472895d5ff25f45b.png" class="" title="在这里插入图片描述"><p><strong>基本元素</strong></p><p>DRM框架涉及到的元素很多，大致如下：</p><p>KMS：<strong>CRTC，ENCODER，CONNECTOR，PLANE，FB，VBLANK，property</strong></p><p>GEM：<strong>DUMB、PRIME、fence</strong></p><blockquote><p>学习DRM驱动其实就是学习上面各个元素的实现及用法，如果你能掌握这些知识点，那么在编写DRM驱动的时候就能游刃有余。</p></blockquote><img src="/posts/undefined/c0131052a585d4c497f612384d98ead4.png" class="" title="在这里插入图片描述"><img src="/posts/undefined/76382e53fc4867c145b4d440f07dec76.jpeg" class="" title="在这里插入图片描述"><p><a href="https://blog.csdn.net/dearsq/article/details/78394388">Linux DRM（二）基本概念和特性_Younix脏羊的博客-CSDN博客</a></p><table><thead><tr><th align="left">元素</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">CRTC</td><td align="left">电子束控制器，用于控制显卡输出信号，将帧缓存中的图像数据按照一定的方式输出到显示器上，并控制显示器的显示模式、分辨率、刷新率等参数。在DRM里有多个显存，可以通过操作CRTC来控制要显示的那个显存。</td></tr><tr><td align="left">ENCODER</td><td align="left">编码器，用于将 CRTC 输出的图像信号转换成一定格式的数字信号，通常用于连接显示器或 TV 等设备。如 HDMI、DisplayPort、DVI 等。每个 CRTC 可以有一个或多个 Encoder。</td></tr><tr><td align="left">CONNECTOR</td><td align="left">通常是用于将 Encoder 输出的信号传递给显示器，并与显示器建立连接。每个 Encoder 可以有一个或多个 Connector。</td></tr><tr><td align="left">PLANE</td><td align="left">硬件图层，负责获取显存，再输出到CRTC里，可以看作是一个显示器的图层，每个 crtc 至少要有一个 plane。通常会有多个 plane，每个 plane 可以分别设置自己的属性，从而实现多个图像内容的叠加。例如，在一个视频播放应用中，可以使用一个 plane 显示视频内容，另一个 plane 显示控制面板或字幕等内容，从而实现多个图像内容的同时显示。</td></tr><tr><td align="left">Framebuffer</td><td align="left">帧缓存，用于存储屏幕上的每个像素点的颜色信息。只用于描述显存信息（如 format、pitch、size 等），不负责显存的分配释放</td></tr><tr><td align="left">VBLANK</td><td align="left">软件和硬件的同步机制，RGB时序中的垂直消影区，软件通常使用硬件VSYNC来实现</td></tr><tr><td align="left">property</td><td align="left">原子操作的基础，任何你想设置的参数，都可以做成property，供用户空间使用，是DRM驱动中最灵活、最方便的Mode setting机制</td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">DUMB</td><td align="left">是一个dumb缓冲区，负责一些简单的buffer显示，可以通过CPU直接渲染</td></tr><tr><td align="left">PRIME</td><td align="left">连续、非连续物理内存都支持，基于DMA-BUF机制，可以实现buffer共享，多用于大内存复杂场景</td></tr><tr><td align="left">fence</td><td align="left">buffer同步机制，基于内核dma_fence机制实现，用于防止显示内容出现异步问题</td></tr></tbody></table><blockquote><p>以上内容来自：参考内容1&amp;2。</p></blockquote><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3><h3 id="2、DRM内部Objects"><a href="#2、DRM内部Objects" class="headerlink" title="2、DRM内部Objects"></a>2、DRM内部Objects</h3><img src="/posts/undefined/dcaf498811af9864c547cf527566c572.png" class="" title="在这里插入图片描述"><p>上图<strong>蓝色部分则是对物理硬件的抽象，黄色部分则是对软件的抽象。</strong>虚线以上的为<strong>drm_mode_object</strong>，虚线以下为 <strong>drm_gem_object。</strong></p><img src="/posts/undefined/8a775c35c19860bb690c953b9820be9c.png" class="" title="在这里插入图片描述"><p>上面这些objects的关系如下图所示：</p><p>通过上图可以看到，<strong>plane 是连接 framebuffer 和 crtc 的纽带，而 encoder 则是连接 crtc 和 connector 的纽带。*<em>与物理 buffer 直接打交道的是 gem 而不是 framebuffer。*</em></strong></p><blockquote><p>个人理解：</p><p>buffer是硬件存储设备， 由gem分配和释放，framebuffer用于描述分配的显存的信息（如 format、pitch、size 等），而plane用于描述图层信息，描述的是framebuffer中哪些点处于同一个图层，多个plane隶属于同一个crtc，crtc控制显卡输出图像信号，encoder将 crtc 输出的图像信号转换成一定格式的数字信号，如 HDMI、DisplayPort、DVI 等， connector用于将 Encoder 输出的信号传递给显示器，并与显示器建立连接。</p></blockquote><p>需要注意的是，上图蓝色部分即使没有实际的硬件与之对应，在软件驱动中也需要实现这些 objects，否则 DRM 子系统无法正常运行。</p><h3 id="3、drm-panel"><a href="#3、drm-panel" class="headerlink" title="3、drm_panel"></a>3、drm_panel</h3><blockquote><p>Encoder 驱动程序负责将图形数据转换为 LCD 显示器所需的视频信号，而 Connector 驱动程序则负责将这些信号发送到正确的显示设备上。<strong>LCD 驱动程序需要和Encoder、Connector 这两个驱动程序进行交互，以完成图形输出的控制。</strong></p></blockquote><img src="/posts/undefined/d7e190b7026e1322c9b430bc327d082f.png" class="" title="在这里插入图片描述"><blockquote><p>耦合的产生：<br>（1）connector 的主要作用就是获取显示参数，所以会在 LCD 驱动中去构造 connector object。但是 connector 初始化时需要 attach 上一个 encoder object，而这个 encoder object 往往是在另一个硬件驱动中生成的，为了访问该 encoder object，势必会产生一部分耦合的代码。<br>（2）encoder 除了扮演信号转换的角色，还担任着通知显示设备休眠唤醒的角色。因此，当 encoder 通知 LCD 驱动执行相应的 enable&#x2F;disable 操作时，就一定会调用 LCD 驱动导出的全局函数，这也必然会产生一部分的耦合代码。</p></blockquote><blockquote><p>Encoder 驱动与 LCD 驱动之间的耦合会造成以下问题：</p><ol><li>可维护性下降：耦合代码过多，使得维护代码变得困难。</li><li>可移植性下降：由于硬件平台的不同，encoder 驱动的实现可能不同，这就导致了 LCD 驱动对 encoder 驱动的依赖程度变高，降低了代码的可移植性。</li><li>系统可扩展性下降：由于 encoder 驱动与 LCD 驱动的紧耦合关系，当系统需要支持新的显示设备时，需要修改大量的代码，增加了系统扩展性的难度。</li></ol></blockquote><p><strong>为了解决该耦合的问题，</strong>DRM 子系统为开发人员<strong>提供了 drm_panel 结构体，</strong>该结构体封装了 connector &amp; encoder 对 LCD 访问的常用接口。</p><img src="/posts/undefined/875b41f94b9882f49c43a6796a850aad.png" class="" title="在这里插入图片描述"><blockquote><p>于是，原来的 Encoder 驱动和 LCD 驱动之间的耦合，就转变成了上图中 Encoder 驱动与 drm_panel、drm_panel 与 LCD 驱动之间的“耦合”，从而实现了 Encoder 驱动与 LCD 驱动之间的解耦合。</p></blockquote><blockquote><p>drm_panel 不属于 objects 的范畴，它只是<strong>一堆回调函数的集合。</strong>但它的存在降低了 LCD 驱动与 encoder 驱动之间的耦合度。</p></blockquote><hr><h2 id="三、DRM-驱动常用结构体"><a href="#三、DRM-驱动常用结构体" class="headerlink" title="三、DRM 驱动常用结构体"></a>三、DRM 驱动常用结构体</h2><h3 id="🍚-drm-mode-object"><a href="#🍚-drm-mode-object" class="headerlink" title="🍚 *drm_mode_object*"></a>🍚 <em><strong>*drm_mode_object*</strong></em></h3><p>对于plane、crtc、encoder、connector 几个对象，DRM框架将其称作“对象”，<strong>有一个公共基类struct drm_mode_object，</strong>这几个对象都由此基类扩展而来（该类作为crtc等结构体的成员）。</p><p><strong>如 struct crtc 结构体中存在****基类成员</strong> <strong>struct drm_mode_object：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * struct drm_crtc - central CRTC control structure</span><br><span class="line"> *</span><br><span class="line"> * Each CRTC may have one or more connectors associated with it.  This structure</span><br><span class="line"> * allows the CRTC to be controlled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct drm_crtc &#123;</span><br><span class="line">&#x2F;*挂载到&amp;drm_mode_config.crtc_list*&#x2F;</span><br><span class="line">struct list_head head;</span><br><span class="line">&#x2F;** crtc名称 *&#x2F;</span><br><span class="line">char *name;</span><br><span class="line">&#x2F;** kms mode对象 *&#x2F;</span><br><span class="line">struct drm_mode_object base;&#x2F;&#x2F; 基类</span><br><span class="line">&#x2F;*primary层*&#x2F;</span><br><span class="line">struct drm_plane *primary;</span><br><span class="line">&#x2F;*鼠标层*&#x2F;</span><br><span class="line">struct drm_plane *cursor;</span><br><span class="line">&#x2F;*序号*&#x2F;</span><br><span class="line">unsigned index;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>事实上，这个基类扩展出来的子类并不是只有上面提到的几种，本文只考虑以上四种。以下为结构体 <strong>drm_mode_object 的定义：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct drm_mode_object &#123;</span><br><span class="line">  uint32_t id;</span><br><span class="line">  uint32_t type;</span><br><span class="line">  struct drm_object_properties *properties;</span><br><span class="line">  struct kref refcount;</span><br><span class="line">  void (*free_cb)(struct kref *kref);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>struct drm_mode_object</strong> 中 id 和 type 分别为这个对象在KMS子系统中的ID和类型（即上面提到的plane、CRTC等）。drm_mode_object 从的定义中即可发现其实现了<strong>两个比较重要的功能：</strong></p><blockquote><p><strong>kref 引用计数及生命周期管理：</strong></p><p>指 drm_mode_object 对象在内核中的生命周期的管理。每个 drm_mode_object 对象都有一个引用计数，当一个对象被创建时，它的引用计数被初始化为1。每当一个新的引用指向该对象时，它的引用计数就会增加1，每当一个引用被释放时，它的引用计数就会减少1。当对象的引用计数降为0时，内核会自动释放该对象。这种方式确保了内核中不会存在不再使用的对象，从而避免了内存泄漏。</p></blockquote><blockquote><p><strong>drm_object_properties</strong> <strong>属性管理：</strong></p><p>属性管理是指在DRM驱动中，每个对象都可以拥有一组属性（例如分辨率、刷新率等），并且可以动态地增加、删除或修改属性。这些属性可以被用户空间的应用程序或者其他驱动程序获取或者设置。</p></blockquote><h3 id="🍚-Framebuffer"><a href="#🍚-Framebuffer" class="headerlink" title="🍚 Framebuffer"></a>🍚 Framebuffer</h3><p>注意framebuffer没有对应的回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; include&#x2F;drm&#x2F;drm_framebuffer.h</span><br><span class="line">struct drm_framebuffer &#123; </span><br><span class="line">struct drm_device *dev;</span><br><span class="line">struct list_head head;</span><br><span class="line">struct drm_mode_object base;</span><br><span class="line">const struct drm_format_info *format; &#x2F;&#x2F; drm格式信息</span><br><span class="line">const struct drm_framebuffer_funcs *funcs;</span><br><span class="line">unsigned int pitches[4]; &#x2F;&#x2F; Line stride per buffer</span><br><span class="line">unsigned int offsets[4]; &#x2F;&#x2F; Offset from buffer start to the actual pixel data in bytes, per buffer.</span><br><span class="line">uint64_t modifier; &#x2F;&#x2F; Data layout modifier</span><br><span class="line">unsigned int width;</span><br><span class="line">unsigned int height;</span><br><span class="line">int flags;</span><br><span class="line">int hot_x;</span><br><span class="line">int hot_y;</span><br><span class="line">struct list_head filp_head;</span><br><span class="line">struct drm_gem_object *obj[4];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>struct drm_framebuffer 主要元素的展示如下图所示(来自brezillon-drm-kms)，内存缓冲区组织，采取FOURCC格式代码：</p><img src="/posts/undefined/7be9e44bac7b7519255f0a434ddfa387.png" class="" title="在这里插入图片描述"><h3 id="🍚-Plane"><a href="#🍚-Plane" class="headerlink" title="🍚 Plane"></a>🍚 Plane</h3><p>drm_plane结构体详见：<a href="https://lxr.missinglinkelectronics.com/linux/include/drm/drm_plane.h#L595">LXR linux&#x2F;include&#x2F;drm&#x2F;drm_plane.h</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct drm_plane_funcs 结构体成员：</span><br><span class="line">1、update_plane：为给定的CRTC和framebuffer启用并配置平面</span><br><span class="line">2、disable_plane：关闭plane</span><br><span class="line">3、destroy：清除plane所有的资源</span><br><span class="line">4、reset：复位软硬件状态为关闭</span><br><span class="line">5、set_property：更新plane的property</span><br><span class="line">6、atomic_duplicate_state：复制当前的plane状态并返回</span><br><span class="line">7、atomic_destroy_state：销毁当前的plane状态</span><br><span class="line">8、atomic_set&#x2F;get_property:原子操作设置&#x2F;获得property</span><br><span class="line">9、format_mod_supported：该可选挂钩用于DRM，以确定给定的格式&#x2F;修饰符组合是否对平面有效</span><br><span class="line">struct drm_plane_helper_funcs结构体成员：</span><br><span class="line">1、prepare_fb：该钩子通过固定其后备存储器或将其重新定位到连续的VRAM块，为扫描准备帧缓冲区。其他可能的准备工作包括冲洗缓存。</span><br><span class="line">2、cleanup_fb：清除在prepare_fb分配的给framebuffer和plane的资源</span><br><span class="line">3、atomic_check：检查该挂钩中的plane特定约束</span><br><span class="line">4、atomic_update：更新plane状态</span><br><span class="line">5、atomic_disable：关闭</span><br><span class="line">6、atomic_async_check：异步检查</span><br><span class="line">7、atomic_async_update：异步更新状态</span><br></pre></td></tr></table></figure><h3 id="🍚-Crtc"><a href="#🍚-Crtc" class="headerlink" title="🍚 Crtc"></a>🍚 Crtc</h3><p>drm_crtc结构体详见：<a href="https://lxr.missinglinkelectronics.com/linux/include/drm/drm_crtc.h#L946">LXR linux&#x2F;include&#x2F;drm&#x2F;drm_crtc.h</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct drm_crtc_funcs结构体成员：</span><br><span class="line">1、reset;复位，设置为关闭状态</span><br><span class="line">2、destroy：清除CRTC资源</span><br><span class="line">3、cursor_set：更新鼠标图像</span><br><span class="line">4、cursor_move：更新光标位置</span><br><span class="line">5、gamma_set：gamma设置</span><br><span class="line">6、set_config：修改配置</span><br><span class="line">7、page_flip：修改帧缓冲页，避免垂直消影期间用新的缓冲区替代时产生撕裂</span><br><span class="line">8、set_property：设置property</span><br><span class="line">9、atomic_duplicate_state：复制当前的状态</span><br><span class="line">10、atomic_destroy_state：销毁复制的状态</span><br><span class="line">11、atomic_get_property：获取atomic_get_property</span><br><span class="line">12、set_crc_source：更改CRC的来源</span><br><span class="line">13、get_vblank_counter 获取CRTC的vblank计数器</span><br><span class="line">14、disable_vblank：关闭消影</span><br><span class="line">struct drm_crtc_helper_funcs结构体成员</span><br><span class="line">1、dpms：控制CRTC电源功率</span><br><span class="line">2、commit：提交新的模式</span><br><span class="line">3、mode_valid：用于检查特定模式在此crtc中是否有效</span><br><span class="line">4、mode_fixup：用于验证模式</span><br><span class="line">5、mode_set:设置模式</span><br><span class="line">6、mode_set_nofb：用于更新CRTC的显示模式，而不更改主平面配置的任何内容</span><br><span class="line">7、mode_set_base：设置新的帧缓冲区和扫描位置</span><br><span class="line">8、atomic_flush：完成CRTC上多个平面的更新</span><br><span class="line">9、atomic_enable&#x2F;disable:打开&#x2F;关闭</span><br></pre></td></tr></table></figure><h3 id="🍚-Encoder"><a href="#🍚-Encoder" class="headerlink" title="🍚 Encoder"></a>🍚 Encoder</h3><p>drm_encoder结构体详见：<a href="https://lxr.missinglinkelectronics.com/linux/include/drm/drm_encoder.h#L98">LXR linux&#x2F;include&#x2F;drm&#x2F;drm_encoder.h</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static const struct drm_encoder_funcs ltdc_encoder_funcs &#x3D; &#123;</span><br><span class="line">.destroy &#x3D; drm_encoder_cleanup,</span><br><span class="line">&#125;;</span><br><span class="line">static const struct drm_encoder_helper_funcs ltdc_encoder_helper_funcs &#x3D; &#123;</span><br><span class="line">.disable &#x3D; ltdc_encoder_disable,</span><br><span class="line">.enable &#x3D; ltdc_encoder_enable,</span><br><span class="line">.mode_set &#x3D; ltdc_encoder_mode_set,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="🍚-helper-函数与使用"><a href="#🍚-helper-函数与使用" class="headerlink" title="🍚 helper 函数与使用"></a>🍚 helper 函数与使用</h3><p>很多文章对 helper 函数和 drm_xxx_helper_funcs 函数产生了混淆！！！以下是我的理解，有错误评论区指出。</p><blockquote><ul><li><strong>drm_xxx_funcs 和 drm_xxx_helper_funcs 结构体是用于表示某个组件的基本操作和辅助操作的结构体；</strong></li><li><strong>而 helper 函数是 DRM 框架提供的通用函数，用于实现 DRM 驱动程序中常见的操作。</strong></li></ul></blockquote><blockquote><p>在 Linux DRM 驱动中，helper 函数指的是由 DRM 框架提供的一组辅助函数，用于简化驱动程序的实现。这些函数包括了多种类型的操作，如模式设置、原子操作、缓冲区管理等。</p><p>常见的helper函数：</p><img src="/posts/undefined/4a1986a3b135b11c5cd8f885b50b48fc.png" class="" title="img"><img src="/posts/undefined/fa4e3ca48f9d63dfbb57d9223ab20dd0.png" class="" title="img"></blockquote><blockquote><p><strong>在 drm_xxx_funcs 可以自定义回调函数（完全不使用helper函数），或者使用DRM驱动提供的helper函数直接填充（使用helper函数），如果直接使用helper函数填充不足以满足要求，还可以使用 drm_xxx_helper_funcs 中的回调函数进行补充、修改、覆盖****！</strong></p><p>终于理解了！如果你觉着有用，点个赞鼓励一下吧！</p></blockquote><h3 id="🍚-drm-xxx-funcs-和-drm-xxx-helper-funcs-区别"><a href="#🍚-drm-xxx-funcs-和-drm-xxx-helper-funcs-区别" class="headerlink" title="🍚 drm_xxx_funcs 和 drm_xxx_helper_funcs 区别"></a>🍚 drm_xxx_funcs 和 drm_xxx_helper_funcs 区别</h3><p>****在DRM子系统中，当需要执行特定组件的操作时，就会调用对应的回调函数，这些回调函数会根据其实现的功能，对特定组件进行相应的操作。****比如当系统检测到连接状态发生变化时，会调用drm_connector_funcs中的detect函数，该函数会根据当前连接状态，更新drm_connector的状态，并将状态通知给上层应用程序和显示管道。</p><p><strong>drm_xxx_funcs 和 drm_xxx_helper_funcs 都是用来定义回调函数的结构体，它们之间的区别在于它们包含的函数指针的类型和含义不同。</strong></p><p>它们的区别在于，<strong>drm_xxx_funcs</strong> 中包含一些<strong>必要的、基本的</strong>由驱动程序实现的函数指针，而 <strong>drm_xxx_helper_funcs</strong> 中包含一些<strong>可选的、辅助的</strong>由驱动程序选择性实现的辅助函数指针。</p><blockquote><p><strong>总结（来自参考文献，并进行修改）：</strong></p><p>drm_xxx_funcs 是 drm ioctl 操作的最终入口，但是对于大多数 SoC 厂商来说，它们的 drm_xxx_funcs 操作流程基本相同（你抄我，我抄你），只是在寄存器配置上存在差异，因此开发者们将那些 common 的操作流程抽象成了 helper 库函数，而将那些厂商差异化的代码放到了 drm_xxx_helper_funcs 中去，用于补充和客制化 helper 库函数。</p><p><strong>架构优势：</strong></p><p>这样双层的实现即能保证开发者有足够高的自由度（完全不用helper函数），也能简化开发者的开发（使用helper函数），同时提供给开发者hook（修改或者覆盖）特定helper函数的能力。</p></blockquote><hr><h2 id="四、DRM驱动框架（VKMS）"><a href="#四、DRM驱动框架（VKMS）" class="headerlink" title="四、DRM驱动框架（VKMS）"></a>四、DRM驱动框架（VKMS）</h2><h3 id="1、VKMS-简介"><a href="#1、VKMS-简介" class="headerlink" title="1、VKMS 简介"></a>1、VKMS 简介</h3><p><strong>VKMS 是 “Virtual Kernel Mode Setting” 的缩写，</strong>它于2018年7月5日被合入到 linux-4.19 主线版本中，并存放在 drivers&#x2F;gpu&#x2F;drm&#x2F;vkms 目录下。之所以称它为 Virtual KMS，是因为该驱动不需要真实的硬件，它完全是一个软件虚拟的“显示”设备，甚至连显示都算不上，因为当它运行时，你看不到任何显示内容。它唯一能提供的，就是一个由高精度 timer 模拟的 VSYNC 中断信号！</p><p>该驱动存在的目的，<strong>主要是为了 DRM 框架自测试，</strong>以及方便那些无头显示器设备的调试应用。虽然我们看不到 VKMS 的显示效果，但是在驱动流程上，它实现了 modesetting 该有的基本操作（Modesetting是指在显示器上渲染图像的过程中，调整显示器的分辨率、刷新率、像素格式等参数，以适应不同的应用场景和显示设备。）。<strong>因其逻辑简单，代码量少，拿来做学习案例讲解再好不过。</strong></p><img src="/posts/undefined/3aa2f87db6c6e7c307038c22231d767a.png" class="" title="img">**VKMS在Linux源码下的分布**<p>随着内核版本的不断升级，添加到 VKMS 的功能也越来越多，截止到内核版本 kernel 5.7-rc2，该 VKMS 驱动已经集成了如下功能：</p><ul><li>Atomic Modeset</li><li>VBlank</li><li>Dumb Buffer</li><li>Cursor &amp; Primary Plane</li><li>Framebuffer CRC 校验</li><li>Plane Composition</li><li>GEM Prime Import</li></ul><p>下面我们将一步一步学习如何从零开始撰写一个VKMS驱动。 </p><h3 id="2、最简单的VKMS驱动"><a href="#2、最简单的VKMS驱动" class="headerlink" title="2、最简单的VKMS驱动"></a>2、最简单的VKMS驱动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drmP.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;&#x2F;&#x2F; 用于抽象一个完整的DRM设备</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><p>我们将该驱动以 build-in 方式编译进内核，然后启动内核，如果你在 kernel log 中仔细查找，会发现有如下 drm log, 这些信息正是从上面的 name、date、major、minor 字段中获取的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[drm] Initialized vkms 1.0.0 20180514 for virtual device on minor 0</span><br></pre></td></tr></table></figure><p>除此之外，DRM 框架还为我们做了下面这些事情：</p><blockquote><p>创建设备节点：&#x2F;dev&#x2F;dri&#x2F;card0</p><p>创建 sysfs 节点：&#x2F;sys&#x2F;class&#x2F;drm&#x2F;card0</p><p>创建 debugfs 节点：&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;dri&#x2F;0</p></blockquote><p>当然，简单是以牺牲功能为代价的。该驱动目前什么事情也做不了，你唯一能做的就是查看该驱动的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;dri&#x2F;0&#x2F;name</span><br><span class="line">vkms unique&#x3D;vkms</span><br></pre></td></tr></table></figure><h3 id="3、VKMS驱动添加-fops-操作接口"><a href="#3、VKMS驱动添加-fops-操作接口" class="headerlink" title="3、VKMS驱动添加 fops 操作接口"></a>3、VKMS驱动添加 fops 操作接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drmP.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;&#x2F;&#x2F; 用于抽象一个完整的DRM设备</span><br><span class="line"></span><br><span class="line">static const struct file_operations vkms_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; drm_open,</span><br><span class="line">.release &#x3D; drm_release,</span><br><span class="line">.unlocked_ioctl &#x3D; drm_ioctl,</span><br><span class="line">.poll &#x3D; drm_poll,</span><br><span class="line">.read &#x3D; drm_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.fops&#x3D; &amp;vkms_fops,</span><br><span class="line"></span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><p>有了 fops，我们就<strong>可以对 card0 进行 open &#x2F; read 操作了。</strong>更重要的是，我们现在可以进行一些简单的 ioctl 操作了（DRM相关只读的操作，且不需要调用DRM相关回调函数的操作）！但是，到目前为止，<strong>凡是和 modesetting 相关的操作，我们还是操作不了。</strong></p><h3 id="4、添加-drm-mode-objects"><a href="#4、添加-drm-mode-objects" class="headerlink" title="4、添加 drm mode objects"></a>4、添加 drm mode objects</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drmP.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_encoder.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;&#x2F;&#x2F; 用于抽象一个完整的DRM设备</span><br><span class="line">static struct drm_plane primary;</span><br><span class="line">static struct drm_crtc crtc;</span><br><span class="line">static struct drm_encoder encoder;</span><br><span class="line">static struct drm_connector connector;</span><br><span class="line"></span><br><span class="line">static const struct drm_plane_funcs vkms_plane_funcs;</span><br><span class="line">static const struct drm_crtc_funcs vkms_crtc_funcs;</span><br><span class="line">static const struct drm_encoder_funcs vkms_encoder_funcs;</span><br><span class="line">static const struct drm_connector_funcs vkms_connector_funcs;</span><br><span class="line"></span><br><span class="line">static const u32 vkms_formats[] &#x3D; &#123;</span><br><span class="line">DRM_FORMAT_XRGB8888,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void vkms_modeset_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_mode_config_init(&amp;drm);&#x2F;&#x2F; 初始化KMS框架(初始化一些全局结构体），本质上是初始化drm_device中mode_config结构体</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化drm_device中包含的drm_connector，drm_crtc等对象</span><br><span class="line">drm_universal_plane_init(&amp;drm, &amp;primary, 0, &amp;vkms_plane_funcs,</span><br><span class="line"> vkms_formats, ARRAY_SIZE(vkms_formats),</span><br><span class="line"> NULL, DRM_PLANE_TYPE_PRIMARY, NULL);</span><br><span class="line"></span><br><span class="line">drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, NULL, &amp;vkms_crtc_funcs, NULL);</span><br><span class="line"></span><br><span class="line">drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, NULL);</span><br><span class="line"></span><br><span class="line">drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations vkms_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; drm_open,</span><br><span class="line">.release &#x3D; drm_release,</span><br><span class="line">.unlocked_ioctl &#x3D; drm_ioctl,</span><br><span class="line">.poll &#x3D; drm_poll,</span><br><span class="line">.read &#x3D; drm_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.driver_features &#x3D; DRIVER_MODESET, &#x2F;&#x2F; 添加上 DRIVER_MODESET 标志位，告诉 DRM Core 当前驱动支持 modesetting 操作</span><br><span class="line">.fops&#x3D; &amp;vkms_fops,</span><br><span class="line"></span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line"></span><br><span class="line">vkms_modeset_init();</span><br><span class="line"></span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><p>由于上面4个 objects 在创建时，它们的 <strong>callback funcs 没有赋初值，</strong>所以真正的 <strong>modeset 操作目前还无法正常执行，</strong>不过我们至少可以使用一些只读的 modeset IOCTL 了（DRM objects 相关只读的操作，且不需要调用DRM相关回调函数的操作）。</p><h3 id="5、添加-FB-和-GEM-支持"><a href="#5、添加-FB-和-GEM-支持" class="headerlink" title="5、添加 FB 和 GEM 支持"></a>5、添加 FB 和 GEM 支持</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drmP.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_encoder.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_fb_cma_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_gem_cma_helper.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;&#x2F;&#x2F; 用于抽象一个完整的DRM设备</span><br><span class="line">static struct drm_plane primary;</span><br><span class="line">static struct drm_crtc crtc;</span><br><span class="line">static struct drm_encoder encoder;</span><br><span class="line">static struct drm_connector connector;</span><br><span class="line"></span><br><span class="line">static const struct drm_plane_funcs vkms_plane_funcs;</span><br><span class="line">static const struct drm_crtc_funcs vkms_crtc_funcs;</span><br><span class="line">static const struct drm_encoder_funcs vkms_encoder_funcs;</span><br><span class="line">static const struct drm_connector_funcs vkms_connector_funcs;</span><br><span class="line"></span><br><span class="line">&#x2F;* add here *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 定义了一组函数指针，用于管理驱动程序中的显示模式配置。</span><br><span class="line">&#x2F;&#x2F; 这些函数指针包括添加和删除连接器、CRTC和编解码器，以及更新显示模式等功能。</span><br><span class="line">&#x2F;&#x2F; 这些函数在驱动程序中被调用以进行显示模式的管理和配置。</span><br><span class="line">static const struct drm_mode_config_funcs vkms_mode_funcs &#x3D; &#123;</span><br><span class="line">.fb_create &#x3D; drm_fb_cma_create, &#x2F;&#x2F; 根据给定的帧缓冲参数，创建一个新的帧缓冲对象，并返回其句柄</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const u32 vkms_formats[] &#x3D; &#123;</span><br><span class="line">DRM_FORMAT_XRGB8888,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void vkms_modeset_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_mode_config_init(&amp;drm);&#x2F;&#x2F; 初始化KMS框架，本质上是初始化drm_device中的mode_config结构体</span><br><span class="line">    &#x2F;&#x2F; 填充mode_config中int min_width, min_height; int max_width, max_height的值，这些值是framebuffer的大小限制</span><br><span class="line">drm.mode_config.max_width &#x3D; 8192;</span><br><span class="line">drm.mode_config.max_height &#x3D; 8192;</span><br><span class="line">&#x2F;* add here *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 设置mode_config-&gt;funcs指针，本质是一组由驱动实现的回调函数，涵盖KMS中一些相当基本的操作</span><br><span class="line">drm.mode_config.funcs &#x3D; &amp;vkms_mode_funcs;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 初始化drm_device中包含的drm_connector，drm_crtc等对象</span><br><span class="line">drm_universal_plane_init(&amp;drm, &amp;primary, 0, &amp;vkms_plane_funcs,</span><br><span class="line"> vkms_formats, ARRAY_SIZE(vkms_formats),</span><br><span class="line"> NULL, DRM_PLANE_TYPE_PRIMARY, NULL);</span><br><span class="line"></span><br><span class="line">drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, NULL, &amp;vkms_crtc_funcs, NULL);</span><br><span class="line"></span><br><span class="line">drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, NULL);</span><br><span class="line"></span><br><span class="line">drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 文件操作回调函数</span><br><span class="line">static const struct file_operations vkms_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; drm_open,</span><br><span class="line">.release &#x3D; drm_release,</span><br><span class="line">.unlocked_ioctl &#x3D; drm_ioctl,</span><br><span class="line">.poll &#x3D; drm_poll,</span><br><span class="line">.read &#x3D; drm_read,</span><br><span class="line">&#x2F;* add here *&#x2F;</span><br><span class="line">.mmap &#x3D; drm_gem_cma_mmap, &#x2F;&#x2F; DRM的GEM对象映射到用户空间，以便用户空间可以使用它</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.driver_features &#x3D; DRIVER_MODESET | DRIVER_GEM, &#x2F;&#x2F; 添加DRIVER_GEM 标志位，告诉 DRM Core 该驱动支持 GEM 操作</span><br><span class="line">.fops&#x3D; &amp;vkms_fops,</span><br><span class="line"></span><br><span class="line">&#x2F;* add here *&#x2F;</span><br><span class="line">.dumb_create&#x3D; drm_gem_cma_dumb_create, &#x2F;&#x2F; </span><br><span class="line">.gem_vm_ops&#x3D; &amp;drm_gem_cma_vm_ops,</span><br><span class="line">.gem_free_object_unlocked &#x3D; drm_gem_cma_free_object,</span><br><span class="line"></span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line"></span><br><span class="line">vkms_modeset_init();</span><br><span class="line"></span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><p>现在，我们可以使用 IOCTL 来进行一些标准的 GEM 和 FB 操作了！</p><h4 id="驱动解析1"><a href="#驱动解析1" class="headerlink" title="驱动解析1 :"></a><strong>驱动解析1 :</strong></h4><p>我们知道drm_device用于抽象一个完整的DRM设备，而其中与<strong>Mode Setting相关的部分则由drm_mode_config 进行管理。</strong>drm_mode_config 的主要功能之一是<strong>提供对显示器模式的管理和配置。</strong>这包括添加、删除、修改和查询显示器模式的能力。此外，drm_mode_config还提供了与模式相关的配置选项，例如色彩空间、刷新率、分辨率等等。</p><p><strong>在 drm_device 中存在 mode_config 这个 drm_mode_config 结构体:</strong> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* struct drm_device - DRM device structure</span><br><span class="line">*</span><br><span class="line">* This structure represent a complete card that</span><br><span class="line">* may contain multiple heads.</span><br><span class="line">*&#x2F;</span><br><span class="line">struct drm_device &#123;</span><br><span class="line">    &#x2F;** @if_version: Highest interface version set *&#x2F;</span><br><span class="line">    int if_version;</span><br><span class="line"></span><br><span class="line">    &#x2F;** @ref: Object ref-count *&#x2F;</span><br><span class="line">    struct kref ref;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &#x2F;** @mode_config: Current mode config *&#x2F;</span><br><span class="line">    struct drm_mode_config mode_config;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 mode_config 这个 *<em>drm_mode_config 结构体中存在一个*<em>类*<em>型为 drm_mode_config_func 的回调函数 func。</em></em></em>*drm_mode_config_func是一个函数指针结构体，用于驱动程序向内核注册显示器模式配置的回调函数。**这些函数指针包括添加和删除连接器、CRTC和编解码器，以及更新显示模式等功能。当内核需要对显示器模式进行配置或管理时，它将调用这些回调函数以执行相应操作。</p><blockquote><p>drm_mode_config_funcs结构体中的 fb_create 作用：</p><p>fb_create 函数的作用是根据给定的帧缓冲参数，创建一个新的**帧缓冲对象**（并不是分配内存，只是创建帧缓冲对象，因为 framebuffer 不涉及内存的分配与释放）****，并返回其句柄。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* struct drm_mode_config - Mode configuration control structure</span><br><span class="line">* @min_width: minimum fb pixel width on this device</span><br><span class="line">* @min_height: minimum fb pixel height on this device</span><br><span class="line">* @max_width: maximum fb pixel width on this device</span><br><span class="line">* @max_height: maximum fb pixel height on this device</span><br><span class="line">* @funcs: core driver provided mode setting functions</span><br><span class="line">* @fb_base: base address of the framebuffer</span><br><span class="line">* @poll_enabled: track polling support for this device</span><br><span class="line">* @poll_running: track polling status for this device</span><br><span class="line">* @delayed_event: track delayed poll uevent deliver for this device</span><br><span class="line">* @output_poll_work: delayed work for polling in process context</span><br><span class="line">* @preferred_depth: preferred RBG pixel depth, used by fb helpers</span><br><span class="line">* @prefer_shadow: hint to userspace to prefer shadow-fb rendering</span><br><span class="line">* @cursor_width: hint to userspace for max cursor width</span><br><span class="line">* @cursor_height: hint to userspace for max cursor height</span><br><span class="line">* @helper_private: mid-layer private data</span><br><span class="line">*</span><br><span class="line">* Core mode resource tracking structure.  All CRTC, encoders, and connectors</span><br><span class="line">* enumerated by the driver are added here, as are global properties.  Some</span><br><span class="line">* global restrictions are also here, e.g. dimension restrictions.</span><br><span class="line">*&#x2F;</span><br><span class="line">struct drm_mode_config &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    int min_width, min_height;</span><br><span class="line">    int max_width, max_height;</span><br><span class="line">    const struct drm_mode_config_funcs *funcs;</span><br><span class="line">    resource_size_t fb_base;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="驱动解析2"><a href="#驱动解析2" class="headerlink" title="驱动解析2 :"></a><strong>驱动解析2 :</strong></h4><blockquote><p><em>*<em>*dumb_create： struct drm_driver 结构体中的一个函数指针，它指向的函数用于在 DRM 子系统中*</em>*<em>创建 dumb buffer，也就是一个简单的、未映射的内存区域，*</em>*<em>通常用于测试或临时存储。*</em>*</em></p></blockquote><p>dumb_create：分配 dumb buffer 的回调接口，主要完成三件事：<br>（1）创建 gem object<br>（2）创建 gem handle<br>（3）分配物理 buffer （也可以等到后面再分配）<br>本例中直接使用 CMA helper 函数实现，该函数内部会分配最终的物理 buffer。</p><blockquote><p><strong>GEM分配的内存区域通过映射之后交给Frame buffer驱动程序使用。*<em>Frame buffer驱动程序不直接分配内存，而是通过访问GEM对象来获取内存区域的物理地址等信息，以便正确地管理和利用帧缓冲区中的显示数据。*</em></strong></p><p>在将GEM映射到帧缓冲区时，需要经过以下两个步骤：</p><ol><li>将GEM对象中的内存区域映射到内核空间的虚拟地址空间中。</li><li>将内核空间中的GEM内存区域映射到显示设备的显存中。</li></ol></blockquote><h4 id="驱动解析3"><a href="#驱动解析3" class="headerlink" title="驱动解析3 :"></a>驱动解析3 :</h4><p><strong>mmp:</strong> 将GEM内存映射到用户控件。创建 dumb buffer 的目的就是要拿去给 CPU 画图，因此没有 mmap 的 dumb buffer 是没有灵魂的，所以必须实现。通常使用 drm_gem_mmap() 来实现。在 kernel 驱动中，实现 mmap 系统调用离不开两个关键步骤：<strong>（1）内存分配 （2） 建立映射关系</strong>。这刚好也对应了 DRM 中的 <em>dumb_create</em> 和 <em>mmap</em> 操作。</p><h4 id="驱动解析4"><a href="#驱动解析4" class="headerlink" title="驱动解析4 :"></a>驱动解析4 :</h4><p>gem_vm_ops：该函数指针中包含的各种操作函数，例如 fault, open, close, access 等，都是<strong>用于实现 GEM 内存管理机制的各种功能。</strong></p><blockquote><ul><li>mmap 函数是将设备<strong>内存映射</strong>到进程的<strong>用户空间，</strong>让应用程序可以直接访问设备内存。</li><li>gem_vm_ops 函数指针则是在用户空间程序请求显存时被调用(mmp)，用于控制显存的访问权限、分配显存、映射显存到用户空间等操作，从而确保显存的安全性和高效性。</li></ul></blockquote><p>这个过程涉及到分配一块虚拟内存、映射物理内存、建立页表等操作。 因此，在实现 DRM 驱动时，这两个函数通常需要一起实现，以支持对设备内存的映射操作。</p><h4 id="驱动解析5"><a href="#驱动解析5" class="headerlink" title="驱动解析5 :"></a>驱动解析5 :</h4><p>gem_free_object_unlocked ：该指针指向一个函数，用于释放GEM对象的资源。具体来说，当一个GEM对象不再被使用时，该函数将被调用来释放该对象的内存、锁定的页面等资源。这个函数指针可以在结构体中 struct drm_driver 定义，作为驱动的一部分，因此在驱动代码中可以使用它来释放GEM对象的资源。</p><h3 id="6、实现-callback-funcs-并添加-Legacy-Modeset-支持"><a href="#6、实现-callback-funcs-并添加-Legacy-Modeset-支持" class="headerlink" title="6、实现 callback funcs 并添加 Legacy Modeset 支持"></a>6、实现 callback funcs 并添加 Legacy Modeset 支持</h3><p>Legacy Modeset 是指在 Linux DRM 框架中使用传统的 KMS 模式设置，也称为“旧模式设置”。</p><p>在 Legacy Modeset 中，<strong>驱动程序需要执行多个步骤来更改图形模式</strong>，例如分配帧缓冲，设置分辨率和刷新率等。这些步骤是分开执行的，如果其中的任何一步出现错误，整个操作都可能失败。可能会导致画面闪烁、撕裂或丢失帧等问题，而且驱动程序必须花费额外的时间来撤消之前的更改。</p><p>因此，Legacy Modeset 的主要缺点是不具备原子性，无法保证更改的一致性和可靠性。这也是 Atom Modeset 出现的主要原因。Atom Modeset 可以将多个操作封装成一个事务并原子地提交给硬件，从而保证所有更改都是一致和可靠的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drm_crtc_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_plane_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_fb_cma_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_gem_cma_helper.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;</span><br><span class="line">static struct drm_plane primary;</span><br><span class="line">static struct drm_crtc crtc;</span><br><span class="line">static struct drm_encoder encoder;</span><br><span class="line">static struct drm_connector connector;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_dpms(struct drm_crtc *crtc, int mode)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int vkms_crtc_mode_set(struct drm_crtc *crtc,</span><br><span class="line">struct drm_display_mode *mode,</span><br><span class="line">struct drm_display_mode *adjusted_mode,</span><br><span class="line">int x, int y, struct drm_framebuffer *old_fb)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_prepare(struct drm_crtc *crtc)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_commit(struct drm_crtc *crtc)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int vkms_crtc_page_flip(struct drm_crtc *crtc,</span><br><span class="line">struct drm_framebuffer *fb,</span><br><span class="line">struct drm_pending_vblank_event *event,</span><br><span class="line">uint32_t page_flip_flags,</span><br><span class="line">struct drm_modeset_acquire_ctx *ctx)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">crtc-&gt;primary-&gt;fb &#x3D; fb;</span><br><span class="line">if (event) &#123;</span><br><span class="line">spin_lock_irqsave(&amp;crtc-&gt;dev-&gt;event_lock, flags);</span><br><span class="line">drm_crtc_send_vblank_event(crtc, event);</span><br><span class="line">spin_unlock_irqrestore(&amp;crtc-&gt;dev-&gt;event_lock, flags);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs &#x3D; &#123;</span><br><span class="line">.dpms &#x3D; vkms_crtc_dpms,</span><br><span class="line">.mode_set &#x3D; vkms_crtc_mode_set,</span><br><span class="line">.prepare &#x3D; vkms_crtc_prepare,</span><br><span class="line">.commit &#x3D; vkms_crtc_commit,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_crtc_funcs vkms_crtc_funcs &#x3D; &#123;</span><br><span class="line">.set_config &#x3D; drm_crtc_helper_set_config,</span><br><span class="line">.page_flip &#x3D; vkms_crtc_page_flip,</span><br><span class="line">.destroy &#x3D; drm_crtc_cleanup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_plane_funcs vkms_plane_funcs &#x3D; &#123;</span><br><span class="line">.update_plane &#x3D; drm_primary_helper_update,</span><br><span class="line">.disable_plane &#x3D; drm_primary_helper_disable,</span><br><span class="line">.destroy &#x3D; drm_plane_cleanup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int vkms_connector_get_modes(struct drm_connector *connector)</span><br><span class="line">&#123;</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">count &#x3D; drm_add_modes_noedid(connector, 8192, 8192);</span><br><span class="line">drm_set_preferred_mode(connector, 1024, 768);</span><br><span class="line"></span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct drm_encoder *vkms_connector_best_encoder(struct drm_connector *connector)</span><br><span class="line">&#123;</span><br><span class="line">return &amp;encoder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct drm_connector_helper_funcs vkms_conn_helper_funcs &#x3D; &#123;</span><br><span class="line">.get_modes &#x3D; vkms_connector_get_modes,</span><br><span class="line">.best_encoder &#x3D; vkms_connector_best_encoder,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct drm_connector_funcs vkms_connector_funcs &#x3D; &#123;</span><br><span class="line">.dpms &#x3D; drm_helper_connector_dpms,</span><br><span class="line">.fill_modes &#x3D; drm_helper_probe_single_connector_modes,</span><br><span class="line">.destroy &#x3D; drm_connector_cleanup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_encoder_funcs vkms_encoder_funcs &#x3D; &#123;</span><br><span class="line">.destroy &#x3D; drm_encoder_cleanup,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_mode_config_funcs vkms_mode_funcs &#x3D; &#123;</span><br><span class="line">.fb_create &#x3D; drm_fb_cma_create,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const u32 vkms_formats[] &#x3D; &#123;</span><br><span class="line">DRM_FORMAT_XRGB8888,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void vkms_modeset_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_mode_config_init(&amp;drm);</span><br><span class="line">drm.mode_config.max_width &#x3D; 8192;</span><br><span class="line">drm.mode_config.max_height &#x3D; 8192;</span><br><span class="line">drm.mode_config.funcs &#x3D; &amp;vkms_mode_funcs;</span><br><span class="line"></span><br><span class="line">drm_universal_plane_init(&amp;drm, &amp;primary, 0, &amp;vkms_plane_funcs,</span><br><span class="line"> vkms_formats, ARRAY_SIZE(vkms_formats),</span><br><span class="line"> NULL, DRM_PLANE_TYPE_PRIMARY, NULL);</span><br><span class="line"></span><br><span class="line">drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, NULL, &amp;vkms_crtc_funcs, NULL);</span><br><span class="line">drm_crtc_helper_add(&amp;crtc, &amp;vkms_crtc_helper_funcs);</span><br><span class="line"></span><br><span class="line">drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, NULL);</span><br><span class="line"></span><br><span class="line">drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);</span><br><span class="line">drm_connector_helper_add(&amp;connector, &amp;vkms_conn_helper_funcs);</span><br><span class="line">drm_mode_connector_attach_encoder(&amp;connector, &amp;encoder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations vkms_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; drm_open,</span><br><span class="line">.release &#x3D; drm_release,</span><br><span class="line">.unlocked_ioctl &#x3D; drm_ioctl,</span><br><span class="line">.poll &#x3D; drm_poll,</span><br><span class="line">.read &#x3D; drm_read,</span><br><span class="line">.mmap &#x3D; drm_gem_cma_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.driver_features&#x3D; DRIVER_MODESET | DRIVER_GEM,</span><br><span class="line">.fops&#x3D; &amp;vkms_fops,</span><br><span class="line"></span><br><span class="line">.dumb_create&#x3D; drm_gem_cma_dumb_create,</span><br><span class="line">.gem_vm_ops&#x3D; &amp;drm_gem_cma_vm_ops,</span><br><span class="line">.gem_free_object_unlocked &#x3D; drm_gem_cma_free_object,</span><br><span class="line"></span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line"></span><br><span class="line">vkms_modeset_init();</span><br><span class="line"></span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><ol><li>*<strong>xxx_funcs* 必须有，*xxx_helper_funcs* 可以没有。</strong></li><li><em>drm_xxx_init()</em> 必须有，<em>drm_xxx_helper_add()</em> 可以没有。</li><li>只有当 <em>xxx_funcs</em> 采用 DRM 标准的 helper 函数实现时，才<strong>有可能</strong> 需要定义 <em>xxx_helper_funcs</em> 接口。</li><li><em>xxx_funcs.destroy()</em> 接口必须实现。</li></ol><p>有了各种 funcs 和 helper funcs，我们现在终于可以执行真正的 modeset 操作了，不过目前只支持 legacy modeset。</p><h3 id="7、将-Legacy-code-转换为-Atomic-版本"><a href="#7、将-Legacy-code-转换为-Atomic-版本" class="headerlink" title="7、将 Legacy code 转换为 Atomic 版本"></a>7、将 Legacy code 转换为 Atomic 版本</h3><p>DRM驱动的legacy模式是一种传统的方法，它使用一个内核模块来管理DRM资源，支持在内核空间和用户空间之间进行资源管理。这种模式比较简单，但性能不太好，而且容易出现错误。</p><p>Atomic模式是一种更新的模式，它使用多个内核模块来管理DRM资源，并且支持在内核空间和用户空间之间进行原子操作，从而提供更好的性能和可靠性。Atomic模式比legacy模式更复杂，但性能更好，而且更加可靠。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;drm&#x2F;drm_atomic_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_crtc_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_fb_cma_helper.h&gt;</span><br><span class="line">#include &lt;drm&#x2F;drm_gem_cma_helper.h&gt;</span><br><span class="line">#include &lt;linux&#x2F;hrtimer.h&gt;</span><br><span class="line"></span><br><span class="line">static struct drm_device drm;</span><br><span class="line">static struct drm_plane primary;</span><br><span class="line">static struct drm_crtc crtc;</span><br><span class="line">static struct drm_encoder encoder;</span><br><span class="line">static struct drm_connector connector;</span><br><span class="line">static struct hrtimer vblank_hrtimer;</span><br><span class="line"></span><br><span class="line">static enum hrtimer_restart vkms_vblank_simulate(struct hrtimer *timer)</span><br><span class="line">&#123;</span><br><span class="line">drm_crtc_handle_vblank(&amp;crtc);</span><br><span class="line"></span><br><span class="line">hrtimer_forward_now(&amp;vblank_hrtimer, 16666667);</span><br><span class="line"></span><br><span class="line">return HRTIMER_RESTART;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_atomic_enable(struct drm_crtc *crtc,</span><br><span class="line">    struct drm_crtc_state *old_state)</span><br><span class="line">&#123;</span><br><span class="line">hrtimer_init(&amp;vblank_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br><span class="line">vblank_hrtimer.function &#x3D; &amp;vkms_vblank_simulate;</span><br><span class="line">hrtimer_start(&amp;vblank_hrtimer, 16666667, HRTIMER_MODE_REL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_atomic_disable(struct drm_crtc *crtc,</span><br><span class="line">     struct drm_crtc_state *old_state)</span><br><span class="line">&#123;</span><br><span class="line">hrtimer_cancel(&amp;vblank_hrtimer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void vkms_crtc_atomic_flush(struct drm_crtc *crtc,</span><br><span class="line">   struct drm_crtc_state *old_crtc_state)</span><br><span class="line">&#123;</span><br><span class="line">unsigned long flags;</span><br><span class="line"></span><br><span class="line">if (crtc-&gt;state-&gt;event) &#123;</span><br><span class="line">spin_lock_irqsave(&amp;crtc-&gt;dev-&gt;event_lock, flags);</span><br><span class="line">drm_crtc_send_vblank_event(crtc, crtc-&gt;state-&gt;event);</span><br><span class="line">spin_unlock_irqrestore(&amp;crtc-&gt;dev-&gt;event_lock, flags);</span><br><span class="line"></span><br><span class="line">crtc-&gt;state-&gt;event &#x3D; NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct drm_crtc_helper_funcs vkms_crtc_helper_funcs &#x3D; &#123;</span><br><span class="line">.atomic_enable&#x3D; vkms_crtc_atomic_enable,</span><br><span class="line">.atomic_disable&#x3D; vkms_crtc_atomic_disable,</span><br><span class="line">.atomic_flush&#x3D; vkms_crtc_atomic_flush,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_crtc_funcs vkms_crtc_funcs &#x3D; &#123;</span><br><span class="line">.set_config             &#x3D; drm_atomic_helper_set_config,</span><br><span class="line">.page_flip              &#x3D; drm_atomic_helper_page_flip,</span><br><span class="line">.destroy                &#x3D; drm_crtc_cleanup,</span><br><span class="line">.reset                  &#x3D; drm_atomic_helper_crtc_reset,</span><br><span class="line">.atomic_duplicate_state &#x3D; drm_atomic_helper_crtc_duplicate_state,</span><br><span class="line">.atomic_destroy_state   &#x3D; drm_atomic_helper_crtc_destroy_state,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void vkms_plane_atomic_update(struct drm_plane *plane,</span><br><span class="line">      struct drm_plane_state *old_state)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct drm_plane_helper_funcs vkms_plane_helper_funcs &#x3D; &#123;</span><br><span class="line">.atomic_update&#x3D; vkms_plane_atomic_update,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_plane_funcs vkms_plane_funcs &#x3D; &#123;</span><br><span class="line">.update_plane&#x3D; drm_atomic_helper_update_plane,</span><br><span class="line">.disable_plane&#x3D; drm_atomic_helper_disable_plane,</span><br><span class="line">.destroy&#x3D; drm_plane_cleanup,</span><br><span class="line">.reset&#x3D; drm_atomic_helper_plane_reset,</span><br><span class="line">.atomic_duplicate_state &#x3D; drm_atomic_helper_plane_duplicate_state,</span><br><span class="line">.atomic_destroy_state&#x3D; drm_atomic_helper_plane_destroy_state,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int vkms_conn_get_modes(struct drm_connector *connector)</span><br><span class="line">&#123;</span><br><span class="line">int count;</span><br><span class="line"></span><br><span class="line">count &#x3D; drm_add_modes_noedid(connector, 8192, 8192);</span><br><span class="line">drm_set_preferred_mode(connector, 1024, 768);</span><br><span class="line"></span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct drm_connector_helper_funcs vkms_conn_helper_funcs &#x3D; &#123;</span><br><span class="line">.get_modes &#x3D; vkms_conn_get_modes,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_connector_funcs vkms_connector_funcs &#x3D; &#123;</span><br><span class="line">.fill_modes &#x3D; drm_helper_probe_single_connector_modes,</span><br><span class="line">.destroy &#x3D; drm_connector_cleanup,</span><br><span class="line">.reset &#x3D; drm_atomic_helper_connector_reset, &#x2F;&#x2F; reset函数通常被用于在DRM模式切换或重置时，重置plane对象的状态。</span><br><span class="line">.atomic_duplicate_state &#x3D; drm_atomic_helper_connector_duplicate_state,</span><br><span class="line">.atomic_destroy_state &#x3D; drm_atomic_helper_connector_destroy_state,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在DRM中，encoder对象的状态更新和禁用等操作都是通过对应的CRTC对象的状态进行修改来实现的，因此在encoder_funcs结构体中确实不需要实现.atomic_duplicate_state成员。encoder对象的状态更新和禁用等操作都是由CRTC对象的状态更新和禁用等操作来完成的。</span><br><span class="line">static const struct drm_encoder_funcs vkms_encoder_funcs &#x3D; &#123;</span><br><span class="line">.destroy &#x3D; drm_encoder_cleanup, &#x2F;&#x2F; DRM框架中的一个helper函数，用于清理encoder对象的资源。</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const struct drm_mode_config_funcs vkms_mode_funcs &#x3D; &#123;</span><br><span class="line">.fb_create &#x3D; drm_fb_cma_create,</span><br><span class="line">.atomic_check &#x3D; drm_atomic_helper_check, &#x2F;&#x2F; 遍历原子状态中的各个平面状态信息，并进行一些检查，以确保新的状态是合法的，并且可以被应用到显卡硬件上。</span><br><span class="line">.atomic_commit &#x3D; drm_atomic_helper_commit, &#x2F;&#x2F; 根据原子状态中的各个平面状态信息，计算出新的显卡状态，并将其应用到显卡硬件上，从而实现显示输出</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static const u32 vkms_formats[] &#x3D; &#123;</span><br><span class="line">DRM_FORMAT_XRGB8888,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void vkms_modeset_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_mode_config_init(&amp;drm);</span><br><span class="line">drm.mode_config.max_width &#x3D; 8192;</span><br><span class="line">drm.mode_config.max_height &#x3D; 8192;</span><br><span class="line">drm.mode_config.funcs &#x3D; &amp;vkms_mode_funcs;</span><br><span class="line"></span><br><span class="line">drm_universal_plane_init(&amp;drm, &amp;primary, 0, &amp;vkms_plane_funcs,</span><br><span class="line"> vkms_formats, ARRAY_SIZE(vkms_formats),</span><br><span class="line"> NULL, DRM_PLANE_TYPE_PRIMARY, NULL);</span><br><span class="line">drm_plane_helper_add(&amp;primary, &amp;vkms_plane_helper_funcs);</span><br><span class="line"></span><br><span class="line">drm_crtc_init_with_planes(&amp;drm, &amp;crtc, &amp;primary, NULL, &amp;vkms_crtc_funcs, NULL);</span><br><span class="line">drm_crtc_helper_add(&amp;crtc, &amp;vkms_crtc_helper_funcs);</span><br><span class="line"></span><br><span class="line">drm_encoder_init(&amp;drm, &amp;encoder, &amp;vkms_encoder_funcs, DRM_MODE_ENCODER_VIRTUAL, NULL);</span><br><span class="line"></span><br><span class="line">drm_connector_init(&amp;drm, &amp;connector, &amp;vkms_connector_funcs, DRM_MODE_CONNECTOR_VIRTUAL);</span><br><span class="line">drm_connector_helper_add(&amp;connector, &amp;vkms_conn_helper_funcs);</span><br><span class="line">drm_mode_connector_attach_encoder(&amp;connector, &amp;encoder);</span><br><span class="line"></span><br><span class="line">drm_mode_config_reset(&amp;drm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static const struct file_operations vkms_fops &#x3D; &#123;</span><br><span class="line">.owner &#x3D; THIS_MODULE,</span><br><span class="line">.open &#x3D; drm_open,</span><br><span class="line">.release &#x3D; drm_release,</span><br><span class="line">.unlocked_ioctl &#x3D; drm_ioctl,</span><br><span class="line">.poll &#x3D; drm_poll,</span><br><span class="line">.read &#x3D; drm_read,</span><br><span class="line">.mmap &#x3D; drm_gem_cma_mmap,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct drm_driver vkms_driver &#x3D; &#123;</span><br><span class="line">.driver_features &#x3D; DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC, &#x2F;&#x2F; 给 driver_features 添加上 DRIVER_ATOMIC 标志位，告诉 DRM Core 该驱动支持 Atomic 操作。</span><br><span class="line">.fops&#x3D; &amp;vkms_fops,</span><br><span class="line"></span><br><span class="line">.dumb_create&#x3D; drm_gem_cma_dumb_create,</span><br><span class="line">.gem_vm_ops&#x3D; &amp;drm_gem_cma_vm_ops,</span><br><span class="line">.gem_free_object_unlocked &#x3D; drm_gem_cma_free_object,</span><br><span class="line"></span><br><span class="line">.name&#x3D; &quot;vkms&quot;,</span><br><span class="line">.desc&#x3D; &quot;Virtual Kernel Mode Setting&quot;,</span><br><span class="line">.date&#x3D; &quot;20180514&quot;,</span><br><span class="line">.major&#x3D; 1,</span><br><span class="line">.minor&#x3D; 0,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int __init vkms_init(void)</span><br><span class="line">&#123;</span><br><span class="line">drm_dev_init(&amp;drm, &amp;vkms_driver, NULL);</span><br><span class="line"></span><br><span class="line">vkms_modeset_init();</span><br><span class="line"></span><br><span class="line">drm_vblank_init(&amp;drm, 1);</span><br><span class="line"></span><br><span class="line">drm.irq_enabled &#x3D; true;</span><br><span class="line"></span><br><span class="line">drm_dev_register(&amp;drm, 0);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(vkms_init);</span><br></pre></td></tr></table></figure><h4 id="驱动分析1："><a href="#驱动分析1：" class="headerlink" title="驱动分析1："></a>驱动分析1：</h4><p>atomic_duplicate_state：创建一个新的原子状态，并将原子状态中的所有对象（包括CRTC、connector、encoder等等）进行复制。</p><p>atomic_destroy_state：释放原子状态占用的所有资源，包括CRTC、connector、encoder等等。具体来说，该函数会遍历原子状态对象中的所有对象，并依次释放它们占用的资源。另外，该函数还会释放原子状态对象本身。</p><h4 id="驱动分析2："><a href="#驱动分析2：" class="headerlink" title="驱动分析2："></a>驱动分析2：</h4><p>drm_mode_config_funcs.atomic_commit() 接口是 atomic 操作的主要入口函数，必须实现。这里直接使用 drm_atomic_helper_commit() 函数实现。</p><blockquote><p>drm_atomic_helper_commit() 函数的作用是帮助应用程序提交一组关联的对象的更新请求，并保证它们以原子方式生效，从而保证图形显示的稳定性和一致性。</p><p>在DRM中，图形显示涉及多个对象，包括CRTC（控制器）、encoder（编码器）和connector（连接器）等。这些对象之间存在复杂的依赖关系，更新请求必须以原子方式提交，以确保它们同时生效，从而避免出现不一致的图形显示。</p></blockquote><h4 id="驱动分析3："><a href="#驱动分析3：" class="headerlink" title="驱动分析3："></a>驱动分析3：</h4><p>在 plane&#x2F;crtc&#x2F;encoder&#x2F;connector objects 初始化完成之后，一定要调用 drm_mode_config_reset() 来动态创建各个 pipeline 的软件状态（即 drm_xxx_state）。</p><h4 id="驱动分析4："><a href="#驱动分析4：" class="headerlink" title="驱动分析4："></a>驱动分析4：</h4><p>与 Legacy 相比，Atomic 的 xxx_funcs 必须 实现如下接口：</p><blockquote><p>reset()</p><p>atomic_duplicate_state()</p><p>atomic_destroy_state()</p></blockquote><p>它们主要用于维护 drm_xxx_state 数据结构，不能省略！</p><h4 id="驱动分析5："><a href="#驱动分析5：" class="headerlink" title="驱动分析5："></a>驱动分析5：</h4><p>drm_plane_helper_funcs.atomic_update() 必须实现！（不太理解）</p><blockquote><p>这个函数用于在DRM原子模式下更新plane对象的状态。如果一个plane对象没有实现.atomic_update函数，那么在使用DRM原子模式时，就无法正确地更新该plane对象的状态，从而导致显示异常或者错误。</p></blockquote><h4 id="驱动分析6："><a href="#驱动分析6：" class="headerlink" title="驱动分析6："></a>驱动分析6：</h4><p>Atomic 操作依赖 VSYNC 中断（即 VBLANK 事件），因此需要使用 hrtimer 来提供软件中断信号。在驱动初始化时调用 drm_vblank_init()，在 VSYNC 中断处理函数中调用 drm_handle_vblank()。</p><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>要实现一个 DRM KMS 驱动，通常需要实现如下代码：</p><blockquote><p><strong>fops、drm_driver</strong></p><p><strong>dumb_create、fb_create、atomic_commit</strong></p><p><strong>drm_xxx_funcs、drm_xxx_helper_funcs</strong></p><p><strong>drm_xxx_init()、drm_xxx_helper_add()</strong></p><p><strong>drm_dev_init()、drm_dev_register()</strong></p></blockquote><p>但这都只是表象，核心仍然是上面介绍的7个 objects，一切都围绕着这几个 objects 展开：</p><blockquote><ul><li><strong>为了创建 crtc&#x2F;plane&#x2F;encoder&#x2F;connector objects，需要调用 drm_xxx_init()。</strong></li><li><strong>为了创建 framebuffer object，需要实现 fb_create() callback。</strong></li><li><strong>为了创建 gem object，需要实现 dumb_create() callback。</strong></li><li><strong>为了创建 property objects，需要调用 drm_mode_config_init()。</strong></li><li><strong>为了让这些 objects 动起来，需要实现各种 funcs 和 helper funcs。</strong></li><li><strong>为了支持 atomic 操作，需要实现 atomic_commit() callback。</strong></li></ul></blockquote><hr><h2 id="六、panel-simple-c文件分析"><a href="#六、panel-simple-c文件分析" class="headerlink" title="六、panel-simple.c文件分析"></a>六、panel-simple.c文件分析</h2><p>panel_simple.c只是DRM驱动中用于与RGB屏幕交互的一种手段(相当于connector），它仅适用于简单的设备和场景。</p><p>在panel_simple.c中的DRM驱动生成的&#x2F;dev&#x2F;dri&#x2F;card0设备节点同时也会自动生成一个&#x2F;dev&#x2F;fb0设备节点，用于向后兼容传统的Framebuffer接口。</p><p>但需要注意的是，这个Framebuffer接口只能使用一些基本的功能，如显存映射和控制台输出等，而不能使用DRM提供的高级功能。</p><p>对于全志的DRM架构如下图所示：</p><img src="/posts/undefined/c7ea09e82764a0dd07de808cd039984e.png" class="" title="img"><img src="/posts/undefined/6d6729868043b38e629bc50cb7930884.png" class="" title="img"><hr><h2 id="七、参考内容"><a href="#七、参考内容" class="headerlink" title="七、参考内容"></a>七、参考内容</h2><p>1.<a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/framework_drm.html">DRM图形显示框架</a></p><p>2.<a href="https://blog.csdn.net/hexiaolong2009/article/details/83720940">DRM（Direct Rendering Manager）学习简介_何小龙csdn_何小龙的博客-CSDN博客</a> </p><p>3.<a href="https://www.codetd.com/article/14487936">DRM (Direct Rendering Manager) 的基本概念 - 代码天地</a></p><p>4.<a href="https://blog.csdn.net/zichuanning520/article/details/127254426">DRM几个重要的结构体及panel开发_drm panel_紫川宁520的博客-CSDN博客</a></p><p>5.<a href="https://cloud.tencent.com/developer/article/2021477">《DRM 专栏》| 彻底入门 DRM 驱动 - 腾讯云开发者社区-腾讯云</a></p><p>6.<a href="https://crab2313.github.io/post/drm-legacy-kms/#%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86">DRM框架分析（二）：KMS</a></p><p>7.<a href="https://blog.csdn.net/hexiaolong2009/article/details/106532966">DRM GEM 驱动程序开发（dumb）_何小龙的博客-CSDN博客</a></p><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ol><li><p>墨云<a href="https://www.cnblogs.com/twzy/p/14865952.html">uboot移植</a>；</p></li><li><p>稚辉君<a href="https://github.com/peng-zhihui/Planck-Pi">github</a>项目；</p></li><li><p>正点原子《嵌入式Linux驱动开发指南》</p></li></ol><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://download.csdn.net/blog/column/12158774/130497208">F1C200s 的 GPIO 编号规则</a></li><li><a href="https://download.csdn.net/blog/column/12158774/124389957">硬件制作–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128519540">uboot移植–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128544843">内核移植–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128553772">根文件系统–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128570505">Debian系统–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128586204">正点原子4.3寸RGB屏幕驱动–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128661071">GT1151触摸屏驱动–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128684988">USB驱动–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128694780">音频驱动–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128721720">WiFi驱动–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/128758130">NES游戏移植–从零开始自制linux掌上电脑（F1C200S)</a></li><li><a href="https://download.csdn.net/blog/column/12158774/130235461">【项目原理】多点触摸屏驱动原理</a></li><li><a href="https://download.csdn.net/blog/column/12158774/129472180">项目原理】DRM驱动概念、组成、框架、源码分析</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">从零开始自制linux掌上电脑（F1C200S)详细教程-这个特别详细</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="BOOTROM" scheme="https://zml3589110.github.io/tags/BOOTROM/"/>
    
    <category term="SPL" scheme="https://zml3589110.github.io/tags/SPL/"/>
    
    <category term="启动流程" scheme="https://zml3589110.github.io/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>F1C200S在Linux下环境搭建</title>
    <link href="https://zml3589110.github.io/posts/740584845.html"/>
    <id>https://zml3589110.github.io/posts/740584845.html</id>
    <published>2025-09-17T12:06:20.000Z</published>
    <updated>2025-09-19T03:47:58.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一开始只想要裸机搭建，不想弄那么麻烦！画的板子是没有flsh，本来还以为内置Flash,误认为DDR1的64MB是内存，实际上是RAM，所以根本无法运行<br>启动顺序是先找SD卡然后FLASH，如果这两个都没有就会进入FLE模式。<br>昨天买了SD卡托来放内存卡，今天研究了一天才基本把SD卡分区理顺！也烧录进去了，uboot正常运行,kernel也能正常加载，只是最后的rootfs文件系统失败，后续再想想办法，应该是自己编译出了问题，别人的rootfs是能正常读取进入! –20250917</p><h1 id="一、开发环境搭建"><a href="#一、开发环境搭建" class="headerlink" title="一、开发环境搭建"></a>一、开发环境搭建</h1><ul><li><strong>注：因为一直在使用ESP-IDF的开发环境，因此在这基础上添加的话很多基础开发程序都可以通用</strong></li></ul><h2 id="0-准备工作"><a href="#0-准备工作" class="headerlink" title="0.准备工作"></a>0.准备工作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#安装vim:</span></span><br><span class="line">sudo apt-get install vim</span><br><span class="line"><span class="comment">#安装git工具</span></span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="1-交叉编译工具链安装（这是F1C200S使用）"><a href="#1-交叉编译工具链安装（这是F1C200S使用）" class="headerlink" title="1.交叉编译工具链安装（这是F1C200S使用）"></a>1.交叉编译工具链安装（这是F1C200S使用）</h2><ul><li><strong>注：芯片和架构不同都所使用的工具链也不同</strong></li></ul><p>对于F1C200S，使用的交叉工具链必须高于，使用的交叉工具链必须高于6.0。<br>本文选择7.2.1进行u-boot和kernel的编译。<br><a href="https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz">官网下载链接</a><br>下载后解压</p><ul><li><strong>注：可以使用wget命令直接下载,如果太慢的话使用迅雷会快些</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><p>或右键提取</p><p>在&#x2F;usr&#x2F;local目录下新建arm-linux-gcc目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/arm-linux-gcc</span><br></pre></td></tr></table></figure><p>进入解压目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi/</span><br></pre></td></tr></table></figure><p>将该目录下 的所有文件复制到新建的目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rd * /usr/<span class="built_in">local</span>/arm-linux-gcc/</span><br></pre></td></tr></table></figure><p>最后需要添加该工具链的环境变量使其可以在任何目录下执行，打开&#x2F;etc&#x2F;profile文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件末尾 添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/arm-linux-gcc/bin</span><br></pre></td></tr></table></figure><p>添加完毕，使路径生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><ul><li><strong>注：主要是将工具链添加到环境变量中,因为自己为多环境，所以改成了alist别名方式，通过不同shell设置不同环境</strong></li></ul><img src="/posts/undefined/342d5cb93f856d88c4e085d3106c497c.png" class="" title="在这里插入图片描述"><p>验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc -v</span><br></pre></td></tr></table></figure><img src="/posts/undefined/image-20250917202251839.png" class="" title="image-20250917202251839"><p>安装32位动态链接库<br>为了后续移植Linux系统中出现库缺失问题，这里可以一次系统中出现库缺失问题，这里可以一次性将可能需要的库全部安装，执行如下命令即。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev libc6-dev lib32ncurses5-dev gcc-multilib x11proto-core-dev libx11-dev lib32z1-dev libgl1-mesa-dev g++-multilib tofrodos python-markdown libxml2-utils libssl-dev swig python-dev</span><br></pre></td></tr></table></figure><ul><li><strong>注：这里还是根据编译报错的时候再添加，最后发现添加 swig和libxx类即可，其他的软件其实已经都有了，还有python需要使用Python2，3版本会报错，因此，需切换指向python–&gt;python2.7</strong></li></ul><h2 id="2-u-boot移植"><a href="#2-u-boot移植" class="headerlink" title="2. u-boot移植"></a>2. u-boot移植</h2><ul><li><strong>注：后续可以使用其他uboot看看,根据这个步骤下去编译出来的uboot可以运行</strong></li></ul><p>这里采用licheePI nano的u-boot来进行移植。在终端输入如下命令克隆u-boot：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Lichee-Pi/u-boot.git -b nano-v2018.01</span><br></pre></td></tr></table></figure><p><strong>注：如果太慢的话使用gitee也可以 <a href="https://gitee.com/scotthsl/u-boot-licheepi/tree/nano-v2018.01/">u-boot-licheepi</a></strong></p><p>克隆完毕文件会保存在当前目录 下，进入该目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> u-boot</span><br></pre></td></tr></table></figure><p>在该文件夹下有很多分支，我们可以查看所使用如命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>现在我们使用的是nano开发板，所以将当前分支切换到nano分支，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01</span><br></pre></td></tr></table></figure><p>或者直接下载切换到分支下载zip</p><p>u-boot默认的没有指定交叉工具链和架构，因此在编译之前需要芯片默认的没有指定交叉工具链和架构，因此在编译之前需要芯片u-boot的交叉编译器在u-boot的根目录下中Makefile文件中定义了。打开文件中定义了。打开Makefile文件。<br>将# set default to nothing for native builds下面改为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm</span><br><span class="line">CROSS_COMPILE=arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><img src="/posts/undefined/image-20250917203246574.png" class="" title="image-20250917203246574"><p>config文件夹中有<br>licheepi_nano_defconfig和licheepi_nano_spiflash_defconfig配置文件<br>前者表示为，前者表示为TF卡启动，后者表卡启动，后者表示从SPI设备启动，这里使用前者。<br>下一步:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><img src="/posts/undefined/e3dbb44b88b361c64b5301fed73d7b3f.png" class="" title="在这里插入图片描述"><p>配置完成后就可以进入图形界面行了，执make menuconfig命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>更改bootcmd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;</span><br><span class="line">load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;</span><br><span class="line">bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><img src="/posts/undefined/7dd9059ff7add536c75312e56f406b50.png" class="" title="在这里插入图片描述"><img src="/posts/undefined/5920cefdd09c15be7f5f929f43b1a1da.png" class="" title="在这里插入图片描述"><img src="/posts/undefined/a0532dcd66ab627fd046b1d758adafee.png" class="" title="在这里插入图片描述"><p>传参bootarg<br>Y 选中 Enable boot arguments</p><img src="/posts/undefined/b567aea382ae427efb7ca3735064e97e.png" class="" title="在这里插入图片描述"><p>下面一行Enter输入参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p><strong>注：这里这样写的时候在boot中是读取不到SD02分区,因为是ext4格式,可以在boot环境中改成如下也行</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改bootargs（在U-Boot命令行执行）</span></span><br><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 root=/dev/mmcblk0p2 rootfstype=ext4 rw init=/sbin/init rootwait&quot;</span></span><br><span class="line">boot  <span class="comment"># 重新启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行启动命令（根据实际引导方式，如从SD卡启动内核）</span></span><br><span class="line">bootz 0x80008000 - 0x80000000  <span class="comment"># 0x80008000为内核地址，0x80000000为设备树地址（F1C100s可能无需设备树）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 bootargs，添加 rootdelay=5（等待 5 秒再挂载根分区）</span></span><br><span class="line">setenv bootargs <span class="string">&quot;console=ttyS0,115200 panic=5 rootwait rootdelay=5 root=/dev/mmcblk0p2 rootfstype=ext4 earlyprintk rw&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存并启动</span></span><br><span class="line">saveenv</span><br><span class="line">run bootcmd</span><br></pre></td></tr></table></figure><p>编译u-boot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j2</span><br></pre></td></tr></table></figure><p>编译生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><h3 id="编译uboot的时候报错-No-module-named-libfdt"><a href="#编译uboot的时候报错-No-module-named-libfdt" class="headerlink" title="编译uboot的时候报错 No module named _libfdt"></a>编译uboot的时候报错 No module named _libfdt</h3><p><strong>解决：</strong><br>默认python版本切换成python2，参考：<a href="https://blog.csdn.net/p1279030826/article/details/112699149">Linux下切换python版本（python2和python3版本切换）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//删除当前默认版本</span><br><span class="line">sudo rm /usr/bin/python</span><br><span class="line"></span><br><span class="line">//切换到 python2</span><br><span class="line">sudo ln -s /usr/bin/python2 /usr/bin/python</span><br></pre></td></tr></table></figure><h2 id="3-kernel-移植"><a href="#3-kernel-移植" class="headerlink" title="3. kernel 移植"></a>3. kernel 移植</h2><p><strong>注：wget太慢的话可以先使用迅雷下载,特别是linux-4.15.18.tar.xz文件跑了好久都没下好</strong></p><ul><li>编译后报错<strong>configure: error: you should not run configure as root</strong></li></ul><p> 具体日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checking whether mknod can create fifo without root privileges... configure: error: in `/home/docker/openwrt/build_dir/host/tar-1.34&#x27;:</span><br><span class="line">configure: error: you should not run configure as root (set FORCE_UNSAFE_CONFIGURE=1 in environment to bypass this check)</span><br><span class="line">See `config.log&#x27; for more details</span><br></pre></td></tr></table></figure><p><strong>在错误提示中也有说明了</strong><br>解决方案：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FORCE_UNSAFE_CONFIGURE=1</span><br></pre></td></tr></table></figure><hr><p>下载<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz">kernel</a><br>修改主目录Makefile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH    ?=arm</span><br><span class="line">CROSS_COMPILE   ?=arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><img src="/posts/undefined/f8bbe4b60a2e23bb5e4934080301801a.png" class="" title="在这里插入图片描述"><hr><p><strong>注：这里根据这个方法也能编译得出文件，但运行后发现没有加载SD卡MMC模式，后来就找其他方法手动修改添加了</strong></p><p>arch&#x2F;arm&#x2F;boot&#x2F;dts</p><p>目录下，分别修改suniv-f1c100s.dtsi、suniv-f1c100s-licheepi-nano.dts 两个文件</p><p>适配TF卡</p><p>修改<strong>suniv-f1c100s.dtsi</strong>文件</p><p>首先添加头文件(如果有则忽略)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings/clock/suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings/reset/suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>在soc-&gt;pio 下添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins = &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function = &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>soc下添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible = &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg = &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks = &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names = &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets = &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names = &quot;ahb&quot;;</span><br><span class="line">            interrupts = &lt;23&gt;;</span><br><span class="line">            pinctrl-names = &quot;default&quot;;</span><br><span class="line">            pinctrl-0 = &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status = &quot;disabled&quot;;</span><br><span class="line">            #address-cells = &lt;1&gt;;</span><br><span class="line">            #size-cells = &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>修改<strong>suniv-f1c100s-licheepi-nano.dts</strong>文件，在根节点添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible = &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name = &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>外部添加mmc0使能代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply = &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width = &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>下载licheepi_nano的配置文件<br><a href="http://dl.sipeed.com/LICHEE/Nano/SDK/config">linux-licheepi_nano_defconfig文件</a></p><p>然后将其放到arch&#x2F;arm&#x2F;configs&#x2F;目录下</p><img src="/posts/undefined/7e414ff4be65747352d2aa29e4d7c695.png" class="" title="在这里插入图片描述"><p>回到主目录，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make linux-licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j2</span><br></pre></td></tr></table></figure><p>编译完毕后在就会生成zImage文件和dtb文件，zImage在arch&#x2F;arm&#x2F;boot目录下，dtb在arch&#x2F;arm&#x2F;boot&#x2F;dts目录下目录下。</p><img src="/posts/undefined/5cba16cc57508df13f56d234568c02bc.png" class="" title="在这里插入图片描述"><h2 id="4-rootfs移植"><a href="#4-rootfs移植" class="headerlink" title="4 rootfs移植"></a>4 rootfs移植</h2><p><strong>注：今天尝试了好多次还是失败，读取ini文件的时候就不行，好像是没有权限，使用别人的rootfs就可以 20250917</strong><br>**注：今天这个问题已经解决 20250918<br>是因为架构体系选择错了 【架构体系，这里选择arm926t，因为F1C200S&#x2F;F1C100S的架构就是这个架构】<br><a href="https://download.csdn.net/blog/column/12158774/128553772">根文件系统–从零开始自制linux掌上电脑（F1C200S)</a><br>**</p><p>安装buildroot2018.2.11版本 <a href="https://buildroot.org/downloads/">https://buildroot.org/downloads/</a></p><img src="/posts/undefined/5a8104b2476b25925769a9b00ffb49d8.png" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>进入Target options</p><img src="/posts/undefined/b54ad346b1dbc7e5f1508224d3f4c938.png" class="" title="在这里插入图片描述"><img src="/posts/undefined/44b6b083129ee3c097b793b043d5ecd8.png" class="" title="在这里插入图片描述"><img src="/posts/undefined/401d353391af4061b616ef4dbb3a6f8a.png" class="" title="在这里插入图片描述"><p>图框中指定了编译时使用的库类型，我们这里选择(both static and shared)选项，即同时使用静态库和动库。剩下的我们使用默认即可，将光标移动到上，然后按Enter保存。<br>保存后，回到上一级配置界面然进入第三个Toolchain选项，配置如图选项，配置如图：<br>黄色框中的选项尽可能勾，因为后面移植QT5的时候需要用到C++相关库，如果这里没有勾选QT5选型将无法勾选。</p><img src="/posts/undefined/d5bd49c4a9aab9054abec378df5b0265.png" class="" title="在这里插入图片描述"><p>第四个 System configuration配置如图：</p><img src="/posts/undefined/0303a5f5eea58d49f044bd3f940ade02.png" class="" title="在这里插入图片描述"><p>更改启动密码。<br>编译完毕后可以在output&#x2F;images目录下找到rootfs.tar。</p><h1 id="一、-格式化TF卡"><a href="#一、-格式化TF卡" class="headerlink" title="一、 格式化TF卡"></a>一、 格式化TF卡</h1><h2 id="1-linux命令行格式化"><a href="#1-linux命令行格式化" class="headerlink" title="1. linux命令行格式化"></a>1. linux命令行格式化</h2><p><strong>注：如果格式化不对可以使用 wipefs 清除磁盘上的文件系统签名、分区表签名等信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsblk<span class="comment"># 确认 SD 卡设备名</span></span><br><span class="line">wipefs /dev/sdb <span class="comment"># 查看 SD 卡上的签名信息</span></span><br><span class="line">sudo wipefs -a /dev/sdb <span class="comment">#清除所有签名和分区表信息</span></span><br><span class="line">sudo wipefs /dev/sdb  <span class="comment"># 无输出则表示已清除</span></span><br><span class="line">lsblk /dev/sdb        <span class="comment"># 无分区信息</span></span><br></pre></td></tr></table></figure><h3 id="1-1-找到U盘位置（已挂载）"><a href="#1-1-找到U盘位置（已挂载）" class="headerlink" title="1.1 找到U盘位置（已挂载）"></a>1.1 找到U盘位置（已挂载）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l</span><br></pre></td></tr></table></figure><p>如图，我的在&#x2F;dev&#x2F;sdb</p><img src="/posts/undefined/cb729f9b95bd8a59930bc105d5ffa3d2.png" class="" title="在这里插入图片描述"><h3 id="1-2-格式化U盘"><a href="#1-2-格式化U盘" class="headerlink" title="1.2 格式化U盘"></a>1.2 格式化U盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo  mkfs  -t  vfat  /dev/sdb</span><br></pre></td></tr></table></figure><p>-t 后面是格式化为哪种文件系统格式，vfat就是fat32格式，最后加U盘位置<br>有时候被占用了无法格式化，需要先卸载u盘，挂载u盘后会在&#x2F;media&#x2F;user 下找到<br>使用umount 卸载</p><p><strong>注：这里经常无法卸载，后边使用ubuntu系统自带的硬盘管理来卸载即可</strong></p><img src="/posts/undefined/5db5c397a863ad7a274ab43aa91a407e.png" class="" title="在这里插入图片描述"><p>2 gparted格式化 删除分区<br>安装 gparted</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><img src="/posts/undefined/487bf6714bd5ac3d2e8d2277f585e344.png" class="" title="在这里插入图片描述"><h1 id="二、-将uboot写入到sd卡到8k偏移处"><a href="#二、-将uboot写入到sd卡到8k偏移处" class="headerlink" title="二、 将uboot写入到sd卡到8k偏移处"></a>二、 将uboot写入到sd卡到8k偏移处</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><img src="/posts/undefined/07a0ca47a8ce520e4d010808f5d97396.png" class="" title="在这里插入图片描述"><h1 id="三、-新建分区"><a href="#三、-新建分区" class="headerlink" title="三、 新建分区"></a>三、 新建分区</h1><h2 id="1-新建BOOT分区，存放linux-kernel"><a href="#1-新建BOOT分区，存放linux-kernel" class="headerlink" title="1 新建BOOT分区，存放linux kernel"></a>1 新建BOOT分区，存放linux kernel</h2><img src="/posts/undefined/d5dee0a52ba46ea07644dd9b114fe8ec.png" class="" title="在这里插入图片描述"><h2 id="2-新建rootfs分区-存放根文件系统"><a href="#2-新建rootfs分区-存放根文件系统" class="headerlink" title="2 新建rootfs分区 存放根文件系统"></a>2 新建rootfs分区 存放根文件系统</h2><img src="/posts/undefined/26fe538b145a5f4c13b2844b0fd292c7.png" class="" title="在这里插入图片描述"><h2 id="3-将下列三个文件拷贝到BOOT分区"><a href="#3-将下列三个文件拷贝到BOOT分区" class="headerlink" title="3 将下列三个文件拷贝到BOOT分区"></a>3 将下列三个文件拷贝到BOOT分区</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 boot.scr  //看了几个教程都没有提及到这个问题 要搞清楚 荔枝派自带</span><br><span class="line"></span><br><span class="line">2 zimage  目录 arch/arm/boot</span><br><span class="line"></span><br><span class="line">3 suniv-f1c100s-licheepi-nano.dtb  目录 arch/arm/boot/dts</span><br><span class="line">//命令</span><br><span class="line">sudo cp boot.scr suniv-f1c100s-licheepi-nano.dtb zImage /media/wd/BOOT -rf</span><br></pre></td></tr></table></figure><img src="/posts/undefined/7f989acd7bb63aee07452c729f2790cc.png" class="" title="在这里插入图片描述"><h2 id="4-将rootfs-tar解压到rootfs"><a href="#4-将rootfs-tar解压到rootfs" class="headerlink" title="4 将rootfs.tar解压到rootfs"></a>4 将rootfs.tar解压到rootfs</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tar -xvf rootfs.tar  -C /media/wd/rootfs</span><br></pre></td></tr></table></figure><h2 id="F1C100s-制作-SD-卡启动"><a href="#F1C100s-制作-SD-卡启动" class="headerlink" title="F1C100s 制作 SD 卡启动"></a>F1C100s 制作 SD 卡启动</h2><h3 id="1-SD-卡分区"><a href="#1-SD-卡分区" class="headerlink" title="1. SD 卡分区"></a>1. SD 卡分区</h3><ul><li>SD 卡分为两个分区：<ul><li><strong>第1分区：FAT32 格式</strong>，用于放置内核镜像、设备树文件和启动脚本（如 <code>boot.scr</code>）。</li><li><strong>第2分区：ext4 格式</strong>，用于放置根文件系统（rootfs）。</li></ul></li></ul><p>示例分区表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;dev&#x2F;mmcblk0p1 *     2048   18431   16384    8M  c W95 FAT32 (LBA)</span><br><span class="line">&#x2F;dev&#x2F;mmcblk0p2      18432 7774207 7755776  3.7G 83 Linux</span><br></pre></td></tr></table></figure><ul><li>其中第1分区从第2048扇区（约1MB）开始。</li></ul><hr><h3 id="2-U-Boot-写入说明"><a href="#2-U-Boot-写入说明" class="headerlink" title="2. U-Boot 写入说明"></a>2. U-Boot 写入说明</h3><ul><li><p>U-Boot 是裸机启动程序，不能作为普通文件放在 FAT 分区里。</p></li><li><p>正确做法是将 U-Boot 二进制文件（通常为 <code>u-boot-sunxi-with-spl.bin</code>）写入 SD 卡的前 1MB 空间，<strong>通常从 8KB（seek&#x3D;8）处开始写入</strong>。</p></li><li><p>写入命令示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin of=/dev/mmcblk0 bs=1024 seek=8 conv=fsync</span><br></pre></td></tr></table></figure></li><li><p>这样写不会破坏 SD 卡的 MBR 和分区表，也不会影响 FAT&#x2F;ext4 分区。</p></li></ul><hr><h3 id="3-boot-env-与-boot-scr-的关系"><a href="#3-boot-env-与-boot-scr-的关系" class="headerlink" title="3. boot.env 与 boot.scr 的关系"></a>3. boot.env 与 boot.scr 的关系</h3><ul><li><code>boot.env</code> 是一个纯文本格式的 U-Boot 脚本，里面写启动命令。</li><li>U-Boot 不会直接识别 <code>boot.env</code>，必须用 <code>mkimage</code> 工具将其转换成二进制脚本文件 <code>boot.scr</code>。</li></ul><p>转换命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkimage -C none -A arm -T script -d boot.env boot.scr</span><br></pre></td></tr></table></figure><ul><li>生成的 <code>boot.scr</code> 放入 FAT 分区根目录，U-Boot 启动时会自动执行。</li></ul><hr><h3 id="4-F1C100s-启动流程"><a href="#4-F1C100s-启动流程" class="headerlink" title="4. F1C100s 启动流程"></a>4. F1C100s 启动流程</h3><ol><li>设备上电后，硬件首先读取 SD 卡前部的 U-Boot。</li><li>U-Boot 初始化硬件，挂载第1分区（FAT32）。</li><li>U-Boot 加载并执行 <code>boot.scr</code> 脚本。</li><li>脚本加载内核（<code>zImage</code>）和设备树文件（<code>.dtb</code>）。</li><li>启动 Linux 内核，挂载根文件系统（ext4 分区）。</li></ol><hr><h3 id="5-如何写入-U-Boot-不破坏分区"><a href="#5-如何写入-U-Boot-不破坏分区" class="headerlink" title="5. 如何写入 U-Boot 不破坏分区"></a>5. 如何写入 U-Boot 不破坏分区</h3><ul><li>查看分区起始扇区：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo fdisk -l /dev/mmcblk0</span><br><span class="line">AI运行代码bash1</span><br></pre></td></tr></table></figure><ul><li>确认第1分区起始扇区（通常≥2048，代表1MB起始）。</li><li>使用 <code>dd</code> 命令跳过前8KB，写入 U-Boot：</li></ul><h1 id="四、应用编译"><a href="#四、应用编译" class="headerlink" title="四、应用编译"></a>四、应用编译</h1><p>驱动开发过程中有时候需要编写简单的应用测试程序，由于编译根文件用的buildroot，所以在编译应用程序也用同样的交叉工具链。<br>进入buildroot主目录，进入output&#x2F;host&#x2F;，<br>在 usr&#x2F;local 目录下新建一个 arm-gcc-app 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/<span class="built_in">local</span>/arm-gcc-app</span><br></pre></td></tr></table></figure><p>然后将 output&#x2F;host&#x2F;目录下的文件全部拷贝到&#x2F;usr&#x2F;local&#x2F;arm-gcc-app&#x2F;目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -a ./* /usr/<span class="built_in">local</span>/arm-gcc-app/</span><br></pre></td></tr></table></figure><p>接下来我们添加环境变量，打开&#x2F;etc&#x2F;profile 文件，在末尾添加路径：</p><img src="/posts/undefined/7cec3d34ee34046291cd8c6214bcebb7.png" class="" title="在这里插入图片描述"><p>注意: 加export是环境变量，在&#x2F;etc&#x2F;profile加载后别处可以引用。不加就是普通变量了，只能文件内用。<br>验证：在终端中输入 arm-linux-，然后双击 Tab 按键，此时会出<br>现如下内容：</p><img src="/posts/undefined/8b9eebc87ee8441e13ca79e2461437d1.png" class="" title="在这里插入图片描述"><h1 id="五、工具安装"><a href="#五、工具安装" class="headerlink" title="五、工具安装"></a>五、工具安装</h1><h2 id="1-串口传输工具Lrzsz"><a href="#1-串口传输工具Lrzsz" class="headerlink" title="1.串口传输工具Lrzsz"></a>1.串口传输工具Lrzsz</h2><p>感谢万能的坑友,我搜索了一下，buildroot中确实有这个功能，不需要下载；,找到了它位于这个目录中:<br>Target packages —&gt;<br>Networking applications —&gt;<br>[v] lrzsz<br>勾选之后，编译，根文件系统中就有这个工具了。</p><img src="/posts/undefined/001bdb662d851b783a772aa0e6b73d6b.png" class="" title="在这里插入图片描述"><h1 id="六、问题记录"><a href="#六、问题记录" class="headerlink" title="六、问题记录"></a>六、问题记录</h1><h2 id="第一次进入linux，命令号只显示-号"><a href="#第一次进入linux，命令号只显示-号" class="headerlink" title="第一次进入linux，命令号只显示#号"></a>第一次进入linux，命令号只显示#号</h2><p>解决 修改&#x2F;etc&#x2F;profile </p><p>在末尾处 输入 重启板子即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;[\u\@\h: \w\a]$&#x27;</span></span><br></pre></td></tr></table></figure><img src="/posts/undefined/e40a530989e48645819f7fbfc1225767.png" class="" title="在这里插入图片描述"><h2 id="慎用空格、TAB"><a href="#慎用空格、TAB" class="headerlink" title="慎用空格、TAB"></a>慎用空格、TAB</h2><p>在编写一个Makefile工具时，出现Makefile:7: *** missing separator (did you mean TAB instead of 8 spaces?). Stop.这个问题，<br>将空格用TAB键代替<br>用vim编辑makefile 错误的会现红色</p><img src="/posts/undefined/3160c8c1245b5254252eb61dd23c7e25.png" class="" title="在这里插入图片描述"><h2 id="VIM非正常退出"><a href="#VIM非正常退出" class="headerlink" title="VIM非正常退出"></a>VIM非正常退出</h2><p>参考链接：<a href="https://blog.csdn.net/sunsi_10/article/details/78232207">https://blog.csdn.net/sunsi_10/article/details/78232207</a><br>交换文件 “~&#x2F;.add.py.swp” 已存在! 以只读方式打开([O]), 直接编辑((E)), 恢复(®), 删除交换文件((D)), 退出((Q)),中止((A)):</p><p>产生原因：文件的非正常关闭。</p><p>解决办法：删除add.py.swp文件，该文件是隐藏文件所以使用la查看，使用语句rm -r add.py.swp删除该文件，再次打开文件不会产生该问题。</p><h2 id="快捷方式目录"><a href="#快捷方式目录" class="headerlink" title="快捷方式目录"></a>快捷方式目录</h2><p>进入 &#x2F;usr&#x2F;share&#x2F;applicatoions，找到所需的软件的快捷方式，拷贝到桌面就可以了。</p><p>参考：<a href="https://blog.csdn.net/weixin_45881223/article/details/126145992">https://blog.csdn.net/weixin_45881223/article/details/126145992</a></p><hr><p>其他方法</p><h1 id="全志f1c100s系统部署TF卡指导-linux5版本"><a href="#全志f1c100s系统部署TF卡指导-linux5版本" class="headerlink" title="全志f1c100s系统部署TF卡指导_linux5版本"></a>全志f1c100s系统部署TF卡指导_linux5版本</h1><h2 id="1、安装交叉编译链和Lib"><a href="#1、安装交叉编译链和Lib" class="headerlink" title="1、安装交叉编译链和Lib"></a>1、安装<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%93%BE&zhida_source=entity">交叉编译链</a>和<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=Lib&zhida_source=entity">Lib</a></h2><p>此交叉链接只能编译<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=uboot&zhida_source=entity">uboot</a>、linux内核、<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=rootfs&zhida_source=entity">rootfs</a>。编译具体程序的时候需要使用rootfs中的交叉编译链。</p><h3 id="1-1、下载交叉编译链"><a href="#1-1、下载交叉编译链" class="headerlink" title="1.1、下载交叉编译链"></a>1.1、下载交叉编译链</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">下载</span><br><span class="line">wget http://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br><span class="line">解压</span><br><span class="line">tar -vxJf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br><span class="line">复制</span><br><span class="line">sudo cp -r ./gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi /opt/</span><br><span class="line">设置全局</span><br><span class="line">sudo gedit /etc/bash.bashrc</span><br><span class="line"># 在文件末尾 添加以下内容</span><br><span class="line">PATH=&quot;$PATH:/opt/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi/bin&quot;</span><br><span class="line"># 添加完毕</span><br><span class="line"># 使路径生效</span><br><span class="line">source /etc/bash.bashrc</span><br><span class="line">此时可用 arm-linux-gnueabi-gcc -v 进行测试</span><br></pre></td></tr></table></figure><h3 id="1-2、安装一些lib"><a href="#1-2、安装一些lib" class="headerlink" title="1.2、安装一些lib"></a>1.2、安装一些lib</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install python</span><br><span class="line">sudo apt-get install swig</span><br><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo apt-get install libusb-1.0-0-dev</span><br><span class="line">sudo apt-get install zlib1g-dev libssl-dev</span><br><span class="line">sudo apt install libssl-dev</span><br><span class="line">sudo apt-get install flex</span><br><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install automake</span><br><span class="line">sudo apt-get install texinfo</span><br><span class="line">sudo apt install pkg-config</span><br><span class="line">sudo apt install pkgconf</span><br><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure><h2 id="2、编译uboot"><a href="#2、编译uboot" class="headerlink" title="2、编译uboot"></a>2、编译uboot</h2><h3 id="2-1、克隆uboot版本"><a href="#2-1、克隆uboot版本" class="headerlink" title="2.1、克隆uboot版本"></a>2.1、克隆uboot版本</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Lichee-Pi/u-boot.git</span><br><span class="line">cd u-boot</span><br><span class="line"># 查看分支</span><br><span class="line">git branch -a</span><br><span class="line"># 切换到 Nano 分支</span><br><span class="line">git checkout -f nano-v2018.01</span><br></pre></td></tr></table></figure><h3 id="2-2、选择TF或者SPI版本"><a href="#2-2、选择TF或者SPI版本" class="headerlink" title="2.2、选择TF或者SPI版本"></a>2.2、选择TF或者SPI版本</h3><p><a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=MenuConfig&zhida_source=entity">MenuConfig</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 进行可视化配置，我没有配置，直接按默认就行了</span><br><span class="line">make ARCH=arm menuconfig</span><br></pre></td></tr></table></figure><p>TF版本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此处告知make采用arm-linux-gnueabi下的所有交叉编译工具，目标架构为Arm</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>SPI版本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此处告知make采用arm-linux-gnueabi下的所有交叉编译工具，目标架构为Arm</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- licheepi_nano_spiflash_defconfig</span><br></pre></td></tr></table></figure><h3 id="2-3、开始编译"><a href="#2-3、开始编译" class="headerlink" title="2.3、开始编译"></a>2.3、开始编译</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4</span><br></pre></td></tr></table></figure><p>编译完成后在u-boot目录下找到u-boot-sunxi-with-spl.bin文件即为可烧录的文件</p><h3 id="2-4、烧录uboot"><a href="#2-4、烧录uboot" class="headerlink" title="2.4、烧录uboot"></a>2.4、烧录uboot</h3><p>因为没有原生的ubuntu系统，所以只能在windows下烧录，下载如下工具：</p><p>短接<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=spi+flash&zhida_source=entity">spi flash</a>的1和4脚，然后不要插TF卡，上电后f1c100s自动进入了烧录模式，测试可以烧录uboot</p><h3 id="2-5、uboot适配屏幕"><a href="#2-5、uboot适配屏幕" class="headerlink" title="2.5、uboot适配屏幕"></a>2.5、uboot适配屏幕</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">进入uboot配置界面</span><br><span class="line">make ARCH=arm menuconfig    </span><br><span class="line"></span><br><span class="line">选择arm-architecture</span><br><span class="line">使能Enable graphical uboot console on HDMI, LCD or VGA</span><br><span class="line"></span><br><span class="line">LCD panel timing details输入详细参数 对于800x480的屏幕</span><br><span class="line"></span><br><span class="line">x:480,y:272,depth:18,pclk_khz:10000,le:42,ri:8,up:11,lo:4,hs:1,vs:1,sync:3,vmode:0</span><br><span class="line"></span><br><span class="line">x:800,y:480,depth:18,pclk_khz:33000,le:87,ri:40,up:31,lo:13,hs:1,vs:1,sync:3,vmode:0</span><br><span class="line">编译</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4</span><br></pre></td></tr></table></figure><h3 id="2-6、uboot的启动脚本"><a href="#2-6、uboot的启动脚本" class="headerlink" title="2.6、uboot的启动脚本"></a>2.6、uboot的启动脚本</h3><p>建立文件 boot.cmd</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">load mmc 0:1 0x80008000 zImage</span><br><span class="line">bootz 0x80008000 - 0x80C00000</span><br></pre></td></tr></table></figure><p>使用u-boot源码，在其下的tools目录中有一个mkimage工具生成boot.scr</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./mkimage -C none -A arm -T script -d ../../boot.cmd ../../boot.scr</span><br></pre></td></tr></table></figure><p>得到的boot.scr需要放到分区的第一个分区文件</p><h2 id="3、分区TF卡"><a href="#3、分区TF卡" class="headerlink" title="3、分区TF卡"></a>3、分区TF卡</h2><h3 id="3-1、将TF卡分两个区"><a href="#3-1、将TF卡分两个区" class="headerlink" title="3.1、将TF卡分两个区"></a>3.1、将TF卡分两个区</h3><p>分区1用于存放系统启动和内核相关文件，格式化为FAT，一般只需要分配32MiB空间</p><ul><li>boot.scr (指引u-boot加载内核的文件)</li><li>zImage (系统内核)</li><li>suniv-f1c100s-licheepi-nano.dtb (<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=%E8%AE%BE%E5%A4%87%E6%A0%91%E6%96%87%E4%BB%B6&zhida_source=entity">设备树文件</a>)</li></ul><p>分区2用于存放根文件系统，格式化为ext4格式，分配所有剩余的空间</p><h3 id="3-2、分区工具GParted"><a href="#3-2、分区工具GParted" class="headerlink" title="3.2、分区工具GParted"></a>3.2、分区工具GParted</h3><p>直接安装即可，为图形工具</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>插入TF卡，进行分区</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前面可以预留2MB空间</span><br><span class="line">第一分区格式化为FAT16模式，空间设计为32MB即可。 label为 boot</span><br><span class="line">第二分区格式化为EXT4模式，剩下的所有空间，或自己设定。   label为 rootfs</span><br></pre></td></tr></table></figure><p>分区好之后rootfs会提示错误，使用如下指令进行修复</p><p>新的操作系统上使用系统自带的 mkfs.ext4 对文件系统进行了格式化，默认会使用一些新的的特性，这些新的特性在旧的系统上是无法使用的，即在旧的内核上不支持。这个是不支持 <code>has_journal</code> 特性</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 查看文件系统特性</span><br><span class="line">sudo tune2fs -l /dev/sdb2</span><br><span class="line"># 去除has_journal特性</span><br><span class="line">sudo tune2fs -O ^has_journal /dev/sdb2</span><br><span class="line"># 再次查看文件系统特性 has_journal是否删除</span><br><span class="line">sudo tune2fs -l /dev/sdb2</span><br></pre></td></tr></table></figure><p>查看分区结果</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo parted -l</span><br></pre></td></tr></table></figure><h3 id="3-3、放入文件"><a href="#3-3、放入文件" class="headerlink" title="3.3、放入文件"></a>3.3、放入文件</h3><p>第一分区放入uboot启动的脚本</p><p>第一分区放入linux的内核 zimage</p><p>第一分区放入dtb文件</p><p>第二分区放入rootfs</p><h2 id="4、编译Linux内核"><a href="#4、编译Linux内核" class="headerlink" title="4、编译Linux内核"></a>4、编译<a href="https://zhida.zhihu.com/search?content_id=217280288&content_type=Article&match_order=1&q=Linux%E5%86%85%E6%A0%B8&zhida_source=entity">Linux内核</a></h2><h3 id="4-1、获得linux-5-7-1内核。"><a href="#4-1、获得linux-5-7-1内核。" class="headerlink" title="4.1、获得linux-5.7.1内核。"></a>4.1、获得linux-5.7.1内核。</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">进入网站下载对应内核</span><br><span class="line">https://cdn.kernel.org/pub/linux/kernel/v5.x/</span><br><span class="line">或直接下载</span><br><span class="line">https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz</span><br><span class="line">解压后获得内核</span><br></pre></td></tr></table></figure><h3 id="4-2、获得f1c100s的项目配置文件"><a href="#4-2、获得f1c100s的项目配置文件" class="headerlink" title="4.2、获得f1c100s的项目配置文件"></a>4.2、获得f1c100s的项目配置文件</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">linux-licheepi_nano_defconfig</span><br><span class="line">然后将该文件放入到 arch/arm/configs/</span><br><span class="line">然后回到linux的根目录执行如下指令来配置项目</span><br><span class="line">mv arch/arm/configs/linux-licheepi_nano_defconfig ./config</span><br></pre></td></tr></table></figure><h3 id="4-3、使用MenuConfig"><a href="#4-3、使用MenuConfig" class="headerlink" title="4.3、使用MenuConfig"></a>4.3、使用MenuConfig</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm menuconfig</span><br><span class="line">保存即可</span><br></pre></td></tr></table></figure><h3 id="4-4、编译试试？"><a href="#4-4、编译试试？" class="headerlink" title="4.4、编译试试？"></a>4.4、编译试试？</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- -j4</span><br></pre></td></tr></table></figure><h2 id="5、适配我们的开发板"><a href="#5、适配我们的开发板" class="headerlink" title="5、适配我们的开发板"></a>5、适配我们的开发板</h2><p><strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong></p><p>目录下，分别修改<strong>suniv-f1c100s.dtsi</strong>、<strong>suniv-f1c100s-licheepi-nano.dts</strong> 两个文件。</p><p>这两个文件很重要。</p><h3 id="5-1、适配TF卡"><a href="#5-1、适配TF卡" class="headerlink" title="5.1、适配TF卡"></a>5.1、适配TF卡</h3><p>修改<strong>suniv-f1c100s.dtsi</strong>文件</p><p>首先添加头文件(如果有则忽略)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings/clock/suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings/reset/suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>在soc-&gt;pio 下添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins = &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function = &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>soc下添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible = &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg = &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks = &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names = &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets = &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names = &quot;ahb&quot;;</span><br><span class="line">            interrupts = &lt;23&gt;;</span><br><span class="line">            pinctrl-names = &quot;default&quot;;</span><br><span class="line">            pinctrl-0 = &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status = &quot;disabled&quot;;</span><br><span class="line">            #address-cells = &lt;1&gt;;</span><br><span class="line">            #size-cells = &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>修改<strong>suniv-f1c100s-licheepi-nano.dts</strong>文件，在根节点添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible = &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name = &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt = &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt = &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>外部添加mmc0使能代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply = &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width = &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-2、适配音频"><a href="#5-2、适配音频" class="headerlink" title="5.2、适配音频"></a>5.2、适配音频</h3><p>获得 Linux-5.7_音频补丁测试通过.zip 文件，解压后和linux内核代码进行比较，并将补丁放进去。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/drivers/clk/sunxi-ng/ccu-suniv-f1c100s.c</span><br><span class="line">这个文件整体覆盖</span><br><span class="line"></span><br><span class="line">/drivers/dma/Kconfig</span><br><span class="line">修改如下部分:</span><br><span class="line">    depends on MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNIV</span><br><span class="line">    default (MACH_SUN4I || MACH_SUN5I || MACH_SUN7I || MACH_SUNIV)</span><br><span class="line"></span><br><span class="line">/drivers/dma/sun4i-dma.c</span><br><span class="line">这个文件整体覆盖</span><br><span class="line"></span><br><span class="line">/include/dt-bindings/clock/suniv-ccu-f1c100s.h</span><br><span class="line">这个文件整体覆盖</span><br><span class="line"></span><br><span class="line">/sound/soc/sunxi/sun4i-codec.c</span><br><span class="line">这个文件整体覆盖</span><br></pre></td></tr></table></figure><p>修改suniv-f1c100s.dtsi设备树文件</p><p>首先添加sun41-a10.h引用。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings/dma/sun4i-a10.h&gt; //添加头文件</span><br></pre></td></tr></table></figure><p>然后在soc节点下，添加如下代码</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dma: dma-controller@1c02000 &#123;</span><br><span class="line">    compatible = &quot;allwinner,suniv-f1c100s-dma&quot;;</span><br><span class="line">    reg = &lt;0x01c02000 0x1000&gt;;</span><br><span class="line">    interrupts = &lt;18&gt;;</span><br><span class="line">    clocks = &lt;&amp;ccu CLK_BUS_DMA&gt;;</span><br><span class="line">    resets = &lt;&amp;ccu RST_BUS_DMA&gt;;</span><br><span class="line">    #dma-cells = &lt;2&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">codec: codec@1c23c00 &#123;</span><br><span class="line">    compatible = &quot;allwinner,suniv-f1c100s-codec&quot;;</span><br><span class="line">    reg = &lt;0x01c23c00 0x400&gt;;</span><br><span class="line">    interrupts = &lt;21&gt;;</span><br><span class="line">    clocks = &lt;&amp;ccu CLK_BUS_CODEC&gt;,</span><br><span class="line">         &lt;&amp;ccu CLK_CODEC&gt;;</span><br><span class="line">    clock-names = &quot;apb&quot;, &quot;codec&quot;;</span><br><span class="line">    resets = &lt;&amp;ccu RST_BUS_CODEC&gt;;</span><br><span class="line">    dmas = &lt;&amp;dma SUN4I_DMA_NORMAL 0x0c&gt;, </span><br><span class="line">         &lt;&amp;dma SUN4I_DMA_NORMAL 0x0c&gt;;</span><br><span class="line">    dma-names = &quot;rx&quot;, &quot;tx&quot;;</span><br><span class="line">    status = &quot;disabled&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改suniv-f1c100s-licheepi-nano.dts设备树，使解码方式工作</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;codec &#123;</span><br><span class="line">    allwinner,audio-routing =</span><br><span class="line">    &quot;Headphone&quot;, &quot;HP&quot;,</span><br><span class="line">    &quot;Headphone&quot;, &quot;HPCOM&quot;,</span><br><span class="line">    &quot;MIC&quot;, &quot;Mic&quot;;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>配置MenuConfig</p><p>配置codec</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers</span><br><span class="line">     &lt;*&gt; Sound card support </span><br><span class="line">         &lt;*&gt; Advanced Linux Sound Architecture </span><br><span class="line">             &lt;*&gt; ALSA for SoC audio support </span><br><span class="line">                 -&gt; Allwinner SoC Audio support 使能</span><br></pre></td></tr></table></figure><p>配置dma</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers </span><br><span class="line">   &lt;*&gt; DMA Engine support</span><br></pre></td></tr></table></figure><p>完成</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_33552551/article/details/123172018">（主要参考）linux(全志F1C100S&#x2F;F1C200S)系列01：初始环境搭建</a></li><li><a href="https://www.cnblogs.com/adam-ma/p/17867881.html">OpenWrt编译报错——configure: error: you should not run configure as root</a></li><li><a href="https://blog.csdn.net/p1279030826/article/details/112890400">【问题解决】报错：ImportError: No module named _libfdt</a></li><li><a href="https://zhuanlan.zhihu.com/p/581158946">全志f1c100s系统部署TF卡指导_linux5版本</a></li><li><a href="https://blog.csdn.net/is0815/article/details/148357196">F1C100s 制作 SD 卡启动</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C200S在Linux下一步步环境搭建,保姆级别记录过程</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="uboot" scheme="https://zml3589110.github.io/tags/uboot/"/>
    
    <category term="环境搭建" scheme="https://zml3589110.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="rootfs" scheme="https://zml3589110.github.io/tags/rootfs/"/>
    
  </entry>
  
  <entry>
    <title>裸机开发环境搭建</title>
    <link href="https://zml3589110.github.io/posts/3907184433.html"/>
    <id>https://zml3589110.github.io/posts/3907184433.html</id>
    <published>2025-09-15T13:18:20.000Z</published>
    <updated>2025-09-15T13:23:36.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C100S的裸机开发环境搭建"><a href="#F1C100S的裸机开发环境搭建" class="headerlink" title="F1C100S的裸机开发环境搭建"></a>F1C100S的裸机开发环境搭建</h1><p> 我第一次听说荔枝派是不知道多久之前，在电子发烧友网的众筹板块上(现在貌似没众筹了)，那块简陋但功能强大的板子给我留下了很深刻的印象。之后出了荔枝派Nano，资源和性能都有限，但依然可以跑Linux这样的操作系统，而且价格非常便宜，零售一片三十几块。就算不能上Linux、压榨尽可能多的性能，拿来当单片机开发板用，综合性能也是很拔尖的。</p><img src="/posts/3907184433/37dd32257da34fea3e855303fb63725690f8f857.png@1192w.webp" class="" title="img"><p>但是SoC的生产厂家并没有在官网上给出足够的技术支持，毕竟咱们交不起那么多钱签协议，所以想驾驭荔枝派，要踩的坑非常多，可用的资料资料也少得可怜。虽然有WhyCan的各位大佬完善开发生态，对于我这个喜欢折腾底层的人来说，可用的资料依然不多，只有移植好的u-boot、linux、码云上几个基于keil的模板以及RTT相关底层驱动。</p><p>​    所以，只能见坑填坑，让之后的开发者少踩几个坑。</p><p>​    PS:由于up能力有限，一个多月了才点了个灯，所以相关专栏更新会非常……非常慢……（踩坑过程中的大部分代码会在达到一定完善程度之后开源，小测试之类的代码中有用的部分会整合到主线代码中）</p><img src="/posts/3907184433/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    一位嵌入式大佬，用F1C100S，也就是荔枝派Nano的使用的SoC制作了一张名片</p><img src="/posts/3907184433/36346b7b84a2c28e0719454d40bed35c6f0eba52.jpg@1192w.webp" class="" title="img"><p>大佬的名片</p><p>​    这张名片的资料已经在github开源，国内的码云也有同步仓库(<a href="https://gitee.com/mirrors/business-card-linux)%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%89%BE%E5%88%B0%E8%8A%AF%E7%89%87%E6%89%8B%E5%86%8C">https://gitee.com/mirrors/business-card-linux)，在这个仓库中，可以找到芯片手册</a></p><img src="/posts/3907184433/59ba8d7a25d5187c78039b5fda0f80806a42eadc.jpg@1192w.webp" class="" title="img"><p>F1C100S的数据手册和用户手册</p><p>​    在这一部分中，大佬提供的用户手册是F1C600的，所以暂且认定二者手册通用。</p><p>​    参考代码可以使用码云上基于keil进行F1C100S裸机开发的Demo和移植好的u-boot(linux太复杂，暂不考虑)，比如<a href="https://gitee.com/LicheePiNano/F1C100S_MDK%E8%BF%99%E4%B8%AA%E4%BE%8B%E7%A8%8B">https://gitee.com/LicheePiNano/F1C100S_MDK这个例程</a></p><img src="/posts/3907184433/03fa1838b0a431c9545d45dff1955004c56ed85c.jpg@1192w.webp" class="" title="img"><p>​    要注意的是，这个仓库并没有指定许可证，所以这里默认仓库中的所有代码、文件只能用于学习。不过看TA的用户名，应该也是荔枝派的爱好者，应该不会介意我在这里参考一下TA的代码。</p><p>​    u-boot选择<a href="https://gitee.com/scotthsl/u-boot-licheepi%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%A6%81%E6%9C%89%E7%BA%A2%E5%9C%88%E7%9A%84%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E6%89%8D%E6%98%AF%E7%A7%BB%E6%A4%8D%E5%88%B0F1C100S%E7%9A%84u-boot">https://gitee.com/scotthsl/u-boot-licheepi，注意要有红圈的这个分支，这个分支才是移植到F1C100S的u-boot</a></p><img src="/posts/3907184433/15b193dbea6e65cf04b2868c55b2e8b072af2ec2.jpg@1192w.webp" class="" title="img"><p>要有红圈这个分支</p><p>​    此外，F1C100S在全志(生产厂家)的规划中，属于sunxi生态的一部分，因此要使用sunxi-tools，这个工具在码云上也有从github转存的仓库。在克隆的时候，<strong>一定一定要注意</strong>原始仓库必须是<a href="https://github.com/Icenowy/sunxi-tools.git%EF%BC%8C%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E6%89%8D%E6%9C%89**f1c100s-spiflash%E5%88%86%E6%94%AF**%EF%BC%8C%E5%8F%AA%E6%9C%89%E8%BF%99%E4%B8%AA%E5%88%86%E6%94%AF%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E7%9A%84sunxi-fel%E5%B7%A5%E5%85%B7%E6%89%8D%E8%83%BD%E5%B0%86%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5SPI">https://github.com/Icenowy/sunxi-tools.git，只有这个仓库才有**f1c100s-spiflash分支**，只有这个分支编译生成的sunxi-fel工具才能将可执行文件写入SPI</a> Flash中。码云转存的仓库为<a href="https://gitee.com/dbc0301/sunxi-tools">https://gitee.com/dbc0301/sunxi-tools</a></p><img src="/posts/3907184433/455ca7aa25d317de416cb02508f6a291d2cae35f.jpg@1192w.webp" class="" title="img"><p>一定一定要有红圈中的这个分支</p><p>​    <strong>一定，一定要有红圈中的这个分支！！！</strong></p><p>​    因为是裸机开发，所以交叉工具链可以用前面文章中说到的arm-none-eabi-gcc工具链</p><p>【折腾是最大的乐趣】【gcc-arm】gcc-arm工具链的使用</p><p> 不过是个渣渣 · 1297阅读</p><img src="/posts/3907184433/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    受限于sunxi-tools的f1s100s-spiflash分支只能在Linux下使用，所以开发环境基于Linux搭建，在这里我使用VMWare创建了一个Manjaro虚拟机。</p><img src="/posts/3907184433/9c7848e8800680f17118da1d21ed201774cec7a4.jpg@1192w.webp" class="" title="img"><p>Manjaro的虚拟机环境进行裸机开发</p><p>​    用Manjaro的原因是我觉得它的UI做的比较好，而且自带gcc、git、make，实际上用比较大众Ubuntu也是差不多的，都是软件的执行环境而已。</p><p>​    装好虚拟机之后(包括切换国内源、更新系统、安装中文输入法)，去应用商店装个Code-OSS，其实就是Vscode改了个名字。</p><p>​    接下来，安装arm-none-eabi-gcc工具链，命令为：</p><p>​    sudo pacman -S arm-none-eabi-gcc</p><p>​    在终端中键入arm-none-eabi-gcc，如果提示没有输入文件，就表示安装成功了。</p><img src="/posts/3907184433/a2478034821369e12ef423c3d5b561f8c1f42587.jpg@928w_352h.webp" class="" title="img"><p>测试交叉工具链</p><p>​    之后，依次克隆前面讲到的四个仓库到桌面(或者其他熟悉的位置)，命令为</p><p>​    sudo git clone <a href="https://gitee.com/mirrors/business-card-linux">https://gitee.com/mirrors/business-card-linux</a></p><p>​    sudo git clone <a href="https://gitee.com/LicheePiNano/F1C100S_MDK">https://gitee.com/LicheePiNano/F1C100S_MDK</a></p><p>​    sudo git clone <a href="https://gitee.com/scotthsl/u-boot-licheepi">https://gitee.com/scotthsl/u-boot-licheepi</a> -b nano-v2018.01</p><p>​    sudo git clone <a href="https://gitee.com/dbc0301/sunxi-tools">https://gitee.com/dbc0301/sunxi-tools</a> -b f1c100s-spiflash</p><p>​     这些仓库除了第二个的许可证为unlicensed之外，其他全部为GPL家族许可证，所有文件都可以随意使用。</p><p>​    在克隆sunxi-tools仓库时，需要用-b指定了克隆之后签出的分支。如果忘了加这个参数，克隆完成之后需要执行sudo git checkout f1c100s-spiflash签出f1c100s-spiflash分支。u-boot仓库也是一样的。</p><p>​    </p><img src="/posts/3907184433/8f3d3ff782055a7145fce83b85fa52bb338b2cb5.jpg@1032w_340h.webp" class="" title="img"><p>克隆好的四个仓库</p><p>​    之后，安装sunxi-tools。</p><p>​    在终端中进入sunxi-tools目录，确定当前分支为f1c100s-spiflash，之后运行make编译安装sunxi-tools中的sunxi-fel。</p><p>​    查看分支：sudo git branch -a</p><img src="/posts/3907184433/2c5f5a382e1a2e40223f4df29fd2a1eb51ae74ad.jpg@868w.webp" class="" title="img"><p>当前分支是f1c100s-spiflash</p><p>​    第一行星号开头的内容就是当前分支</p><p>​    安装工具：sudo make sunxi-fel &amp;&amp; sudo make install</p><img src="/posts/3907184433/4d1eeeac47b42086539f78b5019dd004dd4d8978.jpg@1192w.webp" class="" title="img"><p>​    之后会开始sunxi-fel的编译和安装，过程中可能会有警告，但着不影响工具的安装。</p><p>​    安装完成之后，在终端键入sunxi-fel，如果出现这样的一大片提示信息，说明安装正确。</p><img src="/posts/3907184433/dd603052957d127be01daad6cd2494d45d190c4e.jpg@1192w.webp" class="" title="img"><p>​    这里不能加.&#x2F;来运行sunxi-fel，因为.&#x2F;sunxi-fel表示运行当前目录下的sunxi-fel工具，并不能确认sunxi-fel是否已经安装到系统中。</p><img src="/posts/3907184433/4adb9255ada5b97061e610b682b8636764fe50ed.png" class="" title="cut-off"><p>​    最后，测试荔枝派Nano是否能被Manjaro虚拟机识别。</p><p>​    首先，需要让F1C100S进入FEL模式，方法是让SPIFlash的1号脚接地，然后再连接USB口。</p><img src="/posts/3907184433/09b2800931c833d3d90f81d86df6602a79627761.jpg@824w_600h.webp" class="" title="img"><p>就这个引脚，接地</p><p>​    因为Manjaro是虚拟机，所要把荔枝派分配给虚拟机使用。</p><img src="/posts/3907184433/1ee0833fe59b6d172d13f96270e323f987b4b90f.jpg@1192w.webp" class="" title="img"><p>把荔枝派分给虚拟机用</p><p>​    之后，随便打开一个终端，运行sudo sunxi-fel ver</p><img src="/posts/3907184433/475d20e04a4fab220024b16365e0a5643ddb4f1e.jpg@1192w.webp" class="" title="img"><p>使用sunxi-fel检测F1C100S</p><p>​    如果出现了AWUSBFEX soc&#x3D;00001663(F1C100S)这样的信息，就表示sunxi-fel工具能识别到F1C100S。如果出现了错误，多试几次就行了，一般两次中至少有一次能够正确识别。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.bilibili.com/opus/484633866186215065">【荔枝派Nano】F1C100S的裸机开发环境搭建</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机开发环境搭建</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="环境搭建" scheme="https://zml3589110.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266无线下载器</title>
    <link href="https://zml3589110.github.io/posts/3480903282.html"/>
    <id>https://zml3589110.github.io/posts/3480903282.html</id>
    <published>2025-09-15T13:10:20.000Z</published>
    <updated>2025-09-15T13:23:36.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="无线调试器本体"><a href="#无线调试器本体" class="headerlink" title="无线调试器本体"></a>无线调试器本体</h3><img src="/posts/3480903282/1928719-20230811204815791-1954538293.png" class="" title="img"><img src="/posts/3480903282/1928719-20230819143927241-1099753248.jpg" class="" title="img"><h3 id="SWD有源延长线"><a href="#SWD有源延长线" class="headerlink" title="SWD有源延长线"></a>SWD有源延长线</h3><img src="/posts/3480903282/1928719-20230819102248615-1951507612.png" class="" title="image"><img src="/posts/3480903282/1928719-20230819102252006-1381904011.png" class="" title="image"><img src="/posts/3480903282/1928719-20231003103428942-813334790.jpg" class="" title="image"><img src="/posts/3480903282/1928719-20231003103432321-26787789.jpg" class="" title="image"><h3 id="DAPLINK通用协议测试"><a href="#DAPLINK通用协议测试" class="headerlink" title="DAPLINK通用协议测试"></a>DAPLINK通用协议测试</h3><p>测试固件大小: 225340字节，SWD时钟10M，使用KEIL-MDK下载。<br>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时主动延时500us。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>18.72s</td><td>11.755KB&#x2F;s</td></tr><tr><td>2</td><td>19.09s</td><td>11.527KB&#x2F;s</td></tr><tr><td>3</td><td>18.74s</td><td>11.743KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>8.06s</td><td>6.21s</td><td>4.12s</td></tr><tr><td>2</td><td>8.31s</td><td>6.30s</td><td>4.01s</td></tr></tbody></table><p>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时主动延时1ms。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>20.97s</td><td>10.494KB&#x2F;s</td></tr><tr><td>2</td><td>20.95s</td><td>10.504KB&#x2F;s</td></tr><tr><td>3</td><td>20.41s</td><td>10.782KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>9.98s</td><td>6.31s</td><td>4.20s</td></tr><tr><td>2</td><td>9.80s</td><td>6.42s</td><td>4.05s</td></tr></tbody></table><p>测试项：<code>擦除</code>，<code>下载</code>，<code>校验</code>，设备返回DAP_TRANSFER_WAIT时不延时，直接发起下次轮询。</p><table><thead><tr><th>序号</th><th>耗时</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>16.14s</td><td>13.634KB&#x2F;s</td></tr><tr><td>2</td><td>17.74s</td><td>12.405KB&#x2F;s</td></tr><tr><td>3</td><td>16.06</td><td>13.702KB&#x2F;s</td></tr></tbody></table><p>各阶段耗时测试：</p><table><thead><tr><th>序号</th><th>擦除</th><th>下载</th><th>校验</th></tr></thead><tbody><tr><td>1</td><td>6.10s</td><td>6.18 s</td><td>4.03s</td></tr><tr><td>2</td><td>6.0s</td><td>6.08s</td><td>3.98s</td></tr></tbody></table><h3 id="ESPLINK私有协议测试"><a href="#ESPLINK私有协议测试" class="headerlink" title="ESPLINK私有协议测试"></a>ESPLINK私有协议测试</h3><h4 id="程序加载到SRAM"><a href="#程序加载到SRAM" class="headerlink" title="程序加载到SRAM"></a>程序加载到SRAM</h4><p>目标芯片<code>GD32F303RCT6</code><br>当前主频120MHz，Cortex-M4F, RAM&#x3D;48KB, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>。</p><p>测试固件大小: 46984字节，使用ESPLink-GUI客户端下载。<br>GD32F303RC的SRAM为48KB，需要留2KB给栈空间和全局变量，代码段最大能填充46KB。</p><img src="/posts/3480903282/1928719-20231112140519096-182471829.png" class="" title="image"><p><code>Program Size: Code=1068 RO-data=45908 RW-data=8 ZI-data=1024</code></p><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>46984Byte</td><td>172ms</td><td>266.760KB&#x2F;s</td><td>187ms</td><td>245.362KB&#x2F;s</td></tr><tr><td>2</td><td>46984Byte</td><td>172ms</td><td>266.760KB&#x2F;s</td><td>172ms</td><td>266.760KB&#x2F;s</td></tr><tr><td>3</td><td>46984Byte</td><td>188ms</td><td>244.057KB&#x2F;s</td><td>172ms</td><td>266.760KB&#x2F;s</td></tr></tbody></table><img src="/posts/3480903282/1928719-20240724214751223-1047859686.png" class="" title="image"><p>目标芯片<code>GD32F407VET6</code><br>当前主频240MHz，Cortex-M4F, RAM&#x3D;128KB+64K-TCM, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>，由于64KB的TCM内存只能由M4F内核访问，调试器只能访问挂在AHB总线上的128KB SRAM。</p><p>测试文件大小: 131072字节，使用MineLink-GUI客户端下载。</p><img src="/posts/3480903282/1928719-20240525134934149-1700672102.png" class="" title="image"><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>131072Byte</td><td>562ms</td><td>233.2242KB&#x2F;s</td><td>578ms</td><td>226.7682KB&#x2F;s</td></tr><tr><td>2</td><td>131072Byte</td><td>578ms</td><td>226.7682KB&#x2F;s</td><td>641ms</td><td>204.4805KB&#x2F;s</td></tr><tr><td>3</td><td>131072Byte</td><td>546ms</td><td>240.0586KB&#x2F;s</td><td>594ms</td><td>220.6599KB&#x2F;s</td></tr></tbody></table><img src="/posts/3480903282/1928719-20240525135148213-1467896714.png" class="" title="image"><p>目标芯片<code>PY32F002AW15U</code><br>当前主频8MHz，Cortex-M0+, RAM&#x3D;3KB, tar_size&#x3D;1024Byte，SWD时钟<code>5M</code>。</p><p>测试固件大小: 2020字节，使用ESPLink-GUI客户端下载。<br>PY32F002A的SRAM为3KB，需要留1KB给栈空间和全局变量，代码段最大能填充2KB。</p><img src="/posts/3480903282/1928719-20231112144605399-1411535319.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;984 RO-data&#x3D;1032 RW-data&#x3D;4 ZI-data&#x3D;516</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>大小</th><th>写内存</th><th>速度</th><th>回读内存</th><th>速度</th></tr></thead><tbody><tr><td>1</td><td>2020Byte</td><td>12ms</td><td>164.388KB&#x2F;s</td><td>15ms</td><td>131.510KB&#x2F;s</td></tr><tr><td>2</td><td>2020Byte</td><td>15ms</td><td>131.510KB&#x2F;s</td><td>15ms</td><td>131.510KB&#x2F;s</td></tr><tr><td>3</td><td>2020Byte</td><td>16ms</td><td>123.291KB&#x2F;s</td><td>16ms</td><td>123.291KB&#x2F;s</td></tr></tbody></table><img src="/posts/3480903282/1928719-20231210151237487-1899550147.png" class="" title="image"><h4 id="程序烧录到FLASH"><a href="#程序烧录到FLASH" class="headerlink" title="程序烧录到FLASH"></a>程序烧录到FLASH</h4><p>目标芯片<code>GD32F303RCT6</code><br>当前主频120MHz，Cortex-M4F, RAM&#x3D;48KB, tar_size&#x3D;4096Byte，SWD时钟<code>10M</code>。</p><p>测试固件大小: 244872字节，使用ESPLink-GUI客户端下载。</p><img src="/posts/3480903282/1928719-20231210143706734-1340416645.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;1068 RO-data&#x3D;243796 RW-data&#x3D;8 ZI-data&#x3D;1024</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>扇区擦除(ms)</th><th>编程(ms)</th><th>校验(ms)</th><th>编程速度(KB&#x2F;s)</th><th>整体速度(KB&#x2F;s)</th></tr></thead><tbody><tr><td>1</td><td>3120</td><td>3875</td><td>275</td><td>61.71</td><td>32.89</td></tr><tr><td>2</td><td>3140</td><td>3906</td><td>275</td><td>61.22</td><td>32.66</td></tr><tr><td>3</td><td>3165</td><td>3891</td><td>275</td><td>61.45</td><td>32.61</td></tr></tbody></table><img src="/posts/3480903282/1928719-20231210151654571-1719365168.png" class="" title="image"><p>目标芯片<code>PY32F002AW15U</code><br>当前主频8MHz，Cortex-M0+, RAM&#x3D;3KB, tar_size&#x3D;1024Byte，SWD时钟<code>5M</code>。</p><p>测试固件大小: 19372字节，使用ESPLink-GUI客户端下载。</p><img src="/posts/3480903282/1928719-20231210150346444-1573192374.png" class="" title="image"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Program Size: Code&#x3D;984 RO-data&#x3D;18384 RW-data&#x3D;4 ZI-data&#x3D;516</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>扇区擦除(ms)</th><th>编程(ms)</th><th>校验(ms)</th><th>编程速度(KB&#x2F;s)</th><th>整体速度(KB&#x2F;s)</th></tr></thead><tbody><tr><td>1</td><td>20</td><td>390</td><td>50</td><td>48.51</td><td>41.12</td></tr><tr><td>2</td><td>20</td><td>407</td><td>50</td><td>46.81</td><td>39.66</td></tr><tr><td>2</td><td>20</td><td>406</td><td>50</td><td>46.59</td><td>39.73</td></tr></tbody></table><img src="/posts/3480903282/1928719-20231210151218334-902428463.png" class="" title="image"><p>上位机：进行中…</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/17459214.html">ESP8266无线下载器</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP8266无线下载器</summary>
    
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/categories/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/categories/SWD/"/>
    
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/tags/ESP8266/"/>
    
    <category term="STM32" scheme="https://zml3589110.github.io/tags/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/tags/SWD/"/>
    
    <category term="KEIL" scheme="https://zml3589110.github.io/tags/KEIL/"/>
    
    <category term="下载器" scheme="https://zml3589110.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
    <category term="烧录器" scheme="https://zml3589110.github.io/tags/%E7%83%A7%E5%BD%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>读写SD卡</title>
    <link href="https://zml3589110.github.io/posts/2510049814.html"/>
    <id>https://zml3589110.github.io/posts/2510049814.html</id>
    <published>2025-09-15T13:08:20.000Z</published>
    <updated>2025-09-15T13:23:36.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GD32F303"><a href="#GD32F303" class="headerlink" title="GD32F303"></a>GD32F303</h1><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>原版示例代码位于<code>\GD32F30x_Firmware_Library_V2.2.0\Examples\SDIO</code>，对SD卡读写，卡信息获取，切换高速模式等基本功能已经实现了，但是默认实现的传输方式为CPU轮询读写FIFO，速度偏慢；卡上电初始化部分指令未考虑到一些大容量卡首次上电忙时间过长的问题，这里将在原版代码基础上进一步完善。<br>新增内容如下：</p><ul><li>写单块CMD24，写多块CMD25，读单块CMD17，读多块CMD18支持DMA传输</li><li>使用CMSIS-RTOS2的信号量做DMA同步控制</li><li>60MHz的时钟速度(超出控制器支持的48MHz，连续调用写单块(CMD24)时不太稳定)</li><li>在一些操作指令之间增加延时，适配一些山寨TF卡</li></ul><p>代码下载：<br><a href="https://files.cnblogs.com/files/blogs/575121/gd32f30x_sdio.zip">https://files.cnblogs.com/files/blogs/575121/gd32f30x_sdio.zip</a></p><h3 id="SDIO硬件电路"><a href="#SDIO硬件电路" class="headerlink" title="SDIO硬件电路"></a>SDIO硬件电路</h3><p>GD32F303的SDIO功能只有1组管脚可以使用，具体分配如下：</p><table><thead><tr><th>SDIO定义</th><th>GPIO编号</th><th>PIN位置</th><th>备注</th></tr></thead><tbody><tr><td>SDIO_DAT0</td><td>PC8</td><td>39</td><td>数据0, 上拉10K</td></tr><tr><td>SDIO_DAT1</td><td>PC9</td><td>40</td><td>数据1, 上拉10K</td></tr><tr><td>SDIO_DAT2</td><td>PC10</td><td>51</td><td>数据2, 上拉10K</td></tr><tr><td>SDIO_DAT3</td><td>PC11</td><td>52</td><td>数据3, 上拉10K</td></tr><tr><td>SDIO_CLK</td><td>PC12</td><td>53</td><td>时钟, 上拉10K</td></tr><tr><td>SDIO_CMD</td><td>PD2</td><td>54</td><td>命令&#x2F;响应, 上拉10K</td></tr></tbody></table><p>SDIO的DMA通道为DMA1 Channel3。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><ul><li>如果要测试60MHz时钟，在<code>sd_init()</code>中建议开启IO补偿单元。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> reg = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">uint32_t</span> timeout = <span class="number">0xffff</span>u;</span><br><span class="line"><span class="comment">// enable the I/O compensation cell for 60Mbps IO speed</span></span><br><span class="line">gpio_compensation_config(GPIO_COMPENSATION_ENABLE);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">reg = AFIO_CPSCTL;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;<span class="keyword">while</span>(!(reg &amp; AFIO_CPSCTL_CPS_RDY) &amp;&amp; timeout);</span><br><span class="line"><span class="keyword">if</span>(timeout == <span class="number">0</span>) &#123;</span><br><span class="line">init_status = SD_ERROR;</span><br><span class="line"><span class="keyword">return</span> SD_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启用DMA传输时，需要在NVIC控制器中打开DMA的中断。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SDIO_PRIORITY             10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IRQ_SDIO_DMA_PRIORITY         9</span></span><br><span class="line"></span><br><span class="line">nvic_irq_enable(SDIO_IRQn, IRQ_SDIO_PRIORITY, <span class="number">0</span>);</span><br><span class="line">nvic_irq_enable(DMA1_Channel3_Channel4_IRQn, IRQ_SDIO_DMA_PRIORITY, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ul><li>ACMD指令添加重试<br>在<code>sd_power_on()</code>阶段，发送完CMD0(GO_IDLE_STATE)，CMD8(SEND_IF_COND)后切换到CMD55(APP_CMD)时，部分大容量SD卡还处于忙碌状态，导致CMD55的请求未及时回复，SDIO控制器认为返回响应超时(SD_CMD_RESP_TIMEOUT)。这里需要添加重试机制，经过测试大部分卡在1ms的重试间隔下，只需要重试一次即可继续发送ACMD41(SD_SEND_OP_COND)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">retry = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2025-04-01: add ACMD retry for SANDISK 32G Card</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">/* send CMD55(APP_CMD) to indicate next command is application specific command */</span></span><br><span class="line">sdio_command_response_config(SD_CMD_APP_CMD, (<span class="keyword">uint32_t</span>)<span class="number">0x0</span>, SDIO_RESPONSETYPE_SHORT);</span><br><span class="line">sdio_wait_type_set(SDIO_WAITTYPE_NO);</span><br><span class="line">sdio_csm_enable();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check if some error occurs */</span></span><br><span class="line">status = r1_error_check(SD_CMD_APP_CMD);</span><br><span class="line"><span class="keyword">if</span>(SD_OK == status) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">osDelay(<span class="number">1</span>); retry++;</span><br><span class="line">&#125;<span class="keyword">while</span>(retry &lt; <span class="number">10</span>); <span class="comment">// 10ms is enough, maybe...</span></span><br></pre></td></tr></table></figure><ul><li>新增<code>sd_switch_mode()</code>切换高速模式<br>按以下序列发送命令参数，先查询是否支持高速模式，不支持则返回<code>SD_FUNCTION_UNSUPPORTED</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint32_t</span> cmd_array[] = &#123;<span class="number">0x00FFFFF0</span>u, <span class="number">0x80FFFFF0</span>u&#125;;</span><br></pre></td></tr></table></figure><ul><li>修改<code>sd_bus_mode_config()</code>添加参数配置时钟速度</li><li>修改<code>sd_block_read()</code>函数中，readaddr由调用者控制类型，标准容量 SD 存储卡数据地址以字节为单位，高容量 SD 存储卡数据地址以块（512 字节）为单位。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sd_error_enum <span class="title">sd_block_read</span><span class="params">(<span class="keyword">uint32_t</span> *preadbuffer, <span class="keyword">uint32_t</span> readaddr, <span class="keyword">uint16_t</span> blocksize)</span> </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">/* blocksize is fixed in 512B for SDHC card */</span></span><br><span class="line">    <span class="keyword">if</span>(SDIO_HIGH_CAPACITY_SD_CARD == cardtype)&#123;</span><br><span class="line">        blocksize = <span class="number">512</span>;</span><br><span class="line"><span class="comment">// readaddr /= 512;</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写多数据块(CMD25)前添加<code>SD_R1_READY_FOR_DATA</code>的状态位查询</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sd_error_enum <span class="title">sd_multiblocks_write</span><span class="params">(<span class="keyword">uint32_t</span> *pwritebuffer, <span class="keyword">uint32_t</span> writeaddr, <span class="keyword">uint16_t</span> blocksize, <span class="keyword">uint32_t</span> blocksnumber)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">response = sdio_response_get(SDIO_RESPONSE0);</span><br><span class="line">timeout = SDIO_PULL_TIMEOUT;</span><br><span class="line"><span class="keyword">while</span>((<span class="number">0</span> == (response &amp; SD_R1_READY_FOR_DATA)) &amp;&amp; (timeout &gt; <span class="number">0</span>))&#123;</span><br><span class="line"><span class="comment">/* continue to send CMD13 to polling the state of card until buffer empty or timeout */</span></span><br><span class="line">--timeout;</span><br><span class="line"><span class="comment">/* send CMD13(SEND_STATUS), addressed card sends its status registers */</span></span><br><span class="line">sdio_command_response_config(SD_CMD_SEND_STATUS, (<span class="keyword">uint32_t</span>)sd_rca &lt;&lt; SD_RCA_SHIFT, SDIO_RESPONSETYPE_SHORT);</span><br><span class="line">sdio_wait_type_set(SDIO_WAITTYPE_NO);</span><br><span class="line">sdio_csm_enable();</span><br><span class="line"><span class="comment">/* check if some error occurs */</span></span><br><span class="line">status = r1_error_check(SD_CMD_SEND_STATUS);</span><br><span class="line"><span class="keyword">if</span>(SD_OK != status)&#123;</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line">response = sdio_response_get(SDIO_RESPONSE0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> == timeout)&#123;</span><br><span class="line"><span class="keyword">return</span> SD_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>新增DMA中断处理<br>在调用sd_block_read，sd_multiblocks_read，sd_block_write，sd_multiblocks_write时，调用者线程会因为等待信号量而进入阻塞状态，在DMA完成中断中释放信号量，使调用者线程获得继续向下执行的机会。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DMA1_Channel3_4_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> flag = DMA_INTF(DMA1);</span><br><span class="line">    <span class="keyword">if</span>(flag &amp; DMA_FLAG_ADD(DMA_INT_FLAG_FTF, DMA_CH3)) &#123;</span><br><span class="line">        dma_interrupt_flag_clear(DMA1, DMA_CH3, DMA_INT_FLAG_FTF);</span><br><span class="line">        <span class="keyword">if</span>(transerror == SD_OK) &#123;</span><br><span class="line">            osSemaphoreRelease(sem_sdio);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">在SDIO中断中，当传输出错时也需要释放信号量。</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDIO_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// update the &#x27;transerror&#x27; variable</span></span><br><span class="line">    sd_interrupts_process();</span><br><span class="line">    <span class="keyword">if</span>(transerror != SD_OK) &#123;</span><br><span class="line">        osSemaphoreRelease(sem_sdio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>挂载SD卡：实例中使用了FileX文件系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> FX_MEDIA sdio_media;</span><br><span class="line">static rt_align(4) uint8_t filex_cache[FX_MAX_SECTOR_CACHE * 512];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> sd_card_info_struct sd_cardinfo;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span> cardstate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> buswidth = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint16_t</span> busspeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @return -1: card not exist</span></span><br><span class="line"><span class="comment"> *         -2: select card or get status fail</span></span><br><span class="line"><span class="comment"> *         -3: card locked</span></span><br><span class="line"><span class="comment"> *         -4: formated fail</span></span><br><span class="line"><span class="comment"> *         -5: open fail</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mount_filesystem</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    sd_error_enum status = SD_OK;</span><br><span class="line">    <span class="keyword">uint32_t</span> fxstatus;</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count;</span><br><span class="line"></span><br><span class="line">    status = sd_init();</span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status)&#123;</span><br><span class="line">        sd_card_information_get(&amp;sd_cardinfo);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        sd_deinit();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = sd_card_select_deselect(sd_cardinfo.card_rca);</span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status)&#123;</span><br><span class="line">        status = sd_cardstatus_get(&amp;cardstate);</span><br><span class="line">        <span class="keyword">if</span>(cardstate &amp; SD_CARDSTATE_LOCKED)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SD_OK == status) &#123;</span><br><span class="line">        buswidth = <span class="number">1</span>;</span><br><span class="line">        busspeed = <span class="number">24</span>;</span><br><span class="line">        status = sd_switch_mode(SD_SPEED_MODE_HS);</span><br><span class="line">        <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">            status = sd_bus_mode_config(SD_BUSWIDTH_4BIT, SD_CLK_DIV_40MHZ);</span><br><span class="line">            <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">                buswidth = <span class="number">4</span>;</span><br><span class="line">                busspeed = <span class="number">40</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            status = sd_bus_mode_config(SD_BUSWIDTH_4BIT, SD_CLK_DIV_24MHZ);</span><br><span class="line">            <span class="keyword">if</span>(status == SD_OK) &#123;</span><br><span class="line">                buswidth = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fx_system_initialize();</span><br><span class="line">        block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>) * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        fxstatus = fx_media_open(&amp;sdio_media, <span class="literal">NULL</span>, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache));</span><br><span class="line">        <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;error1:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">            fxstatus = fx_media_format(&amp;sdio_media, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache),</span><br><span class="line">                    <span class="string">&quot;FILEX&quot;</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">0</span>, block_count, <span class="number">512</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 16KB/cluster</span></span><br><span class="line">            <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;error2:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-4</span>; <span class="comment">// formated fail</span></span><br><span class="line">            &#125;</span><br><span class="line">            fxstatus = fx_media_open(&amp;sdio_media, <span class="literal">NULL</span>, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache));</span><br><span class="line">            <span class="keyword">if</span>(fxstatus != FX_SUCCESS) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;error3:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-5</span>; <span class="comment">// open fail</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// success</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化卡：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cardformat</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sd_isinit() != SD_OK) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Card NOT INIT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;waiting...\n&quot;</span>);</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>) * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> fxstatus = fx_media_format(&amp;sdio_media, fx_sdcard_driver, <span class="literal">NULL</span>, filex_cache, <span class="keyword">sizeof</span>(filex_cache),</span><br><span class="line">                    <span class="string">&quot;FILEX&quot;</span>, <span class="number">1</span>, <span class="number">64</span>, <span class="number">0</span>, block_count, <span class="number">512</span>, <span class="number">32</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 16KB/cluster</span></span><br><span class="line">    rt_kprintf(<span class="string">&quot;format result:0x%02x\n&quot;</span>, fxstatus);</span><br><span class="line">&#125;</span><br><span class="line">MSH_CMD_EXPORT(cardformat, format tfcard);</span><br></pre></td></tr></table></figure><p>输出SD卡信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cardinfo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> sd_spec, sd_spec3, sd_spec4, sd_security;</span><br><span class="line">    <span class="keyword">uint32_t</span> block_count, block_size;</span><br><span class="line">    <span class="keyword">uint16_t</span> temp_ccc;</span><br><span class="line">    <span class="keyword">uint8_t</span> name[<span class="number">8</span>];</span><br><span class="line">    sd_cid_struct *cid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sd_isinit() != SD_OK) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Card NOT INIT\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Card Information\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cid = &amp;(sd_cardinfo.card_cid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Manufacturer ID: 0x%02x\n&quot;</span>, cid-&gt;mid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;OEM/Application ID: 0x%02x\n&quot;</span>, cid-&gt;oid);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Name: &quot;</span>);</span><br><span class="line">    rt_memcpy(name, (<span class="keyword">void</span> *)&amp;(cid-&gt;pnm0), <span class="number">4</span>);</span><br><span class="line">    rt_memcpy(name + <span class="number">4</span>, (<span class="keyword">void</span> *)&amp;(cid-&gt;pnm1), <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((name[i]&gt;=<span class="number">0x20</span>) &amp;&amp; (name[i]&lt;<span class="number">0x7F</span>)) &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;%c&quot;</span>, name[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Revision: 0x%02x\n&quot;</span>, cid-&gt;prv);</span><br><span class="line">    rt_memcpy(name, (<span class="keyword">void</span> *)&amp;(cid-&gt;psn), <span class="number">4</span>);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Serial number: %02x%02x%02x%02x\n&quot;</span>, name[<span class="number">3</span>], name[<span class="number">2</span>],name[<span class="number">1</span>],name[<span class="number">0</span>]);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Manufacturing date: 0x%x\n&quot;</span>, cid-&gt;mdt);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Version: &quot;</span>);</span><br><span class="line">    sd_spec = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x0F000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    sd_spec3 = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00008000</span>) &gt;&gt; <span class="number">15</span>;</span><br><span class="line">    sd_spec4 = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00000400</span>) &gt;&gt; <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == sd_spec) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1</span> == sd_spec3) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">1</span> == sd_spec4) &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;4.xx\n&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rt_kprintf(<span class="string">&quot;3.0x\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            rt_kprintf(<span class="string">&quot;2.00\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == sd_spec) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;1.10\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == sd_spec) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;1.0x\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Type: &quot;</span>);</span><br><span class="line">    sd_security = (sd_scr[<span class="number">1</span>] &amp; <span class="number">0x00700000</span>) &gt;&gt; <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDSC card\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">3</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDHC card\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">4</span> == sd_security) &#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;SDXC card\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    block_count = (sd_cardinfo.card_csd.c_size + <span class="number">1</span>)*<span class="number">1024</span>;</span><br><span class="line">    block_size = <span class="number">512</span>;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Device Size: %dKB\n&quot;</span>, sd_card_capacity_get());</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Block Size: %dB\n&quot;</span>, block_size);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Block Count: %d\n&quot;</span>, block_count);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Bus Width: %dBit\n&quot;</span>, buswidth);</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Bus Clock: %dMHz\n&quot;</span>, busspeed);</span><br><span class="line"></span><br><span class="line">    temp_ccc = sd_cardinfo.card_csd.ccc;</span><br><span class="line">    rt_kprintf(<span class="string">&quot;Card Command Classes: %x\n&quot;</span>, temp_ccc);</span><br><span class="line"></span><br><span class="line">    rt_kprintf(<span class="string">&quot;Features:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sd_cardinfo.card_csd.read_bl_partial)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Partial blocks for read allowed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sd_cardinfo.card_csd.write_bl_partial)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Partial blocks for write allowed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((SD_CCC_BLOCK_READ &amp; temp_ccc) &amp;&amp; (SD_CCC_BLOCK_WRITE &amp; temp_ccc))&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Block operation supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_ERASE &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Erase supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_WRITE_PROTECTION &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Write protection supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_LOCK_CARD &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Lock unlock supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_APPLICATION_SPECIFIC &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Application specific supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_IO_MODE &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;I/O mode supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SD_CCC_SWITCH &amp; temp_ccc)&#123;</span><br><span class="line">        rt_kprintf(<span class="string">&quot;Switch function supported\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MSH_CMD_EXPORT(cardinfo, show tfcard info);</span><br></pre></td></tr></table></figure><h3 id="卡片信息"><a href="#卡片信息" class="headerlink" title="卡片信息"></a>卡片信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Card Information</span><br><span class="line">Manufacturer ID: <span class="number">0x03</span></span><br><span class="line">OEM/Application ID: <span class="number">0x5344</span></span><br><span class="line">Name: <span class="number">23</span>DSG</span><br><span class="line">Revision: <span class="number">0x85</span></span><br><span class="line">Serial number: <span class="number">54b</span>b003e</span><br><span class="line">Manufacturing date: <span class="number">0x161</span></span><br><span class="line">Version: <span class="number">3.0</span>x</span><br><span class="line">Type: SDHC card</span><br><span class="line">Device Size: <span class="number">31166976</span>KB</span><br><span class="line">Block Size: <span class="number">512B</span></span><br><span class="line">Block Count: <span class="number">62333952</span></span><br><span class="line">Bus Width: <span class="number">4B</span>it</span><br><span class="line">Bus Clock: <span class="number">40</span>MHz</span><br><span class="line">Card Command Classes: <span class="number">5b</span>5</span><br><span class="line">Features:</span><br><span class="line">Block operation supported</span><br><span class="line">Erase supported</span><br><span class="line">Lock unlock supported</span><br><span class="line">Application specific supported</span><br><span class="line">Switch function supported</span><br></pre></td></tr></table></figure><h3 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h3><p>CMD25连续写20KB</p><table><thead><tr><th>时钟</th><th>Ticks</th><th>速度</th><th>卡类型</th><th>备注</th></tr></thead><tbody><tr><td>40M</td><td>525543</td><td>4.4596MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>416303</td><td>5.6299MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>411787</td><td>5.7145MB&#x2F;s</td><td>SANDISK-32G</td><td></td></tr><tr><td>60M</td><td>408590</td><td>5.7592MB&#x2F;s</td><td>SANDISK-32G</td><td>no print log</td></tr><tr><td>60M</td><td>409943</td><td>5.7172MB&#x2F;s</td><td>SANDISK-32G</td><td>no print log</td></tr></tbody></table><p>CMD18连续读20KB</p><table><thead><tr><th>时钟</th><th>Ticks</th><th>速度</th><th>卡类型</th></tr></thead><tbody><tr><td>40M</td><td>188076</td><td>12.4617MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>127804</td><td>18.3387MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60M</td><td>147390</td><td>15.9017MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>146691</td><td>15.9775MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr><tr><td>60M</td><td>133362</td><td>17.5744MB&#x2F;s</td><td>SDTRUVAL-16G</td></tr></tbody></table><p>不同时钟的CMD18连续读取</p><table><thead><tr><th>时钟</th><th>大小</th><th>Ticks</th><th>速度</th><th>卡类型</th></tr></thead><tbody><tr><td>24MHZ</td><td>4K</td><td>95183</td><td>4.9247MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>40MHZ</td><td>4K</td><td>76923</td><td>6.0939MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60MHZ</td><td>4K</td><td>69888</td><td>6.7071MB&#x2F;s</td><td>SANDISK-32G</td></tr><tr><td>60MHZ</td><td>8K</td><td>86264</td><td>10.8678MB&#x2F;s</td><td>SANDISK-32G</td></tr></tbody></table><p>卡时钟40MHz</p><img src="/posts/2510049814/1928719-20250411132800986-554948786.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/18809197">GD32F303 SDIO-DMA读写SD卡</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">GD32F303 SDIO-DMA读写SD卡</summary>
    
    
    
    <category term="SD卡" scheme="https://zml3589110.github.io/categories/SD%E5%8D%A1/"/>
    
    <category term="SDIO" scheme="https://zml3589110.github.io/categories/SDIO/"/>
    
    
    <category term="GD32" scheme="https://zml3589110.github.io/tags/GD32/"/>
    
    <category term="SD卡" scheme="https://zml3589110.github.io/tags/SD%E5%8D%A1/"/>
    
    <category term="DMA" scheme="https://zml3589110.github.io/tags/DMA/"/>
    
    <category term="SDIO" scheme="https://zml3589110.github.io/tags/SDIO/"/>
    
  </entry>
  
  <entry>
    <title>SWD接口和通信实现</title>
    <link href="https://zml3589110.github.io/posts/1214364109.html"/>
    <id>https://zml3589110.github.io/posts/1214364109.html</id>
    <published>2025-09-15T13:08:20.000Z</published>
    <updated>2025-09-15T13:23:36.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="空闲态电平"><a href="#空闲态电平" class="headerlink" title="空闲态电平"></a>空闲态电平</h3><ol><li>SWD接口由SWCLK和SWDIO两根信号线组成，<code>SWCLK</code>调试器给目标芯片的时钟信号，在芯片端需要下拉；<code>SWDIO</code>双向数据信号，在芯片端需要上拉，上&#x2F;下拉电阻的取值在<code>100K</code>附近即可。<img src="/posts/1214364109/1928719-20230805195424710-1520620034.png" class="" title="image">上&#x2F;下拉电阻取值来自<code>PY32</code>单片机数据手册：<img src="/posts/1214364109/1928719-20230807212951926-1687425708.png" class="" title="image"></li><li>在调试器端，空闲态下：<code>SWDIO</code>可以输出高，<code>SWCLK</code>可以输出高也可以输出低（DAPLINK初始化端口默认输出高，JLINK的SWCLK和SWDIO输出都是低，JLINK和DAPLINK时序不同）。</li></ol><p>DAPLINK的配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Setup SWD I/O pins: SWCLK, SWDIO, and nRESET.</span></span><br><span class="line"><span class="comment">Configures the DAP Hardware I/O pins for Serial Wire Debug (SWD) mode:</span></span><br><span class="line"><span class="comment"> - SWCLK, SWDIO, nRESET to output mode and set to default high level.</span></span><br><span class="line"><span class="comment"> - TDI, TMS, nTRST to HighZ mode (pins are unused in SWD mode).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">__STATIC_INLINE <span class="keyword">void</span> <span class="title">PORT_SWD_SETUP</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Set SWCLK HIGH</span></span><br><span class="line">    pin_out_init(SWCLK_TCK_PIN_PORT, SWCLK_TCK_PIN_Bit);</span><br><span class="line">    SWCLK_TCK_PIN_PORT-&gt;BSRR = SWCLK_TCK_PIN;</span><br><span class="line">    <span class="comment">// Set SWDIO HIGH</span></span><br><span class="line">    pin_out_init(SWDIO_OUT_PIN_PORT, SWDIO_OUT_PIN_Bit);</span><br><span class="line">    SWDIO_OUT_PIN_PORT-&gt;BSRR = SWDIO_OUT_PIN;</span><br><span class="line"></span><br><span class="line">    pin_in_init(SWDIO_IN_PIN_PORT, SWDIO_IN_PIN_Bit, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Set RESET HIGH</span></span><br><span class="line">    pin_out_od_init(nRESET_PIN_PORT, nRESET_PIN_Bit);<span class="comment">//TODO - fix reset logic</span></span><br><span class="line">    nRESET_PIN_PORT-&gt;BSRR = nRESET_PIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WCH-LinkE工作在DAP模式下的电平实测：空闲态SWDIO为高电，SWCLK为低电平。</p><img src="/posts/1214364109/1928719-20230807212621679-697386745.png" class="" title="image"><img src="/posts/1214364109/1928719-20230807212625437-1585078791.png" class="" title="image"><p>JLINK电平实测：空闲态SWDIO和SWCLK都为低电平。</p><img src="/posts/1214364109/1928719-20230807213312276-862329399.png" class="" title="image"><img src="/posts/1214364109/1928719-20230807213314953-303506179.png" class="" title="image"><h3 id="接口模拟"><a href="#接口模拟" class="headerlink" title="接口模拟"></a>接口模拟</h3><ol><li>纯GPIO模拟，这也是DAPLINK的默认实现方式，只用两个IO，对于SWCLK时钟线，只需要单向输出；但是SWDIO是双向IO，那么调试器就需要对这个GPIO做输入输出切换。该方法优点是简单易实现，缺点是IO翻转频率无法做的很高，输入输出切换时有较大时间消耗。<img src="/posts/1214364109/1928719-20230805201548128-805195177.png" class="" title="image"><img src="/posts/1214364109/1928719-20230805201952501-1563029995.png" class="" title="image"></li><li>纯GPIO模拟，使用三个IO，对于SWCLK时钟线，只需要单向输出；对于SWDIO，使用两个IO，一个输出一个输入，中间串两个或一个电阻防止调试器的输入&#x2F;输出口灌入大电流。时钟速度仍受GPIO翻转速率限制，优点是省去了IO输入&#x2F;输出切换的时间。<br><strong>JLINK接法：</strong><br>当调试器驱动SWDIO时，信号经过MCU_OUT–&gt;R87–&gt;SWDIO传入目标芯片，同时信号也会经过R88返回到调试器，此时调试器忽略输入。<br>当目标芯片驱动SWDIO时，信号经过SWDIO–&gt;R88–&gt;MCU_IN被调试器接收，同时信号也会经过R87到达MCU_OUT，由于R87的存在，无论调试器端MCU_OUT之前状态是输出高还是低，都不会造成短路。<img src="/posts/1214364109/1928719-20230805202052915-684475811.png" class="" title="image"><strong>DAPLINK接法：</strong><br>简化的版本，SWDIO直连调试器输入端，原理和上文类似。<img src="/posts/1214364109/1928719-20230805202514124-762302590.png" class="" title="image">关于电阻的取值：电阻值限制了SWDIO信号线的上升&#x2F;下降速率，需要高速传输取100R左右的小电阻，代价是动态电流较大，在DAPLINK接法的100R电阻下，调试线长15CM左右，满足10M的IO翻转速率是没有问题的。<br><strong>推荐的接法：</strong><br>满足日常10~20CM的调试线使用，其中0R的电阻预留；当走线较长时，需要实测通信线上升和下降的振铃波形幅度，同时修改R87和R116。<img src="/posts/1214364109/1928719-20230811202939969-717443760.png" class="" title="image"></li><li>利用SPI实现部分硬件加速，适用于常见的只支持<code>8bi</code>t或者<code>16bit</code>固定位宽的SPI外设。这种方案有一定的加速效果，但是使用起来比较麻烦。<img src="/posts/1214364109/1928719-20230811202947168-161295864.png" class="" title="image"></li></ol><p>下图是调试器写目标芯片的时序为例：<br>1：调试器发送的包请求（8bits）由SPI硬件完成<br>2：转向位(1bit) + 芯片发送的应答响应（3bits）+ 转向位(1bit) 切换到GPIO模拟<br>3：调试器的数据发送阶段（32bits）由SPI硬件完成<br>4：校验位（1bit）切换到GPIO模拟</p><img src="/posts/1214364109/1928719-20230805211142155-686503954.png" class="" title="image"><ol><li>完全的SPI硬件加速，硬件连线同上图。例如<code>STM32F072, STM32F303,STM32F051</code>这种最低支持<code>4bit</code>的SPI外设就可以完全模拟SWD协议各个部分的时序了。<br>调试器向目标芯片的写操作：8bit写 + 5bit读(丢掉最低位和最高位) + （16bit写 + 8bit写 + 9bit写）。<img src="/posts/1214364109/1928719-20230805211703375-1225858851.png" class="" title="image">调试器向目标芯片的读操作：8bit写 + 4bit读(丢掉最低位) + （16bit读 + 8bit读 + 10bit读）。<img src="/posts/1214364109/1928719-20230805211850125-880518240.png" class="" title="image"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stm32f0xx_spi.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_4b                 ((uint16_t)0x0300)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_5b                 ((uint16_t)0x0400)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_6b                 ((uint16_t)0x0500)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_7b                 ((uint16_t)0x0600)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_8b                 ((uint16_t)0x0700)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_9b                 ((uint16_t)0x0800)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_10b                ((uint16_t)0x0900)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_11b                ((uint16_t)0x0A00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_12b                ((uint16_t)0x0B00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_13b                ((uint16_t)0x0C00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_14b                ((uint16_t)0x0D00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_15b                ((uint16_t)0x0E00)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPI_DataSize_16b                ((uint16_t)0x0F00)</span></span><br></pre></td></tr></table></figure><p>另一款芯片<code>ESP8266</code>的SPI使用FIFO模式操作，支持<code>1bit~512bit</code>任意读写，那么在SWD协议的WDATA段直接发起31bit的传输即可。</p><h3 id="信号时序"><a href="#信号时序" class="headerlink" title="信号时序"></a>信号时序</h3><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/17608599.html">SWD接口和通信实现</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">SWD接口和通信实现</summary>
    
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/categories/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/categories/SWD/"/>
    
    
    <category term="STM32" scheme="https://zml3589110.github.io/tags/STM32/"/>
    
    <category term="SWD" scheme="https://zml3589110.github.io/tags/SWD/"/>
    
    <category term="KEIL" scheme="https://zml3589110.github.io/tags/KEIL/"/>
    
    <category term="下载器" scheme="https://zml3589110.github.io/tags/%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    
    <category term="烧录器" scheme="https://zml3589110.github.io/tags/%E7%83%A7%E5%BD%95%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>F1C100S-BOOTROM与SPL阶段</title>
    <link href="https://zml3589110.github.io/posts/1056682153.html"/>
    <id>https://zml3589110.github.io/posts/1056682153.html</id>
    <published>2025-09-15T13:02:20.000Z</published>
    <updated>2025-09-15T13:23:36.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="BootROM支持的引导介质"><a href="#BootROM支持的引导介质" class="headerlink" title="BootROM支持的引导介质"></a>BootROM支持的引导介质</h3><img src="/posts/1056682153/1928719-20220604124014691-1561797689.png" class="" title="img"><h4 id="默认的启动优先级"><a href="#默认的启动优先级" class="headerlink" title="默认的启动优先级"></a>默认的启动优先级</h4><p>目前没有找到修改启动顺序的方式</p><table><thead><tr><th>序号</th><th>启动介质</th><th>注意事项</th></tr></thead><tbody><tr><td>1st</td><td>MicroSD Card&#x2F;eMMC</td><td>只支持PF0 ~ PF5这六个脚复用为SDC0启动, 控制器支持到SD2.0和eMMC4.41，设备端可以使用主流的eMMC5.1(eMMC存储器可以向前兼容)</td></tr><tr><td>2nd</td><td>SPI Nor&#x2F;Nand Flash</td><td>只支持PC0 ~ PC3这四个脚复用为SPI0启动, 支持标准SPI和DOUT模式, BROM启动时SPI Nand固定为1024字节&#x2F;页，SPI Nor无特殊限制</td></tr><tr><td>3rd</td><td>BROM FEL Mode</td><td>以上介质都无启动代码时，自动运行芯片内部USB程序(FEL Mode)(USB Full-Speed@12Mbps)，USB脚是固定的无其它复用功能</td></tr></tbody></table><p>F1C100S手册未提及芯片启动顺序，但可以参考全志V3S的手册，F1C100S没有强制进入烧写模式的专用引脚，可以将<code>SDC0_CMD</code>或<code>SPI0_CS/SPI0_DOUT</code>强制接地干扰已经固化在eMMC&#x2F;Nor-Flash中的SPL启动，让芯片进入USB-FEL下载模式。</p><img src="/posts/1056682153/1928719-20220724134750238-317317628.png" class="" title="img"><p>下图的SDC1_CMD实际上作为SPI0_DOUT功能</p><img src="/posts/1056682153/1928719-20220724150444768-1249396344.png" class="" title="img"><h4 id="SDC0启动"><a href="#SDC0启动" class="headerlink" title="SDC0启动"></a>SDC0启动</h4><p>硬件连线使用以下引脚，BootROM读取eMMC或SDCard中的SPL程序时，只使用了1bit-sdio，且最大速度限制在25MHz，因此正常启动最少需要接CMD、CLK、D0这三根线；<br>但eMMC或SDCard在启动完成后还可作为应用程序的存储器，为了提升传输速度建议<code>CMD、CLK D0~D3</code>这6根线都接上，F1C100S的SDIO控制器最大支持SDR-4bit@50MHz。</p><img src="/posts/1056682153/1928719-20220604124248950-877387359.png" class="" title="img"><p>通过逻辑分析仪抓取BootROM读取eMMC中的SPL程序的过程，可以看到只使用了1bit模式。</p><img src="/posts/1056682153/1928719-20220604131404899-2040727626.png" class="" title="img"><p>SPL程序需要从eMMC UDA物理分区的第16个扇区(512字节&#x2F;扇区)开始烧录，下图是eMMC UDA物理分区内的布局图：<br><code>前8KB(扇区0 ~ 扇区15)</code>存放MBR分区表或者非标准的GPT分区表，<code>扇区16</code>开始存放SPL程序，BROM将从这里读取程序到SRAM并执行，<code>扇区80</code>开始可以存放用户的程序，如果是启动linux，这里可以存放uboot，如果是嵌入式系统或者裸机，这里直接存放应用程序。</p><img src="/posts/1056682153/1928719-20220724152140819-205036069.png" class="" title="img"><p>对于使用GPT分区表的情况，前8KB的空闲空间只能存放56条分区信息，GPT规范要求至少留128条分区信息的空间，某些工具可能不会认可这样非标准的分区表，因此GPT分区表可以放在SPL程序后面。对于一般应用来说，MBR分区表最大支持4个分区已经可以满足需求。</p><img src="/posts/1056682153/1928719-20220724152657321-1244433231.png" class="" title="img"><p>在抓取BootROM与eMMC通信中，观察到了F1C100S的BootROM会写eMMC的1号扇区<code>(待重复验证)</code>，建议前0~15扇区都空着，有分区表的话还是放在SPL程序后面。</p><img src="/posts/1056682153/1928719-20220604133848505-755113197.png" class="" title="img"><h4 id="SPI0启动"><a href="#SPI0启动" class="headerlink" title="SPI0启动"></a>SPI0启动</h4><p>标准的4线SPI接口，最大速度是AHB总线时钟的2分频，AHB通常设置为200MHz，因此SPI的时钟最大为100MHz。<br>BootROM加载SPL程序时默认使用标准SPI，具体时钟速度忘记了，大概10MHz以内，这段启动时间是无法优化的。<br>SPL启动后，加载用户程序时，推荐使用DOUT模式，用带宽换时钟，降低SPI布线要求，100MHz的SPI读写Flash实测不是很稳定。</p><img src="/posts/1056682153/1928719-20220604140519975-852271578.png" class="" title="img"><p>nor-flash和nand-flash需要从物理0地址<code>(0号扇区0地址)</code>开始烧录SPL程序。</p><img src="/posts/1056682153/1928719-20220724154906422-1940832619.png" class="" title="img"><p>spi nor-flash直接使用sunxi-fel工具烧录。</p><img src="/posts/1056682153/1928719-20220724155111676-1896318578.png" class="" title="img"><p>spi nand-flash有一个改版的sunxi-fel工具可用，目前大部分的spi nand-flash都是4K&#x2F;扇区的，烧录的时候每扇区只使用前1K，剩下的空着(spi nand启动还未测试过)。</p><h4 id="USB启动"><a href="#USB启动" class="headerlink" title="USB启动"></a>USB启动</h4><p>当SDC0，SPI0都没有读取到SPL程序时，自动运行芯片固化的USB程序(FEL)，此时可以通过该程序提供的API，通过USB对芯片下载程序或执行ARM汇编代码。</p><img src="/posts/1056682153/1928719-20220606195458253-1956918537.png" class="" title="img"><p>在usb-fel模式下，usb接口默认是全速的(12Mbps)，F1C100S的usb也支持高速模式(480Mbps)，因此在USB端口的ESD二极管等效电容尽可能小，推荐使用5pF左右的。<br>windows下需要使用<code>zadig</code>安装winusb(libusb)驱动，然后才能使用<code>sunxi-fel</code>工具进行nor-flash烧录，发送程序到DRAM执行等。</p><img src="/posts/1056682153/1928719-20220618120305897-113075659.png" class="" title="img"><h3 id="BOOTROM到SPL"><a href="#BOOTROM到SPL" class="headerlink" title="BOOTROM到SPL"></a>BOOTROM到SPL</h3><p>以下是全志F1C100S参考手册的内存映射表：</p><img src="/posts/1056682153/1928719-20220730210223879-2026439209.png" class="" title="img"><p>以下是全志V3S参考手册的内存映射表：</p><img src="/posts/1056682153/1928719-20220730210340665-420809545.png" class="" title="img"><p>先说结论：<br>关于BROM地址和SRAM地址，全志F1C100S手册描述有误，全志V3S手册描述部分适用于F1C100S，下面进行验证。</p><p>在没有片外启动介质的情况下，给F1C100S通电，按照F1C100S手册上描述，BROM在<code>0x0 ~ 0x7FFF</code>，这里直接从0地址开始，先读出64K内容查看：</p><img src="/posts/1056682153/1928719-20220731110957701-2088918446.png" class="" title="img"><p>从提取出的内容来看，并不是正常的可执行文件内容，因此可以断定，BROM并不在0x0地址起始处。</p><img src="/posts/1056682153/1928719-20220731111044371-1515494593.png" class="" title="img"><p>使用<code>r</code>命令复位CPU，并使用<code>halt</code>命令暂停CPU，可以看到CPU处于SVC模式，且不响应外部中断，PC是<code>0</code>，表示将从0地址取指。<br><code>PC: (R15) = 00000000, CPSR = 000000D3 (SVC mode, ARM FIQ dis. IRQ dis.)</code></p><img src="/posts/1056682153/1928719-20220730210714072-2093952861.png" class="" title="img"><p>那再次查看下<code>0x00000000</code>地址上的内容吧：<br>可以看到和上文一样是<code>FF FF FF FF</code>，由于ARM内核无法区分读到的内容是指令还是数据，读到的东西全部当成指令进行解析，那么全FF肯定不是正常的ARM指令，处理器执行到这里将会进入<code>未定义指令异常</code>。</p><img src="/posts/1056682153/1928719-20220730211156444-547181485.png" class="" title="img"><p>试着单步运行一下，果然出现了未定义指令异常，且PC指向了<code>FFFF0004</code>处，顺着PC值就找到了默认异常向量表的位置。<br><code>PC: (R15) = FFFF0004, CPSR = 000000DB (UNDEF mode, ARM FIQ dis. IRQ dis.)</code></p><img src="/posts/1056682153/1928719-20220730211415427-1305513944.png" class="" title="img"><p>因为未定义指令异常排在异常表的第二位，所以当前PC值是<code>FFFF0004</code>，那么异常向量表起始位置就是<code>0xFFFF0000</code></p><img src="/posts/1056682153/1928719-20220730214105941-395350637.jpg" class="" title="img"><p>通常ARM9异常向量表默认地址可以设置成两种：<code>0x0</code>和<code>0xFFFF0000</code>，可以通过访问CP15协处理器的C1寄存器来设置或者读取</p><img src="/posts/1056682153/1928719-20220730212411136-140083481.png" class="" title="img"><p>继续进行单步操作，发现进入死循环：</p><img src="/posts/1056682153/1928719-20220730225617190-485450976.png" class="" title="img"><p>将<code>0xFFFF0000</code>处的异常向量表读出，发现其他7个异常都指向了<code>while(1)</code></p><img src="/posts/1056682153/1928719-20220730230717230-1415300732.png" class="" title="img"><p>那么可以判断出，F1C100S上电后并不是通过0地址的指令异常向量跳转到BROM处的，BROM应该在其他地方。</p><p>对芯片拉低复位信号，复位CPU，但调试器不做任何操作，这样CPU可正常运行；经过硬复位，芯片的BROM正常运行，sunxi-fel工具也正确识别。</p><img src="/posts/1056682153/1928719-20220730231357023-934849619.png" class="" title="img"><p>此时挂上调试器，可以看到正常运行时<code>PC=0xffff012c</code>，当前运行位置在默认异常表的后面。</p><img src="/posts/1056682153/1928719-20220730231434325-610336373.png" class="" title="img"><p>使用<code>r</code>命令，<code>halt</code>命令复位并暂停CPU，手动将PC设置到<code>0xFFFF0000</code>处，使用<code>s</code>单步执行几次，经过2个跳转指令，最终跳转到了<code>0xFFFF4000</code>地址处。<br>那么基本可以断定，BROM处于<code>0xFFFF4000</code>地址。</p><img src="/posts/1056682153/1928719-20220801000733287-219870545.png" class="" title="img"><p>使用<code>g</code>命令全速运行：</p><img src="/posts/1056682153/1928719-20220731001118831-297741523.png" class="" title="img"><p>sunxi-fel工具也正确识别出了设备，此时暂停CPU查看PC寄存器，也与正常上电运行后再暂停CPU的PC寄存器值一致:</p><img src="/posts/1056682153/1928719-20220731001405882-786755736.png" class="" title="img"><img src="/posts/1056682153/1928719-20220731001441359-1164060828.png" class="" title="img"><p>那么可以推断出F1C100S上电后，应该是从<code>0xFFFF4000</code>地址处启动，BROM异常向量在’0xFFFF0000’处。</p><h3 id="F1C100S实际的BROM和SRAM地址表"><a href="#F1C100S实际的BROM和SRAM地址表" class="headerlink" title="F1C100S实际的BROM和SRAM地址表"></a>F1C100S实际的BROM和SRAM地址表</h3><table><thead><tr><th>Module</th><th>Address</th><th>Size</th><th>权限</th></tr></thead><tbody><tr><td>SRAM</td><td>0x0000 - 0x9000</td><td>36KB</td><td>rwx</td></tr><tr><td>SRAM1</td><td>0xB000 - 0xB600</td><td>1.5KB</td><td>rwx</td></tr><tr><td>异常向量表</td><td>0xFFFF0000 - 0xFFFF001F</td><td>32 Bytes</td><td>rx</td></tr><tr><td>FEL模式相关程序</td><td>0xFFFF0020 - 0xFFFF25AB</td><td>9612 Bytes</td><td>rx</td></tr><tr><td>BROM</td><td>0xFFFF4000 - 0xFFFF62B7</td><td>8888 Bytes</td><td>rx</td></tr></tbody></table><p>同时也在在<code>0xFFFF4000</code>地址处发现了<code>eGON.BRM</code>文件头的固件，通过<code>BRM</code>大致可以猜出这是F1C100S的BOOTROM了，和全志二级引导的文件头<code>eGON.BT0</code>有点类似。</p><img src="/posts/1056682153/1928719-20220731002818456-1888672137.png" class="" title="img"><p>&#x2F;&#x2F; 待完成…</p><p>参考文档：<br>挖坑网关于F1C100S SPI-NAND启动的讨论：<br><a href="https://whycan.com/t_1658.html">https://whycan.com/t_1658.html</a><br><a href="https://whycan.com/t_649.html">https://whycan.com/t_649.html</a><br>github开源的spi-nand调试记录：<br><a href="https://github.com/hcly/f1c100s">https://github.com/hcly/f1c100s</a><br>CSDN关于F1C100S制作SPI-NAND镜像：<br><a href="https://blog.csdn.net/hclydao/article/details/103709642">https://blog.csdn.net/hclydao/article/details/103709642</a><br>linux-sunxi关于SD卡启动，实际上也适用于eMMC：<br><a href="https://linux-sunxi.org/Bootable_SD_card">https://linux-sunxi.org/Bootable_SD_card</a><br>全志V3S手册：<br><a href="https://linux-sunxi.org/images/2/23/Allwinner_V3s_Datasheet_V1.0.pdf">https://linux-sunxi.org/images/2/23/Allwinner_V3s_Datasheet_V1.0.pdf</a><br>全志其他芯片的SPL：<br><a href="https://github.com/allwinner-zh/bootloader/tree/master/basic_loader">https://github.com/allwinner-zh/bootloader/tree/master/basic_loader</a><br>linux-sunxi community：<br><a href="https://linux-sunxi.org/Main_Page">https://linux-sunxi.org/Main_Page</a><br>F1C100S SRAM地址推测：<br><a href="https://blog.csdn.net/qq446252221/article/details/122453469">https://blog.csdn.net/qq446252221/article/details/122453469</a></p><p>其他：<br>全志F1C100S的芯片的开发代号为suniv。<br><a href="https://openwrt.org/docs/techref/hardware/soc/soc.allwinner.sunxi">https://openwrt.org/docs/techref/hardware/soc/soc.allwinner.sunxi</a><br><a href="https://linux-sunxi.org/Allwinner_SoC_Family">https://linux-sunxi.org/Allwinner_SoC_Family</a><br>f1c100s_brom_ffff0000.bin提取的<code>0xFFFF0000</code>地址处的BROM：<br>f1c100s_brom_0提取的<code>0</code>地址处的内容：<br><a href="https://files.cnblogs.com/files/yanye0xff/f1c100s_brom.zip?t=1659198022">https://files.cnblogs.com/files/yanye0xff/f1c100s_brom.zip?t=1659198022</a></p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://www.cnblogs.com/yanye0xcc/p/16341719.html">F1C100S-BOOTROM与SPL阶段</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C100S-BOOTROM与SPL阶段</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="BOOTROM" scheme="https://zml3589110.github.io/tags/BOOTROM/"/>
    
    <category term="SPL" scheme="https://zml3589110.github.io/tags/SPL/"/>
    
    <category term="启动流程" scheme="https://zml3589110.github.io/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>全志F1C200S F1C100S 介绍</title>
    <link href="https://zml3589110.github.io/posts/3233973243.html"/>
    <id>https://zml3589110.github.io/posts/3233973243.html</id>
    <published>2025-09-15T09:52:20.000Z</published>
    <updated>2025-09-15T13:16:43.388Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C100S基本信息"><a href="#F1C100S基本信息" class="headerlink" title="F1C100S基本信息"></a>F1C100S基本信息</h1><h3 id="芯片的启动"><a href="#芯片的启动" class="headerlink" title="芯片的启动"></a>芯片的启动</h3><p>F1C100S支持的启动方式:</p><img src="/posts/3233973243/1928719-20210822203216503-2015530485.png" class="" title="img"><p>F1C100S启动的顺序：（硬件上必须按照注意固定的引脚接线，否则芯片无法启动）</p><table><thead><tr><th>序号</th><th>启动介质</th><th>注意事项</th></tr></thead><tbody><tr><td>1st</td><td>MicroSD Card&#x2F;eMMC</td><td>只支持PF0 ~ PF5这六个脚复用为SDC0启动, 控制器支持到SD2.0和eMMC4.41，设备端可以使用eMMC5.1(向下兼容)</td></tr><tr><td>2nd</td><td>SPI Nor&#x2F;Nand Flash</td><td>只支持PC0 ~ PC3这四个脚复用为SPI0启动, 支持DOUT模式, BROM启动时SPI Nand固定为1024字节&#x2F;页，SPI Nor无特殊限制</td></tr><tr><td>3rd</td><td>BROM FEL Mode</td><td>以上介质都无法启动时，自动运行芯片内部USB程序，此时可以USB下载(USB Full-Speed@12Mbps)，USB脚是固定的无其它复用功能</td></tr></tbody></table><h4 id="SDCard0作为启动介质的引脚"><a href="#SDCard0作为启动介质的引脚" class="headerlink" title="SDCard0作为启动介质的引脚:"></a>SDCard0作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20210822203348581-576019354.png" class="" title="img"><h4 id="SPI0作为启动介质的引脚"><a href="#SPI0作为启动介质的引脚" class="headerlink" title="SPI0作为启动介质的引脚:"></a>SPI0作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20210822203250274-627738019.png" class="" title="img"><h4 id="USB作为启动介质的引脚"><a href="#USB作为启动介质的引脚" class="headerlink" title="USB作为启动介质的引脚:"></a>USB作为启动介质的引脚:</h4><img src="/posts/3233973243/1928719-20211220214844546-1865095828.png" class="" title="img"><h3 id="LCD接口"><a href="#LCD接口" class="headerlink" title="LCD接口"></a>LCD接口</h3><p>GPIO D组就是全部的LCD接口了，RGB666 + HS + VS + DE + PCLK共计22Pin(不支持TE信号)，低配的RGB接口，每个通道的低2bit都没了，最大只支持26w色。（除了标准并口RGB，F1C100S也支持Serial-RGB：HS + VS + DE + PCLK + 8Data）</p><img src="/posts/3233973243/1928719-20210822204149353-2080865958.png" class="" title="img"><img src="/posts/3233973243/1928719-20210822205206562-54488490.png" class="" title="img"><p>需要注意的是GPIO E组有几个脚的复用功能是RGB缺失的几个通道，但这里的直接无视即可，接了也不会有用。</p><img src="/posts/3233973243/1928719-20220606193827172-809061396.png" class="" title="img"><p>具体原因请看LCD寄存器定义(全志的LCD控制器叫TCON)，各个颜色通道最高支持6bit(顺带一提稍微高端点的全志H6也是一样，还是只有6bitRGB接口)</p><img src="/posts/3233973243/1928719-20210822204633889-1819471126.png" class="" title="img"><h3 id="USB-OTG"><a href="#USB-OTG" class="headerlink" title="USB-OTG"></a>USB-OTG</h3><p>F1C100S内置的USB PHY(usb ip核使用的是musb，和ti-am3352, ti-am1810寄存器结构类似)使用GPIO-E2作为USB-ID线，因此使用USB主机时需要保留这个引脚。这里也可以由软件控制切换，软件方式插入U盘无法自动识别，需要用户主动切换到USB-HOST再插入U盘。<br>需要上拉到3.3V，默认做从机，做主机时由OTG线下拉到地。</p><h3 id="GPIO外部中断"><a href="#GPIO外部中断" class="headerlink" title="GPIO外部中断"></a>GPIO外部中断</h3><p>只支持GPIO-D&#x2F;E&#x2F;F组的外部中断，支持边沿和电平触发。由于GPIOD组被RGB占用，GPIOF组被SDC0占用，PE2被USB-OTG占用，因此只有GPIOE组的少部分IO可用。<br>推荐PE3&#x2F;4&#x2F;5&#x2F;9&#x2F;10，这几个引脚复用功能较少。</p><h3 id="PWM"><a href="#PWM" class="headerlink" title="PWM"></a>PWM</h3><p>支持2路独立的PWM，PWM0：PE12，PWM1：PE6。使用简单的16位计数器模式控制输出，输入时钟为OSC24M，最高输出频率&#x3D;24MHz，不支持脉宽调制、采集、正交编码等特殊功能。<br>用处不大，推荐用于控制屏背光，，，</p><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>很久以前发现了一颗性价比极高而且比较好玩的SOC，加群请仔细阅读本博客（见DKTool界面，请备注“来自博客”）</p><p>那就是全志F1C100S F1C200S，其中F1C100S内置32MB DDR1内存，F1C200S内置64MB DDR1内存。</p><p>这个片子能从淘宝轻松的买到，如果找靠谱的店家或者找代理商的话，F1C100S 是10块钱一片，F1C200S是13块钱一片。</p><p>从淘宝买一定要注意分辨是拆机还是库存还是正规代理货源，千万别图便宜，拆机良率可能20%；</p><p> 根据用量，找代理商价格100s是9元多，200s是13块左右。我有靠谱的代理联系方式，并可提供BSP。</p><p>这么10来块钱，32MB 和 64MB 的外扩内存都买不到啊，用来驱动RGB屏幕啥的，STM32赶紧靠边站。</p><p>其实F1C100S F1C200S F1C500S F1C600 R6都是一个芯片，他们都是QFN88封装。</p><p>资源方面，</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右，也有720M出货的。</p><p>有人说可以跑到900MHz，但我没有成功，uboot还没起来就挂了。</p><p>带有100M的SPI接口，2个SDIO接口，1个USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口。</p><p>I2C I2S UART PWM等等。</p><p>因为引脚比较少，所以复用严重，但也是有考虑的，如果IO不够用，就使用I2C扩展IO。</p><p><img src="/%E5%85%A8%E5%BF%97f1c200s%E5%BC%80%E5%8F%91%E6%9D%BF%E8%AE%BE%E8%AE%A1/f26481d46f8a51926a9cab2683435852.png" alt="f26481d46f8a51926a9cab2683435852"></p><p>我们玩的以F1C100S和F1C200S为主。</p><p>目前能从网上找到的只有F1C200S和F1C600的寄存器手册。其实他们里面的内容都是一模一样的。</p><p>目前能找到F1C200s和F1C600的完整数据手册和寄存器手册，当然完整是相对的，基础外设的寄存器都是开放的，高级解码部分是不开放的。</p><p>关于F1C100S&#x2F;F1C200S的资料，可以从挖坑网获得，whycan.cn（资料非常零散，找出自己需要的不易）</p><p>里面真是花式玩F1C100S，下面按照系统区分来列举一下：</p><p>1.流出的全志官方C600的BSP ，linux-3.10。支持硬解码编码，但不支持TVIN。可以从github搜到源码，因为C600面向的是智能音箱，所以bsp部分并没有默认支持显示屏，需要自己趟坑修改。其他问题不知。</p><p>2.全志官方的RTOS，名叫melis 2.0。这是全志自己的小系统，支持所有外设，硬件解码编码，TVIN,TVOUT各种外设，学习难度也是很大的，开发环境也是很难，如果能玩转，出些产品还是可以的。不过一般没人去研究他哈。（坑网可以获得）</p><p>3.全志官方的linux，名叫tina。有针对F1C200S的tina版本，3.0或者3.5，内核版本是linux3.10，这个软件支持部分比较丰富，还有比较完善的指导文档。不过这个资料是需要和代理商签NDA的，也就是保密协议，个人或小公司应该是不会被理会的吧。</p><p>4.社区支持的有linux-4.15，linux5.2，linux-5.6不支持硬解解码编码。其中荔枝派用的就是这个，有很多东西也是他们维护的。另外前一阵火的运行linux的名片用的就是这个片子。</p><p>5.XBOOT，九鼎xboot大佬支持的XBOOT，xboot是可以理解为裸机程序也可以理解为一个小系统，可以用来引导linux，也可以用来直接lua开发（很多人玩裸机或rtt从这里提炼驱动），直接用xboot开发也是比较方便的，在xboot群里有人做公司产品的。</p><p>6.RT-thread，这个最开始是RTT支持荔枝派做的，后来RTT有了融资，考虑盈利，把这一部分闭源了做了柿饼pie(串口屏)，在网上还能找到之前的资料。原来RTT官方支持的现在不能找到了，不过想玩RTT的饼子们，可以从github找第三方移植的RTT，现在支持了lcd和音频，资料还是不错的。有一个领头人@staunchheart ，他想玩RTT，大家可以找他一起完善 ，他已经可以用RTT的IDE studio进行开发了呢）</p><p>7.UCOS，这是xboot群的大佬，自己移植的ucos，把TVOUT都支持了，移植了NES模拟器，并做了掌机开发板，现在淘宝有售，名字叫小淘气科技，价格也很贵哟，人家可是付出了多少个夜晚研究出来的，有需求的希望支持一下，让做技术的人生活的更开心。</p><p>8.裸机keil开发，这是坑网达克罗德大神自己写的，在坑网上有资料，还可以用jlink调试开发。</p><p>9.VFS，这是simon大佬公司维护的项目，使用IAR，在单片机上跑裸机，并可以运行linux子系统。 </p><p>10.Aodzip大佬做了uboot kernel rootfs的buildroot的支持，并且uboot支持dfu下载程序，支持spi nor启动，spi nand启动，sdio0 4bit 的TF卡，SD NAND，emmc启动；sdio1 1bit 的tf卡或emmc或sd nand的启动。并且支持dfu烧写。好像还支持硬件解码编码，有大佬可以试试。</p><p>玩F1C200S的人大部分是想用来带屏的，所以GUI是大家关心的。 列举一些大家使用的GUI。</p><p>1、周立功的AWTK（首推，打算PDA就用这个了）</p><p>2、开源的littlevgl GUI</p><p>3、Qt</p><p>4、minigui</p><p>5、RTX</p><p>总之，这款片子被大家玩起来了。我也做了个核心板。</p><p>粗略算过，不算flash，核心的BOM成本在15块钱。如果全部自己手焊的话，一块板子不到20。</p><p>这是我画的板子，做了几十个挂淘宝已经卖完了。欢迎大家一起来玩，一起交流。</p><p>现在下图中的板子已经淘汰了，我又设计了新板子呢，而且在做手持机。现在没有可卖的了。如果有想要核心板PCB的话，我可以出售立创EDA工程文件，可以在本文中找到联系群号。我自己都没有可以用的了。</p><img src="/posts/3233973243/3f290d98648cea18077fce729f0b23fb.jpeg" class="" title="img"><p>上图中最底部的两个板子就是最新的核心板，增加了LCD接口，也能接通用40PIN的显示屏了。但我没有 继续做下去，毕竟核心板并不好玩，做来卖也是赚不了几十块钱，而且很麻烦。有一款我在立创库里开源过，后来 无人问津就关闭了呢。</p><p>所以玩就玩的好， 想必各位买板子回去也是想接各种东西进行测试的，所以为什么不做一个集成的板子呢！</p><p>于是PDA开始设计。</p><img src="/posts/3233973243/808e89637f87cbd53859891e93e16e6b.png" class="" title="img"><h1 id="DKTool"><a href="#DKTool" class="headerlink" title="DKTool"></a>DKTool</h1><p>同时呢， 为了方便烧写 固件什么的方便一些，我做个了windows下的图形烧录工具（其实就是封装了一下sunxi-fel）</p><p>1、支持监测插入电脑的芯片型号，判断是F1C100S还是F1C200S，</p><p>2、支持监测spi flash的容量</p><p>3、支持烧录文件到spi flash</p><p>4、支持读取spi flash数据以文件的方式存储</p><p>5、支持烧写文件到DDR</p><p>6、支持读取DDR中数据以文件方式存储</p><p>7、支持读写指定内存地址的32bit数据（可以读写ddr，也可以用来设置寄存器啥的）</p><p>8、我觉得最好的功能还就集成了USB驱动部分，DKTool驱动就是本工具使用的驱动，</p><p>另一个则是烧录全志官方BSP固件用的工具。</p><p>（全志BSP生成的固件内包含了很多东西，比较复杂，搞不懂）</p><img src="/posts/3233973243/2802096db368dfe56fbcb5edf2e89bf4.png" class="" title="img"><img src="/posts/3233973243/69cd843646efe61a9ae0e619e1bcab63.png" class="" title="img"><p>烧写工具还有很多BUG需要完善，所以不在这发布了。可以到群里去找，最新版本0229，不再更新。以后PDA出来再做配套软件，会加上可以烧写emmc等功能。</p><p>4层板的PDA正在进行中，还制作了钢网，OK了后续再更新。</p><p>PDA的硬件第一版有些不合理，又做了第二版，就是 下面的工程版PDA。</p><p>工程PDA算是OK了，知道了一些BUG，下一版不出问题就是正式版了，</p><p>另外，RGB屏已经驱动成功，音频带喇叭也已经驱动成功，N76E003的 烧录我要改版到可以使用一个Type-C口烧录。</p><p>N76E003模拟N多个额PCF8574。</p><p>不出现什么意外，今年看看能不能做出来。</p><p>2020今年家有喜事，暂时放下了一段时间，慢慢来吧。</p><p>下面绿色的框子不太好看，正式版用的是黑色亚克力。</p><p>2020年10月：</p><p>3寸屏太小了，板子上塞不了多少东西，于是我又换了一个屏幕3.5寸的（大显家的）。</p><p>在此说一下PDA的配置</p><p>CPU:F1C100S&#x2F;F1C200S</p><p>RAM:内置32MB&#x2F;64MB</p><p>Flash:TF卡槽焊盘+SD Nand焊盘+EMMC焊盘（看情况进行焊接）</p><p>音频：麦克风+iphone6以上高音质喇叭</p><p>接口：Type-C USB2.0 slave；充电、单片机&#x2F;SOC下载程序、串口调试单片机&#x2F;SOC、调试蓝牙模块</p><pre><code>       USB2.0 母口  可以插U盘</code></pre><p>按键：美上美优质滚轮编码器（手感贼棒！！！）</p><p>屏幕：3.5寸电容触摸 480*800分辨率 IPS屏 非全贴合</p><p>摄像头：OV5640 500万像素</p><p>WiFi：ESP8266EX  工作在sdio网卡模式，实测速度1MB&#x2F;S</p><p>蓝牙：杰里方案，支持连接手机，通过该蓝牙，可以手机放歌，当蓝牙音箱用；可以借助蓝牙功能，PDA实现打电话功能。可以BLE数据传输，通过微信小程序配置WIFI网络。</p><p>电源管理：暂时保密，同时锂电池充电管理</p><p>电池：诺基亚BL-5C  1000mAh</p><p>包边：不锈钢装饰条</p><p>正反面：亚克力广告贴（最终效果逼格高！）</p><p>2021年7月：</p><p>换屏了，3.8寸的带弧度的屏，这样做出来才像PDA</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">全志F1C200S F1C100S 介绍</a></li><li><a href="https://www.cnblogs.com/yanye0xcc/p/15173414.html">F1C100S基本信息</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C200S F1C100S 介绍</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="DKTool" scheme="https://zml3589110.github.io/tags/DKTool/"/>
    
  </entry>
  
  <entry>
    <title>F1C200S使用keil5开发问题</title>
    <link href="https://zml3589110.github.io/posts/3416408887.html"/>
    <id>https://zml3589110.github.io/posts/3416408887.html</id>
    <published>2025-09-15T07:04:20.000Z</published>
    <updated>2025-09-15T10:01:53.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译问题"><a href="#编译问题" class="headerlink" title="编译问题"></a>编译问题</h1><h2 id="Folders-x2F-Extensions报错"><a href="#Folders-x2F-Extensions报错" class="headerlink" title="Folders&#x2F;Extensions报错"></a>Folders&#x2F;Extensions报错</h2><img src="/posts/3416408887/5aa9d2c17b19c786354a4e476f1acac8.png" class="" title="img"><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_44346906/article/details/136306006">keil5编译失败。‘Manage Project Items - Folders&#x2F;Extensions‘ to manage ARM Compiler Versions. ‘Options for</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序在Keil环境中开发问题收集</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/categories/Keil/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
    <category term="Keil" scheme="https://zml3589110.github.io/tags/Keil/"/>
    
  </entry>
  
  <entry>
    <title>Web Serial网页串口</title>
    <link href="https://zml3589110.github.io/posts/3511617639.html"/>
    <id>https://zml3589110.github.io/posts/3511617639.html</id>
    <published>2025-09-10T13:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）"><a href="#使用-Web-Serial-API-在浏览器中实现串口通讯（纯前端）" class="headerlink" title="使用 Web Serial API 在浏览器中实现串口通讯（纯前端）"></a>使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>串口是非常常用的一种电脑与设备交互的接口。目前在浏览器上直接使用电脑上的串口设备了，这篇文章将介绍相关内容。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><strong>Web Serial API 相关内容参考如下：</strong></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Serial">https://developer.mozilla.org/en-US/docs/Web/API/Serial</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/API/SerialPort">https://developer.mozilla.org/en-US/docs/Web/API/SerialPort</a><br><a href="https://wicg.github.io/serial/">https://wicg.github.io/serial/</a></p><p><strong>这个API目前还处于实验性质，只有电脑上的Chrome、Edge、Opera等浏览器支持：</strong></p><img src="/posts/3511617639/dc7c13d0e94905685d30ef0d7b849e95.png" class="" title="在这里插入图片描述"><p><strong>另外还需要注意的是从网页操作设备是比较容易产生安全风险的，所以这个API只支持本地调用或者是HTTPS方式调用。</strong></p><p><strong>对于这个API谷歌有提供示例工程：</strong></p><p>在线使用：<a href="https://googlechromelabs.github.io/serial-terminal/">https://googlechromelabs.github.io/serial-terminal/</a><br>项目地址：<a href="https://github.com/GoogleChromeLabs/serial-terminal">https://github.com/GoogleChromeLabs/serial-terminal</a></p><p><strong>下面这个项目做的挺不错的，直接拿来用也很好：</strong></p><p>在线使用：<a href="https://itldg.github.io/web-serial-debug/">https://itldg.github.io/web-serial-debug/</a><br>项目地址：<a href="https://gitee.com/itldg/web-serial-debug">https://gitee.com/itldg/web-serial-debug</a> or <a href="https://github.com/itldg/web-serial-debug">https://github.com/itldg/web-serial-debug</a></p><img src="/posts/3511617639/5dfa19735e8d90d6a670175264b30bae.png" class="" title="在这里插入图片描述"><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p><strong>使用下面方法可以侦测电脑上串口设备插入与拔出：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局串口设备插入事件</span></span><br><span class="line">navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial connected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局串口设备拔出事件</span></span><br><span class="line">navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Serial disconnected: &quot;</span>, event.target);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以对单个的串口设备设置插入与拔出事件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用下面方法可以显示电脑上的串口设备选择授权，或者显示已授权的串口设备列表：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestPort方法将显示一个包含已连接设备列表的对话框，用户选择可以并授予其中一个设备访问权限</span></span><br><span class="line"><span class="comment">// 对于USB虚拟串口而言该方法还可以传入一个过滤器，指定PID&amp;VID的串口</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="keyword">await</span> navigator.serial.requestPort();</span><br><span class="line"><span class="comment">// port.forget(); // 取消授权</span></span><br><span class="line"><span class="comment">// port.getInfo() // 获取PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getDevices方法可以返回已连接的授权过的设备列表</span></span><br><span class="line"><span class="keyword">const</span> ports = <span class="keyword">await</span> navigator.serial.getPorts();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 open 方法打开选中的串口设备后就可以进行数据交互了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open时可以传入串口参数</span></span><br><span class="line"><span class="keyword">await</span> port.open(&#123;</span><br><span class="line">    baudRate: <span class="number">115200</span>,</span><br><span class="line">    <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span><br><span class="line">    <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span><br><span class="line">    <span class="comment">// flowControl: none, // 流控制，默认无</span></span><br><span class="line">    <span class="comment">// parity: none,      // 校验，默认无</span></span><br><span class="line">    <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>打开后就可以发送数据了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> encoder = <span class="keyword">new</span> TextEncoder();</span><br><span class="line"><span class="comment">// const data= new Uint8Array(length);</span></span><br><span class="line"><span class="keyword">const</span> writer = port.writable.getWriter();</span><br><span class="line"><span class="keyword">await</span> writer.write(encoder.encode(<span class="string">&quot;PING&quot;</span>));</span><br><span class="line"><span class="comment">// await writer.write(data);</span></span><br><span class="line">writer.releaseLock();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>同样可以设置数据接收：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (port.readable) &#123;</span><br><span class="line">  <span class="keyword">const</span> reader = port.readable.getReader();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">      <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Do something with |value|…</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// Handle |error|…</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    reader.releaseLock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据接收本身很简单，但需要注意的是在关闭串口前需要释放 reader 对象。</p><p><strong>下面是关闭串口操作：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 await port.close(); 即可关闭串口，如果正在读写数据，需要先释放相关资源</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keepReading = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> reader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readUntilClosed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (port.readable &amp;&amp; keepReading) &#123;</span><br><span class="line">    reader = port.readable.getReader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span><br><span class="line">        <span class="keyword">if</span> (done) &#123;</span><br><span class="line">          <span class="comment">// |reader| has been canceled.</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do something with |value|...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// Handle |error|...</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      reader.releaseLock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> port.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closed = readUntilClosed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sometime later...</span></span><br><span class="line">keepReading = <span class="literal">false</span>;</span><br><span class="line">reader.cancel();</span><br><span class="line"><span class="keyword">await</span> closed;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除了上面内容外还可以使用 setSignals 和 getSignals 来设置和获取流控制情况。</strong></p><h2 id="代码与演示"><a href="#代码与演示" class="headerlink" title="代码与演示"></a>代码与演示</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web Serial API Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        * &#123;</span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">button</span>,<span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin</span>: <span class="number">1rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">0.5rem</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">width</span>: <span class="number">20rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">textarea</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="attribute">resize</span>: none;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-y</span>: scroll;</span></span><br><span class="line"><span class="css">            <span class="attribute">overflow-x</span>: hidden;</span></span><br><span class="line"><span class="css">            <span class="attribute">height</span>: <span class="number">5rem</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="string">&quot;serial&quot;</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// alert(&quot;Your browser support Web Serial API.&quot;); // 浏览器不支持 Web Serial API</span></span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;Your browser is not support Web Serial API.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备插入事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.onconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port connected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 全局串口设备拔出事件</span></span></span><br><span class="line"><span class="javascript">        navigator.serial.ondisconnect = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Serial port disconnected: &quot;</span>, event.target);</span></span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSelect&quot;</span>&gt;</span>select<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnOpen&quot;</span>&gt;</span>open<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnClose&quot;</span>&gt;</span>close<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btnSend&quot;</span>&gt;</span>send<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptOutput&quot;</span>&gt;</span>D0 D1 D2 D3 D4 D5 D6 D7<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;iptInput&quot;</span> <span class="attr">readonly</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSelect = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSelect&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnOpen = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnOpen&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnClose = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnClose&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btnSend = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#btnSend&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptOutput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptOutput&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> iptInput = <span class="built_in">document</span>.querySelector(<span class="string">&quot;#iptInput&quot;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reader = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> reading = <span class="literal">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 选择串口</span></span></span><br><span class="line"><span class="javascript">        btnSelect.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                port = <span class="keyword">await</span> navigator.serial.requestPort(); <span class="comment">// 弹出系统串口列表对话框，选择一个串口进行连接</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> ports = <span class="keyword">await</span> navigator.serial.getPorts(); <span class="comment">// 获取已连接的授权过的设备列表</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(ports);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// await port.forget(); // 取消授权</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="comment">// console.log(port.getInfo()); // 打印PID&amp;VID (对于蓝牙串口好像是显示服务号)</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(e); <span class="comment">// The prompt has been dismissed without selecting a device.</span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">updateInputData</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data); <span class="comment">// event.data.buffer就是接收到的inputreport包数据了</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> hexstr = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> array) &#123;</span></span><br><span class="line"><span class="javascript">                hexstr += (<span class="built_in">Array</span>(<span class="number">2</span>).join(<span class="number">0</span>) + data.toString(<span class="number">16</span>).toUpperCase()).slice(-<span class="number">2</span>) + <span class="string">&quot; &quot;</span>; <span class="comment">// 将字节数据转换成（XX ）形式字符串</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            iptInput.value += hexstr;</span><br><span class="line"><span class="javascript">            iptInput.scrollTop = iptInput.scrollHeight; <span class="comment">// 滚动到底部</span></span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 读取数据</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">listenReceived</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;On reading.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            reading = <span class="literal">true</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span> (port.readable &amp;&amp; reading) &#123;</span></span><br><span class="line">                reader = port.readable.getReader();</span><br><span class="line"><span class="javascript">                <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> &#123; value, done &#125; = <span class="keyword">await</span> reader.read();</span></span><br><span class="line">                        if (done) &#123;</span><br><span class="line"><span class="javascript">                            <span class="comment">// |reader| has been canceled.</span></span></span><br><span class="line"><span class="javascript">                            <span class="keyword">break</span>;</span></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="javascript">                        <span class="comment">// 需要特别注意的是：实际使用中即使对端是按一个个包发送的串口数据，接收时收到的也可能是分多段收到的</span></span></span><br><span class="line">                        updateInputData(value);</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">catch</span> (e) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">finally</span> &#123;</span></span><br><span class="line">                    reader.releaseLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.close(); <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">            port = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port closed.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 打开串口</span></span></span><br><span class="line"><span class="javascript">        btnOpen.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (port === <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not selected.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> port.open(&#123;</span></span><br><span class="line">                baudRate: 115200,</span><br><span class="line"><span class="javascript">                <span class="comment">// bufferSize: 255,   // 读写缓存，默认255</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// dataBits: 8,       // 数据位，默认8</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// flowControl: none, // 流控制，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// parity: none,      // 校验，默认无</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// stopBits: 1,       // 停止位，默认1</span></span></span><br><span class="line">            &#125;);</span><br><span class="line">            listenReceived();</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;Port opened.&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 关闭串口</span></span></span><br><span class="line"><span class="javascript">        btnClose.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (reading) &#123;</span><br><span class="line"><span class="javascript">                reading = <span class="literal">false</span>;</span></span><br><span class="line">                reader?.cancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 获取发送窗口十六进制字符串转换为字节数组</span></span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">getOutputData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> outputDatastr = iptOutput.value.replace(<span class="regexp">/\s+/g</span>, <span class="string">&quot;&quot;</span>); <span class="comment">// 去除所有空白字符</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (outputDatastr.length % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; <span class="regexp">/^[0-9a-fA-F]+$/</span>.test(outputDatastr)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 获取字节数组长度</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> byteLength = outputDatastr.length / <span class="number">2</span>;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 创建字节数组</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">const</span> outputData = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteLength);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 将字符串转成字节数组数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteLength; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    outputData[i] = <span class="built_in">parseInt</span>(outputDatastr.substr(i * <span class="number">2</span>, <span class="number">2</span>), <span class="number">16</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 返回数据</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span> outputData;</span></span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">throw</span> <span class="string">&quot;Data is not even or 0-9、a-f、A-F&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 发送数据</span></span></span><br><span class="line"><span class="javascript">        btnSend.onclick = <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> ((port === <span class="literal">null</span>) || (!port.writable)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&quot;Not opened.&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">return</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> writer = port.writable.getWriter();</span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> writer.write(getOutputData()); <span class="comment">// 发送数据</span></span></span><br><span class="line">            writer.releaseLock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面测试时我将串口的TX&#x2F;RT短接在一起，发送什么数据就会收到什么数据：</p><img src="/posts/3511617639/0256cd59c4a24e64aa50d9562bd40a80.gif" class="" title="在这里插入图片描述"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Web Serial API 访问串口非常方便，目前来说唯一的问题是这还是实验性质的功能，可能之后接口还会变动，需要根据实际情况进行调整。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/132522118">使用 Web Serial API 在浏览器中实现串口通讯（纯前端）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Web Serial网页串口</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/categories/Web/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="Web" scheme="https://zml3589110.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>全志F1C100s使用记录</title>
    <link href="https://zml3589110.github.io/posts/968082855.html"/>
    <id>https://zml3589110.github.io/posts/968082855.html</id>
    <published>2025-09-10T11:59:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料索引与基础说明"><a href="#资料索引与基础说明" class="headerlink" title="资料索引与基础说明"></a>资料索引与基础说明</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最早接触到F1C100s是前两年的一个文章，里面使用F1C100s制作了一张可以运行Linux的名片，就是下图这个。下图上实际电路部分就占用角落一点点面积，当时觉得蛮有意思的的，可以跑Linux的开发板可以做这么小，成本和常见单片机最小系统板差不多，用来玩挺有意思的。</p><img src="/posts/968082855/b51b5b133d25d5997d2a341c993397b5.png" class="" title="在这里插入图片描述"><p>在这里文章里了解到 Sipeed Lichee Nano （荔枝派Nano），这个差不多可以当作F1C100s的最小系统板板用了，某宝一搜一大片，当时价格还不错，这两年因为疫情等各种原因价格上涨不少。</p><img src="/posts/968082855/3d4704387a6e3e446f72b4c9251458a6.png" class="" title="在这里插入图片描述"><p>这篇文章将介绍下上手玩F1C100s需要的一些基础信息，方便回头查询使用。</p><h2 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h2><ul><li><strong>linux-sunxi community</strong><br><a href="https://linux-sunxi.org/Main_Page%E5%85%A8%E5%BF%97SoCs%E7%A4%BE%E5%8C%BAlinux">https://linux-sunxi.org/Main_Page全志SoCs社区linux</a> wiki，全志除了新出的基于RISC-V的D1，其它的芯片资料都是不开放的，mainlinux相关的开发都是由社区维护的，主要资料就是在这里；<br><strong>全志的芯片都以 <code>sunxi</code> 来指代，后面凡是看到 <code>sunxi</code> 或是 <code>sun\*</code> 的内容可能就是全志相关的内容；</strong>比如F1C100s就关联 <em>suniv</em> ；<br><a href="https://linux-sunxi.org/F1C100s">https://linux-sunxi.org/F1C100s</a><br>上面可以下载到F1C100s芯片的一些文档；</li><li><strong>WhyCan Forum(哇酷开发者社区)</strong><br><a href="https://whycan.com/index.html">https://whycan.com/index.html</a><br>这个论坛虽然嵌入式相关的内容都有涉及，但目前主要还是全志相关的内容多些；<br><a href="https://whycan.com/t_717.html">https://whycan.com/t_717.html</a><br>上面这篇文章中有很多F1C100s相关的例子资料等；<br><a href="https://whycan.com/t_3177.html">https://whycan.com/t_3177.html</a><br>F1C100s开发时的一个坑，编译工具链引起的问题；</li><li><strong>荔枝派Nano 全流程指南 与 资料下载</strong><br><a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a><br><a href="https://dl.sipeed.com/shareURL/LICHEE/Nano">https://dl.sipeed.com/shareURL/LICHEE/Nano</a></li><li><strong>My Business Card Runs Linux</strong><br><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/">https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a><br>这个就是开头说的那个可以运行Linux的名片的文章；</li></ul><h2 id="u-boot-amp-linux"><a href="#u-boot-amp-linux" class="headerlink" title="u-boot &amp; linux"></a>u-boot &amp; linux</h2><p>F1C100s玩的最多的就是拿来搞Linux玩，重要的是针对该芯片的uboot和linux的修改，这里收集了一些主要的项目：</p><p><strong>u-boot</strong></p><ul><li><a href="https://github.com/Icenowy/u-boot">https://github.com/Icenowy/u-boot</a><br>这个项目有 <em>f1c100s</em> 和 <em>f1c100s-spiflash</em> 两个分支，后者更加新点；<br>分支中有 <em>licheepi_nano_defconfig</em> 和 <em>licheepi_nano_spiflash_defconfig</em> 两个配置文件；</li><li><a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a><br>这个项目包含荔枝派所有的u-boot，对于F1C100s而言则是在前面项目的 f1c100s-spiflash 分支基础上新增了 <em>nano-lcd800480</em> 分支，增加了对lcd的支持；</li></ul><p><strong>linux</strong></p><ul><li><p><a href="https://github.com/Icenowy/linux">https://github.com/Icenowy/linux</a><br>这个项目主要查看 <em>f1c100s</em> 分支；</p></li><li><p><a href="https://github.com/Lichee-Pi/linux">https://github.com/Lichee-Pi/linux</a><br>这个项目目前主要查看 <em>nano-4.14-exp</em> 、 <em>nano-5.2-tf</em> 、 <em>nano-5.2-flash</em> 三个分支；<br><em>nano-4.14-exp</em> 分支是在前面项目的基础上修复了一个bug，这个分支可以下载<br><a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 这个配置文件进行测试；</p></li></ul><h2 id="基础特性"><a href="#基础特性" class="headerlink" title="基础特性"></a>基础特性</h2><p>F1C100s是全志的一颗比较便宜的芯片，其功能框图如下：</p><img src="/posts/968082855/7bf76defe2cb6abf7faeb95d27d9338c.png" class="" title="在这里插入图片描述"><p>典型应用如下：</p><img src="/posts/968082855/42ce2ee954569f4714c54cc5d205035e.png" class="" title="在这里插入图片描述"><ul><li><strong><code>F1C100s的内核是 ARM926EJ-S ，ARMv5架构，有MMU，没有硬件FPU，主频默认为408MHz；</code></strong></li><li><strong><code>F1C100s内置32MB DDR1内存；</code></strong></li><li><strong><code>F1C200s是F1C100s的兄弟型号，其它特性都相同，内存容量翻倍为64MB；</code></strong></li></ul><p>F1C100s和F1C200s价格便宜的时候可以在1~2刀左右，带有LCD、摄像头、音频、视频等接口，还内置几十兆内存，用来简单的点屏使用比单片机之类的好多了。所以经常可以看到用F1C100s来做行车记录仪或是复古游戏机等产品。</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>F1C100s的启动过程在它流出的手册中并没有找到相关描述，在 <em>全志V3s</em> 的 <em>DataSheet</em> 的 <em>4.2. Boot System</em> 章节中倒是有相似描述，可以作为参考：</p><img src="/posts/968082855/c0effa5c4bcc99fcb1419b633e545da2.png" class="" title="在这里插入图片描述"><p>芯片上电启动后，芯片会先执行内部固化的程序（BROM），该程序会依次检查外部存储器是否可用，如果可用再从中加载第二阶段程序（SPL）并执行。如果前面过程失败了则会进入全志系列处理器内置的FEL模式。</p><p><strong>对于F1C100s而言启动时寻找用户程序的位置顺序如下：</strong></p><ul><li>SDC0接口（<em>PF0~PF5</em>）上的SD（TF）卡；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nor Flash；</li><li>SPI0接口（<em>PC0~PC3</em>）上的Nand Flash；</li></ul><p><strong>对于SD（TF）卡而言在它上面的数据存储布局通常如下****：</strong></p><table><thead><tr><th>start</th><th>sector</th><th>size</th><th>usage</th></tr></thead><tbody><tr><td>0KB</td><td>0</td><td>8KB</td><td>Unused, available for an MBR or (limited) GPT partition table</td></tr><tr><td>8KB</td><td>16</td><td>32KB</td><td>Initial SPL loader</td></tr><tr><td>—-</td><td>—-</td><td>———</td><td>——————</td></tr><tr><td>40KB</td><td>80</td><td>Max 984KB</td><td>U-Boot</td></tr><tr><td>1MB</td><td>2048</td><td>-</td><td>bootfs and rootfs</td></tr></tbody></table><p>上面参数中SPL从8K位置开始不能动（这是由BROM决定的）；文件系统可以根据需要来分区，boot分区在前，通常为FAT格式。</p><p>如果使用上文列出的那些 u-boot 项目，编译后会得到 <strong>u-boot-sunxi-with-spl.bin</strong> 这个文件会拼合 spl 和 u-boot ，直接把这个文件写入到 8KB 开始的位置就行了。</p><p>更多内容可以参考：<a href="https://linux-sunxi.org/Bootable_SD_card">https://linux-sunxi.org/Bootable_SD_card</a></p><p><strong>对于SPI Flash</strong>而言其实和SD（TF）卡而言差不多，最关键的就是将 <em>u-boot-sunxi-with-spl.bin</em> 文件放在头部，即从0位置开始写入；其它内容根据需求而设置，只要对应的调整 u-boot 读取启动内核时相关位置参数就行。</p><p>需要注意的是默认情况下SPI Flash最大支持16M，更大就需要在程序中设置bank了。</p><h2 id="FEL模式"><a href="#FEL模式" class="headerlink" title="FEL模式"></a>FEL模式</h2><p>上文中可以了解到F1C100s要是启动外部程序均失败的话就会进入FEL模式，用户可以通过USB和芯片进行交互 。在FEL模式你可以直接运行 u-boot 和 linux 等，也可以将数据写入spiflash中（可以用作烧录固件到设备中）。</p><p>FEL模式其实也就是BROM上的一段程序，可以在 <code>u-boot</code> 命令行中使用 <code>go 0xffff0020</code> 跳转进入。另外也可以通过在SD（TF）卡写入下面数据来通过SD（TF）卡启动跳转：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sdX 为SD（TF）卡，使用 sudo fdisk -l 查看</span></span><br><span class="line"><span class="comment"># 如果有自动挂载的分区则逐条使用 sudo umount /dev/sdXn 进行卸载</span></span><br><span class="line">wget https://github.com/linux-sunxi/sunxi-tools/raw/master/bin/fel-sdboot.sunxi</span><br><span class="line">sudo dd <span class="keyword">if</span>=fel-sdboot.sunxi of=/dev/sdX bs=1024 seek=8</span><br></pre></td></tr></table></figure><p>如果外接了SPI Flash，并且SPI Flash中有可运行的程序的话可以将F1C100s的 <em>Pin60 - PC1 - SPI0_CS</em> 即 SPI Flash 的 1 脚接地后进入FEL模式。</p><p>为了和FEL模式下的芯片交互我们还需要用到 <em>sunxi-tools</em> 工具包，针对运行程序或烧录等操作需要用到其中的 <em>sunxi-fel</em> 工具，工具包项目地址如下：<br><a href="https://github.com/Icenowy/sunxi-tools">https://github.com/Icenowy/sunxi-tools</a></p><p>针对F1C100s的 <em>sunxi-fel</em> 工具可以使用下面方式下载、编译、安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-1.0-0-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make</span><br><span class="line"><span class="comment"># 编译完成后可以使用下面方式安装到系统目录</span></span><br><span class="line"><span class="comment"># sudo make install</span></span><br><span class="line"><span class="comment"># 不过其实不推荐安装到系统目录，因为全志不同的芯片需要用不同分支的sunxi-tools</span></span><br><span class="line"><span class="comment"># 更加推荐使用时临时添加环境目录，比如下面这样</span></span><br><span class="line"><span class="comment"># export PATH=$PATH:sunxi-tools目录路径</span></span><br><span class="line"><span class="comment"># 这种方式使用时需要用下面方式</span></span><br><span class="line"><span class="comment"># sudo `which sunxi-fel` [-选项] 命令 参数</span></span><br></pre></td></tr></table></figure><p>安装完成后可以使用 <code>sudo sunxi-fel -l</code> 列出所有处于FEL模式的设备、使用 <code>sudo sunxi-fel ver</code> 设备 BROM 信息：</p><img src="/posts/968082855/4914896309688605f6efd130124b559b.png" class="" title="在这里插入图片描述"><p>可以使用 <code>sudo sunxi-fel uboot /path/u-boot-sunxi-with-spl.bin</code> 来直接运行u-boot程序；</p><p>可以使用 <code>sudo sunxi-fel -p spiflash-write addr file</code> （addr常用0）将数据写入spiflash（注意最大16M，再大可能需要改程序）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./sunxi-fel [options] <span class="built_in">command</span> arguments... [<span class="built_in">command</span>...]</span><br><span class="line">        -v, --verbose                   Verbose logging</span><br><span class="line">        -p, --progress                  <span class="string">&quot;write&quot;</span> transfers show a progress bar</span><br><span class="line">        -l, --list                      Enumerate all (USB) FEL devices and <span class="built_in">exit</span></span><br><span class="line">        -d, --dev bus:devnum            Use specific USB bus and device number</span><br><span class="line">            --sid SID                   Select device by SID key (exact match)</span><br><span class="line"></span><br><span class="line">        spl file                        Load and execute U-Boot SPL</span><br><span class="line">                If file additionally contains a main U-Boot binary</span><br><span class="line">                (u-boot-sunxi-with-spl.bin), this <span class="built_in">command</span> also transfers that</span><br><span class="line">                to memory (default address from image), but won<span class="string">&#x27;t execute it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        uboot file-with-spl             like &quot;spl&quot;, but actually starts U-Boot</span></span><br><span class="line"><span class="string">                U-Boot execution will take place when the fel utility exits.</span></span><br><span class="line"><span class="string">                This allows combining &quot;uboot&quot; with further &quot;write&quot; commands</span></span><br><span class="line"><span class="string">                (to transfer other files needed for the boot).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        hex[dump] address length        Dumps memory region in hex</span></span><br><span class="line"><span class="string">        dump address length             Binary memory dump</span></span><br><span class="line"><span class="string">        exe[cute] address               Call function address</span></span><br><span class="line"><span class="string">        reset64 address                 RMR request for AArch64 warm boot</span></span><br><span class="line"><span class="string">        readl address                   Read 32-bit value from device memory</span></span><br><span class="line"><span class="string">        writel address value            Write 32-bit value to device memory</span></span><br><span class="line"><span class="string">        read address length file        Write memory contents into file</span></span><br><span class="line"><span class="string">        write address file              Store file contents into memory</span></span><br><span class="line"><span class="string">        write-with-progress addr file   &quot;write&quot; with progress bar</span></span><br><span class="line"><span class="string">        write-with-gauge addr file      Output progress for &quot;dialog --gauge&quot;</span></span><br><span class="line"><span class="string">        write-with-xgauge addr file     Extended gauge output (updates prompt)</span></span><br><span class="line"><span class="string">        multi[write] # addr file ...    &quot;write-with-progress&quot; multiple files,</span></span><br><span class="line"><span class="string">                                        sharing a common progress status</span></span><br><span class="line"><span class="string">        multi[write]-with-gauge ...     like their &quot;write-with-*&quot; counterpart,</span></span><br><span class="line"><span class="string">        multi[write]-with-xgauge ...      but following the &#x27;</span>multi<span class="string">&#x27; syntax:</span></span><br><span class="line"><span class="string">                                          &lt;#&gt; addr file [addr file [...]]</span></span><br><span class="line"><span class="string">        echo-gauge &quot;some text&quot;          Update prompt/caption for gauge output</span></span><br><span class="line"><span class="string">        ver[sion]                       Show BROM version</span></span><br><span class="line"><span class="string">        sid                             Retrieve and output 128-bit SID key</span></span><br><span class="line"><span class="string">        clear address length            Clear memory</span></span><br><span class="line"><span class="string">        fill address length value       Fill memory</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><p>对于Windows上装虚拟机来操作的话这之间还有一个坑：默认情况下FEL模式的USB设备Windows是无法识别的，这样就更没法传递给虚拟机使用了。这个问题可以使用 <a href="https://zadig.akeo.ie/">https://zadig.akeo.ie/</a> 这个工具来安装驱动解决（主要关注VID和PID就行）：</p><img src="/posts/968082855/d87e33cc9a73f2a6abb879e47a64a048.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/ac578738576c24cc2425ccc38f0d0748.png" class="" title="在这里插入图片描述"><p>除了 <em>sunxi-fel</em> ，也可以使用第三方的 <em>XFEL</em> 工具来进行FEL模式下的交互操作， <em>XFEL</em> 还有提供windows版本的可执行文件。项目地址如下：<br><a href="https://github.com/xboot/xfel">https://github.com/xboot/xfel</a></p><p>关于FEL模式的更多内容可以参考下面链接：<br><a href="https://linux-sunxi.org/FEL">https://linux-sunxi.org/FEL</a><br><a href="https://linux-sunxi.org/FEL/USBBoot">https://linux-sunxi.org/FEL/USBBoot</a></p><h2 id="电路设计"><a href="#电路设计" class="headerlink" title="电路设计"></a>电路设计</h2><p>电路设计上主要有下面一些注意点：</p><ul><li><strong>SD（TF）卡连接在SDC0</strong><br><code>Pin53 - PF5 - SDC0_D2</code><br><code>Pin54 - PF4 - SDC0_D3</code><br><code>Pin55 - PF3 - SDC0_CMD</code><br><code>Pin56 - PF2 - SDC0_CLK</code><br><code>Pin57 - PF1 - SDC0_D0</code><br><code>Pin58 - PF0 - SDC0_D1</code></li><li><strong>SPI Flash连接在SPI0</strong><br><code>Pin59 - PC0 - SPI0_CLK</code><br><code>Pin60 - PC1 - SPI0_CS</code><br><code>Pin61 - PC2 - SPI0_MISO</code><br><code>Pin62 - PC3 - SPI0_MOSI</code></li><li><strong>FEL模式通过USB通讯</strong><br><code>Pin68 - USB-DM</code><br><code>Pin69 - USB-DP</code></li><li><strong>控制台交互通过UART0</strong><br><code>Pin48 - PE1 - UART0_TX</code><br><code>Pin49 - PE0 - UART0_RX</code></li><li><strong>供电</strong><br><code>VCC-CORE - 1.0~1.2V</code><br><code>VCC-DRAM - 2.3~2.7V</code> <code>SVREF - 通过电阻将VCC-DRAM分压成一半</code><br><code>AVCC - 2.5~3.1V</code><br><code>VCC-IO / UVCC / HPVCC / TV_VCC - 2.5~3.1V</code></li></ul><p>电路设计上可以参考 荔枝派Nano 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/7bc367ee1b31ab3fc06a93c7b97acccf.png" class="" title="在这里插入图片描述"><p>如果对电路功能上没啥需求，只需要跑个Linux玩的话可以参考 Business Card 的原理图（可以点击查看大图）：</p><img src="/posts/968082855/231b714136edcf31d159cd2ecfbd7d67.png" class="" title="在这里插入图片描述"><h1 id="u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）"><a href="#u-boot-amp-linux-amp-rootfs-编译与烧录测试（基于SD卡）" class="headerlink" title="u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）"></a>u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</h1><h2 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h2><h3 id="硬件准备"><a href="#硬件准备" class="headerlink" title="硬件准备"></a>硬件准备</h3><p>测试用开发板可以参考上面文章中电路绘制，或者也可以直接购买荔枝派Nano进行测试。</p><img src="/posts/968082855/fff757aeb13d7b8676e87b0322bc8c83.png" class="" title="在这里插入图片描述"><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>下载安装Ubuntu Desktop（使用版本为20.04）：<br><a href="https://ubuntu.com/download/desktop">https://ubuntu.com/download/desktop</a></p><p>安装完成后进行基础环境安装与设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install -y build-essential</span><br><span class="line">sudo apt install -y libusb-1.0-0-dev zlib1g-dev</span><br><span class="line">sudo apt install -y pkg-config</span><br><span class="line">sudo apt install -y python python3 python-dev python3-dev</span><br><span class="line">sudo apt install -y swig</span><br><span class="line">sudo apt install -y libncurses-dev libncurses5-dev</span><br><span class="line">sudo apt install -y libssl-dev</span><br><span class="line">sudo apt install -y kpartx</span><br><span class="line">sudo apt install -y mtd-utils</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因为需要从GitHub下载项目所以还要安装git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y git</span><br><span class="line"><span class="comment"># git使用时可能需要设置用户名和邮箱</span></span><br><span class="line"><span class="comment"># git config --global user.name &quot;naisu&quot;</span></span><br><span class="line"><span class="comment"># git config --global user.email naisu@example.com</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>建立工作目录并进入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 本文将工作目录设置在用户目录（$HOME）下的f1c100s-sdk文件夹中</span></span><br><span class="line"><span class="comment"># cd ~</span></span><br><span class="line">mkdir f1c100s-sdk</span><br><span class="line"><span class="built_in">cd</span> f1c100s-sdk/ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="制作toolchain和rootfs"><a href="#制作toolchain和rootfs" class="headerlink" title="制作toolchain和rootfs"></a>制作toolchain和rootfs</h2><p>为了方便这里使用buildroot来制作rootfs，这里有个坑。这里如果使用linaro等组织提供的现成的交叉编译工具链来编译buildroot项目生成rootfs，在使用时系统启动过程中可能会出现 Kernel panic - not syncing: Attempted to kill init! exitcode&#x3D;0x0000000b ，而使用buildroot自己生成的编译工具链就不会出现这个问题了。所以我们这里统一使用buildroot生成的编译工具链。</p><p>下载、解压与配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">wget https://buildroot.org/downloads/buildroot-2022.02.tar.xz</span><br><span class="line">tar -xJf buildroot-2022.02.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入buildroot-2022.02目录</span></span><br><span class="line"><span class="built_in">cd</span> buildroot-2022.02/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 进行配置</span></span><br><span class="line"><span class="comment"># 这里做测试使用，只要配置下目标和工具链即可，详见后面截图</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/posts/968082855/8497be47fe917fc84b72e565f9bec9e2.png" class="" title="在这里插入图片描述"><img src="/posts/968082855/8935dd6dc710379acf7c9b4a3ef3da4e.png" class="" title="在这里插入图片描述"><p>编译完成后 <em>output</em> 目录下的 <em>host</em> 目录中就是交叉编译工具链（toolchain）； <em>output</em> 目录下的 <em>images</em> 目录中的 <em>rootfs.tar</em> 就是生成的根文件系统。</p><h3 id="设置编译工具链"><a href="#设置编译工具链" class="headerlink" title="设置编译工具链"></a>设置编译工具链</h3><p><strong>注意PATH使用自己的路径，每次打开终端都需要重新设置：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-buildroot-linux-gnueabi-</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/nx/f1c100s-sdk/buildroot-2022.02/output/host/bin</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="u-boot-amp-linux编译"><a href="#u-boot-amp-linux编译" class="headerlink" title="u-boot &amp; linux编译"></a>u-boot &amp; linux编译</h2><h3 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h3><p>下载、配置、编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-lcd800480 --depth=1 https://github.com/Lichee-Pi/u-boot.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入u-boot目录</span></span><br><span class="line"><span class="built_in">cd</span> u-boot/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载配置文件</span></span><br><span class="line">make licheepi_nano_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认bootcmd</span></span><br><span class="line">gedit include/configs/suniv.h</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONFIG_BOOTCOMMAND <span class="meta-string">&quot;run distro_bootcmd&quot;</span></span></span><br></pre></td></tr></table></figure><p>然后就可以编译了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译后当前目录下的 <em>u-boot-sunxi-with-spl.bin</em> 文件就是我们需要的。</p><h3 id="boot-scr"><a href="#boot-scr" class="headerlink" title="boot.scr"></a>boot.scr</h3><p>根据上面对bootcmd的修改，u-boot启动时会从第一分区读取 <em>boot.scr</em> 文件，并执行其中的脚本。我们可以通过这个来设置要传递给linux内核的参数、来加载内核和设备树、来启动内核。</p><p>在uboot目录下新建boot.cmd文件，向其中写入u-boot要执行的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">touch boot.cmd</span><br><span class="line">gedit boot.cmd</span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置传递给内核的bootargs参数</span></span><br><span class="line"><span class="comment"># 读取内核镜像和设备树到内存中指定位置</span></span><br><span class="line"><span class="comment"># 启动内核程序</span></span><br><span class="line">setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">load mmc 0:1 0x80008000 zImage</span><br><span class="line">load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">bootz 0x80008000 - 0x80C00000</span><br></pre></td></tr></table></figure><p>使用u-boot编译后tools目录下的 <em>mkimage</em> 工具可以将boot.cmd文件生成为 <em>boot.scr</em> 文件，通过下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># arm架构；不压缩；script文件；输入boot.cmd文件；输出boot.scr文件</span></span><br><span class="line">tools/mkimage -A arm -C none -T script -d boot.cmd boot.scr</span><br></pre></td></tr></table></figure><p>生成的 <em>boot.scr</em> 文件就在当前目录下。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line">git <span class="built_in">clone</span> -b nano-4.14-exp --depth=1 https://github.com/Lichee-Pi/linux.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入linux目录</span></span><br><span class="line"><span class="built_in">cd</span> linux/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载使用荔枝派Nano的linux配置文件</span></span><br><span class="line">wget https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</span><br><span class="line">cp config .config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据需要配置，没有需要的话直接按两下Esc保存退出</span></span><br><span class="line">make menuconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="comment"># 根据电脑配置使用make -jx等加快编译速度</span></span><br><span class="line"><span class="comment"># 过程中如果出现需要设置的选项全部选n</span></span><br><span class="line">make</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译后在 <em>arch&#x2F;arm&#x2F;boot&#x2F;</em> 目录下的 <em>zImage</em> 文件就是压缩后的内核程序；在 <em>arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;</em> 目录下的 <em>suniv-f1c100s-licheepi-nano.dtb</em> 或 <em>suniv-f1c100s-licheepi-nano-with-lcd.dtb</em> 文件就是编译后的设备树文件。</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>嵌入式linux开发最终是需要在系统上运行应用程序来实现特定的功能需求，这里编写个基础的应用程序用于测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 建立程序文件夹并进入</span></span><br><span class="line">mkdir helloworld</span><br><span class="line"><span class="built_in">cd</span> helloworld/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立程序文件并编写程序</span></span><br><span class="line">touch helloworld.c</span><br><span class="line">gedit helloworld.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译生成可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-buildroot-linux-gnueabi-gcc helloworld.c -o helloworld</span><br></pre></td></tr></table></figure><p>生成的 <em>helloworld</em> 就是我们需要的可执行文件了。</p><h2 id="文件烧录"><a href="#文件烧录" class="headerlink" title="文件烧录"></a>文件烧录</h2><p>前面编译生成的内容可以分块分别烧录进SD卡进行测试，也可以将 u-boot &amp; linux &amp; rootfs 整块打包烧录进SD卡进行测试，其实本质上是一样的，这里先进行分块测试的介绍，打包烧录介绍将在后面的章节说明。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先将SD卡插入Ubuntu中</span></span><br><span class="line"><span class="comment"># 使用 lsblk 查看SD卡设备号sdX</span></span><br><span class="line"><span class="comment"># 我这里显示为sdb，下面均以此进行说明</span></span><br></pre></td></tr></table></figure><h3 id="分区设置"><a href="#分区设置" class="headerlink" title="分区设置"></a>分区设置</h3><p>准备SD卡并按要求分区，空间划分参考本文开头的给出的文章，下面是在Ubuntu终端中进行分区划分示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果已经分过区了那么Ubuntu可能会自动挂载</span></span><br><span class="line"><span class="comment"># 逐条使用 sudo umount /dev/sdbn 进行卸载</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对SD（TF）卡进行分区</span></span><br><span class="line">sudo fdisk /dev/sdb</span><br><span class="line"><span class="comment"># 如果有分区的话可以输入 d 回车依次删除</span></span><br><span class="line"><span class="comment"># 输入 n 新建分区，分区大小根据需要设置即可</span></span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，输入使用 lsblk 查看分区情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/sdb1</span><br><span class="line">sudo mkfs.ext4 /dev/sdb2</span><br></pre></td></tr></table></figure><h3 id="分块烧录"><a href="#分块烧录" class="headerlink" title="分块烧录"></a>分块烧录</h3><p><strong>u-boot</strong><br><em>u-boot-sunxi-with-spl.bin</em> 文件需要放置在SD卡8k开始的位置上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot-sunxi-with-spl.bin  of=/dev/sdb bs=1024 seek=8</span><br></pre></td></tr></table></figure><p><strong>linux &amp; dtb &amp; boot.scr</strong><br>这三个放在刚才新建的第一个分区里（sdb1）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb1 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝linux和dtb</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/linux/</span></span><br><span class="line">sudo cp arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝boot.scr</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/u-boot/</span></span><br><span class="line">sudo cp boot.scr /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br></pre></td></tr></table></figure><p><strong>rootfs</strong><br>这个放在刚才新建的第二个分区里（sdb2）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压并拷贝rootfs</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/buildroot-2022.02/</span></span><br><span class="line">sudo tar -xf output/images/rootfs.tar -C /mnt/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br></pre></td></tr></table></figure><p><strong>测试程序</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"><span class="comment"># 将分区挂载到 /mnt</span></span><br><span class="line">sudo mount /dev/sdb2 /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝helloworld</span></span><br><span class="line"><span class="comment"># cd ~/f1c100s-sdk/helloworld/</span></span><br><span class="line">sudo cp helloworld /mnt/root/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存退出</span></span><br><span class="line"><span class="comment"># sync</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="上电测试"><a href="#上电测试" class="headerlink" title="上电测试"></a>上电测试</h2><p>上电打印信息与应用程序测试结果与关键日志如下：</p><p><em>默认通过UART0 PE0-RX PE1-TX 波特率115200</em><br><em>我这里使用的是F1C200s，所以内存显示为 64 MiB</em><br><em>前面生成的rootfs登陆用户名为root，无密码</em></p><img src="/posts/968082855/93e44242d33e3d5eee3579a3f39b0796.gif" class="" title="在这里插入图片描述"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-gd83b2fe-dirty (Mar 15 2022 - 15:52:58 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Lichee Pi Nano</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">mmc0 is current device</span><br><span class="line">Scanning mmc 0:1...</span><br><span class="line">Found U-Boot script /boot.scr</span><br><span class="line">reading /boot.scr</span><br><span class="line">279 bytes <span class="built_in">read</span> <span class="keyword">in</span> 14 ms (18.6 KiB/s)</span><br><span class="line"><span class="comment">## Executing script at 80c50000</span></span><br><span class="line">reading zImage</span><br><span class="line">3841152 bytes <span class="built_in">read</span> <span class="keyword">in</span> 200 ms (18.3 MiB/s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7464 bytes <span class="built_in">read</span> <span class="keyword">in</span> 25 ms (291 KiB/s)</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd27 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.14.0-licheepi-nano+ (nx@nx-ubuntu) (gcc version 10.3.0 (Buildroot 2022.02)) <span class="comment">#1 Tue Mar 15 16:07:52 CST 2022</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">[    1.331930] Waiting <span class="keyword">for</span> root device /dev/mmcblk0p2...</span><br><span class="line">[    1.375977] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.390277] mmc0: new high speed SDHC card at address aaaa</span><br><span class="line">[    1.396880] mmcblk0: mmc0:aaaa SC16G 14.8 GiB </span><br><span class="line">[    1.407742]  mmcblk0: p1 p2</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Starting syslogd: OK</span><br><span class="line">Starting klogd: OK</span><br><span class="line">Running sysctl: OK</span><br><span class="line"></span><br><span class="line">省略若干内容……</span><br><span class="line"></span><br><span class="line">Welcome to Buildroot</span><br><span class="line">buildroot login: root</span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">helloworld</span><br><span class="line"><span class="comment"># ./helloworld </span></span><br><span class="line">Hello, world!</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="系统镜像"><a href="#系统镜像" class="headerlink" title="系统镜像"></a>系统镜像</h2><p>前面分块烧录在测试的时候用用还行，但是如果是要批量生产或是交给他人使用就不方便了，这个时候可以制作系统成单个系统镜像文件来处理。</p><p>前面讲了对SD卡分区等操作，其实不管是分区还是数据拷贝等，最终在SD卡上无非就是一片按照一定顺序存储的数据。把这段数据原模原样的拷贝成一个文件，这就是系统镜像文件，使用的时候只要把这个文件内容拷贝到SD卡上就可以了。</p><h3 id="制作镜像文件"><a href="#制作镜像文件" class="headerlink" title="制作镜像文件"></a>制作镜像文件</h3><p><strong>从已有SD卡制作镜像文件</strong><br>如果有已经烧录完成所有内容的SD卡的话直接使用 dd 命令将SD卡内容复制到一个文件即可得到系统镜像文件。比如针对前面流程下的SD卡可以使用下面方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 将SD卡中有用的数据保存镜像文件中</span></span><br><span class="line"><span class="comment"># 大小为 1M(uboot) + 32M(bootfs) + 200M(rootfs) + 2M(多拷贝点，防止不明意外)</span></span><br><span class="line"><span class="comment"># 数据比较大会花点时间</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sdb of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>从编译生成的文件制作</strong><br>如果还没有烧录好的SD卡也可以直接从编译生成的文件制作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建系统镜像文件</span></span><br><span class="line">touch f1c100s-system-image.bin</span><br><span class="line"><span class="comment"># 向镜像文件写入空数据固定大小</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=f1c100s-system-image.bin bs=1M count=235</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的设备挂载点</span></span><br><span class="line">sudo losetup -f</span><br><span class="line"><span class="comment"># 我这里显示 /dev/loop13，接下来都以此进行说明</span></span><br><span class="line"><span class="comment"># 将镜像文件挂载到 /dev/loop13</span></span><br><span class="line">sudo losetup /dev/loop13 f1c100s-system-image.bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对挂载的设备进行分区</span></span><br><span class="line">sudo fdisk /dev/loop13</span><br><span class="line"><span class="comment"># 下面是我新建的两个分区的输入情况</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(1)  回车(2048)  +32M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># n回车  回车(p)  回车(2)  回车(67584) +200M回车  (如果有额外提示则Y回车)</span></span><br><span class="line"><span class="comment"># 接着 a回车 1回车 (将分区1设置为可启动)</span></span><br><span class="line"><span class="comment"># 输入 w 回车保存退出，会有点问题提示不用管</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新分区表</span></span><br><span class="line">sudo kpartx -av /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化分区建立文件系统</span></span><br><span class="line">sudo mkfs.vfat /dev/mapper/loop13p1</span><br><span class="line">sudo mkfs.ext4 /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第一个分区向里拷贝linux、dtb、boot.scr</span></span><br><span class="line">sudo mount /dev/mapper/loop13p1 /mnt</span><br><span class="line">sudo cp linux/arch/arm/boot/zImage /mnt/</span><br><span class="line">sudo cp linux/arch/arm/boot/dts/suniv-f1c100s-licheepi-nano.dtb /mnt/</span><br><span class="line">sudo cp u-boot/boot.scr /mnt/</span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载第二个分区向里解压并拷贝rootfs</span></span><br><span class="line">sudo mount /dev/mapper/loop13p2 /mnt</span><br><span class="line">sudo tar -xf buildroot-2022.02/output/images/rootfs.tar -C /mnt/</span><br><span class="line"><span class="comment"># 根据需求也可以拷贝应用程序进去</span></span><br><span class="line"><span class="comment"># sudo cp helloworld/helloworld /mnt/root/</span></span><br><span class="line">sync</span><br><span class="line">sudo umount /dev/mapper/loop13p2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载设备</span></span><br><span class="line">sudo kpartx -d /dev/loop13</span><br><span class="line">sudo losetup -d /dev/loop13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向头部写入uboot，注意conv=notrunc选项参数一定不能漏</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=u-boot/u-boot-sunxi-with-spl.bin  of=f1c100s-system-image.bin bs=1024 seek=8 conv=notrunc</span><br></pre></td></tr></table></figure><p><strong>压缩系统镜像</strong><br>前面生成的系统镜像比较大，不适合存储，可以对镜像镜像压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># 将系统镜像以zip方式镜像压缩</span></span><br><span class="line">zip f1c100s-system-image.zip f1c100s-system-image.bin</span><br></pre></td></tr></table></figure><h3 id="使用镜像文件"><a href="#使用镜像文件" class="headerlink" title="使用镜像文件"></a>使用镜像文件</h3><p><strong>在Linux上可以直接使用 *dd* 命令将镜像文件写入SD卡中</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd ~/f1c100s-sdk/</span></span><br><span class="line"><span class="comment"># rm f1c100s-system-image.bin</span></span><br><span class="line"><span class="comment"># 如果分区已挂载到别的地方先进行卸载</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb1</span></span><br><span class="line"><span class="comment"># sudo umount /dev/sdb2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压镜像文件压缩包</span></span><br><span class="line">unzip f1c100s-system-image.zip</span><br><span class="line"><span class="comment"># 将镜像文件写入SD卡，写入可能较慢</span></span><br><span class="line">sudo dd <span class="keyword">if</span>=f1c100s-system-image.bin of=/dev/sdb bs=1M</span><br></pre></td></tr></table></figure><p>当然我更加推荐使用工具来烧录，<strong>这里推荐使用 BalenaEtcher 工具</strong> ，这个工具支持windos、macos、linux，其官方页面和项目地址分别如下：<br><a href="https://www.balena.io/etcher/">https://www.balena.io/etcher/</a><br><a href="https://github.com/balena-io/etcher">https://github.com/balena-io/etcher</a><br>下面是用这个工具进行烧录的演示：</p><img src="/posts/968082855/3b2b282db96c566137f8554efdbcc6b5.gif" class="" title="在这里插入图片描述"><p>上面演示了使用BalenaEtcher工具进行烧录和启动测试，其中有两点值得注意的：</p><ul><li>原始的.bin后缀名的系统进行经过压缩后变得非常小（235MB &gt; 5.98MB），可见压缩非常有用；</li><li>BalenaEtcher可以直接使用压缩包进行烧录（比如我上面演示中）；</li></ul><h2 id="可能会遇到的问题"><a href="#可能会遇到的问题" class="headerlink" title="可能会遇到的问题"></a>可能会遇到的问题</h2><ul><li><strong>buildroot编译过程中下载文件慢</strong><br>buildroot编译过程中会下载很多文件，有可能会下着下着就不动了，或是下载缓慢。首先可以尝试使用 <code>ctrl + c</code> 终止当前工作后再 <code>make</code> ，会从终止的步骤重新开始；<br>如果上面的方式不行，那自行查看编译输出信息，其中有文件下载地址的，手动用下载工具进行下载，把下载的内容压缩包或解压后内容放到buildroot的 <code>dl</code> 目录下，然后重复前面步骤；</li><li><strong>编译过程中因为缺少文件报错</strong><br>百度、必应等查找Ubuntu下安装这些文件的方法；</li><li><strong>编译或使用中其它不明的问题</strong><br>使用 <code>make clean</code> 或者 <code>make distclean</code> 后重复配置编译过程；</li></ul><h2 id="SDK数据包"><a href="#SDK数据包" class="headerlink" title="SDK数据包"></a>SDK数据包</h2><p>鉴于整个过程中有很多东西需要下载，部分内容可能下载缓慢，所以将本文中出现的主要的几个项目内容进行了打包，方便将来使用。下载链接如下：</p><p>链接：<a href="https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g">https://pan.baidu.com/s/1BJPKuZJQmczxh82JJOGG_g</a><br>提取码：<code>ezrw</code></p><p>下载下来是个zip格式压缩包，解压后得到下面内容（Ubuntu上可以使用 unzip 进行解压）：</p><img src="/posts/968082855/f3eaf553ab39f4d46e3bed21d55995f2.png" class="" title="在这里插入图片描述"><p>各个文件说明如下：</p><table><thead><tr><th>文件</th><th>说明</th></tr></thead><tbody><tr><td>helloworld</td><td>内部含有helloworld.c文件</td></tr><tr><td>buildroot-2022.02.tar.xz</td><td>使用 wget <a href="https://buildroot.org/downloads/buildroot-2022.02.tar.xz">https://buildroot.org/downloads/buildroot-2022.02.tar.xz</a> 下载得到的压缩包</td></tr><tr><td>buildroot-2022.02-with-dl.tar.xz</td><td>根据上面项目 make menuconfig &gt; make &gt; make clean 后的文件夹进行重新打包压缩 其dl文件夹中包含了所有make时需要下载的东西</td></tr><tr><td>linux.tar.xz</td><td>使用 git clone -b nano-4.14-exp –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/linux.git">https://github.com/Lichee-Pi/linux.git</a> 下载 得到的linux文件夹中放入使用 wget <a href="https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config">https://dl.sipeed.com/fileList/LICHEE/Nano/SDK/config</a> 下载的config文件<br/>然后对linux文件夹重新打包</td></tr><tr><td>sunxi-tools.tar.xz</td><td>使用 git clone -b f1c100s-spiflash –depth&#x3D;1 <a href="https://github.com/Icenowy/sunxi-tools.git">https://github.com/Icenowy/sunxi-tools.git</a> 下载 得到的sunxi-tools文件夹重新打包</td></tr><tr><td>u-boot.tar.xz</td><td>使用 git clone -b nano-lcd800480 –depth&#x3D;1 <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> 下载 到的u-boot文件夹重新打包</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于现有的一些项目，详细记录 <em>u-boot &amp; linux &amp; rootfs 编译与烧录测试（ 基于SD卡）</em> 整个流程内容，可以作为进一步的移植、开发与使用的基础。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/Naisu_kun/article/details/122704052">资料索引与基础说明</a></li><li><a href="https://blog.csdn.net/Naisu_kun/article/details/123142958">u-boot &amp; linux &amp; rootfs 编译与烧录测试（基于SD卡）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">全志F1C100s使用记录</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="F1C100S" scheme="https://zml3589110.github.io/tags/F1C100S/"/>
    
  </entry>
  
  <entry>
    <title>ESP8266内置网页配置</title>
    <link href="https://zml3589110.github.io/posts/2546212267.html"/>
    <id>https://zml3589110.github.io/posts/2546212267.html</id>
    <published>2025-09-10T08:09:20.000Z</published>
    <updated>2025-09-10T13:10:14.324Z</updated>
    
    <content type="html"><![CDATA[<p>1、写入一个网页到FLASH指定位置：</p><p>（1）找到可以放置网页的位置；扇区：4KBytes-0x001000</p><p>ESP8266-01:FLASH:25Q80&#x3D;8Mbits&#x3D;1MBytes&#x3D;0x100000: 256扇区</p><p>eagle.flash.bin——————————————–0x000000: 0扇区—–64KBytes</p><p>eagle.irom0text.bin————————————–0x010000: 16扇区—-944KBytes</p><p>esp_init_data_default_v05.bin———————–0x0FC000: 252扇区</p><p>blank.bin—————————————————0x0FE000: 254扇区</p><p>FLASH中前64K为系统程序1，紧接着是系统程序2，倒数4个扇区（16KBytes）中为系统参数区。<br>用户可用区域在系统程序2与系统参数区中间部分，<br>至于从何扇区开始，到何处结束，则由前后扇区内容决定。在ld-&gt;eagle.app.v6.ld中可以查看各区域设置的长度，<br>其中最后一项是irom0_0_seg-&gt;len即为eagle.irom0text.bin的允许长度。由此可以计算出用户可用区域的起始结束地址</p><img src="/posts/2546212267/34f8765cbe2ed465be5ed6dd8770a434.png" class="" title="img"><p>eagle.irom0text.bin—0x010000—0x06C000: 0x05C000</p><p>因此用户可用区域为: 0x06C000—0x0FC000: 576KBytes: 144扇区</p><p>（2）放入写好的网页，读取出来看看数据是否写入正确；</p><p>使用ESP8266烧写工具在指定位置放入一个WEB页面，利用OS_printf输出到串口助手查看。</p><p>新建一个login.html ；注意格式一定要是UTF-8，否则在页面开头有乱码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>LOGIN<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>;<span class="attribute">width</span>:<span class="number">500px</span>;<span class="attribute">height</span>:<span class="number">80px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.log</span>&#123;<span class="attribute">font-size</span>:<span class="number">80px</span>;<span class="attribute">width</span>:<span class="number">400px</span>;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.dx</span>&#123;<span class="attribute">font-size</span>:<span class="number">60px</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;dx&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&#x27;post&#x27;</span> <span class="attr">action</span>=<span class="string">&#x27;Login.cgi&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">登录WIFI设置界面</span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">UserName:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;NAME&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"> PassWord:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;text&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">id</span>=<span class="string">&#x27;PWD&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;submit&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;log&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;登录&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;NAME&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;PWD&#x27;</span>).value=<span class="string">&#x27;admin&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">center</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在ESP8266测试代码中，读取出FLASH里的数据，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char ch[1000];</span><br><span class="line">os_printf(<span class="string">&quot;login.page!\n&quot;</span>);</span><br><span class="line">spi_flash_read(0x6C000, (uint32 *)&amp;ch, 654);</span><br><span class="line">ch[655] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">os_printf(<span class="string">&quot;%s&quot;</span>, ch);</span><br><span class="line">os_printf(<span class="string">&quot;\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>在串口助手中可以看到输出结果，如果文件格式不是UTF-8，则串口助手输出的中文就会是乱码。如果页面代码中有错误码，也能查出来。同时修改上面的数字大小也能测出页面包含的字节数。这个字节数会用于页面的发送。测试结果</p><p>可以看出数据没有问题，保证了在FLASH中的页面数据没有问题。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/105232494">ESP8266学习-内置网页配置（一）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP8266内置网页配置</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/tags/ESP8266/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
  </entry>
  
  <entry>
    <title>自制F1C200S demo板</title>
    <link href="https://zml3589110.github.io/posts/2989473239.html"/>
    <id>https://zml3589110.github.io/posts/2989473239.html</id>
    <published>2025-09-10T07:51:20.000Z</published>
    <updated>2025-09-10T13:10:14.356Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、电路"><a href="#一、电路" class="headerlink" title="一、电路"></a>一、电路</h1><ul><li>具备FLASH下载，TF卡座，摄像头，LCD，MIC，UART等</li></ul><h2 id="一、原理图：如需PDF源文件可到资源下载。"><a href="#一、原理图：如需PDF源文件可到资源下载。" class="headerlink" title="一、原理图：如需PDF源文件可到资源下载。"></a>一、原理图：如需PDF源文件可到资源下载。</h2><p><a href="https://oshwhub.com/AI_QY/f1c100s_1">原理图资料</a></p><img src="/posts/2989473239/a5e8331f42cc6551eac8403725716d39.png" class="" title="img"><img src="/posts/2989473239/4b63a90eafd334ce1bf724bddb06b89b.png" class="" title="img"><h2 id="二、电路：如需PDF源文件可到资源下载。"><a href="#二、电路：如需PDF源文件可到资源下载。" class="headerlink" title="二、电路：如需PDF源文件可到资源下载。"></a>二、电路：如需PDF源文件可到资源下载。</h2><img src="/posts/2989473239/1cf8dfb59ba44ccc0a63ab7bb516d98a.png" class="" title="img"><img src="/posts/2989473239/f4dd572283b5db780ac8b8f2ed37cda7.png" class="" title="img"><h2 id="三、实物"><a href="#三、实物" class="headerlink" title="三、实物"></a>三、实物</h2><img src="/posts/2989473239/387da10619629c5bdc3f5e86ba60fb18.png" class="" title="img"><img src="/posts/2989473239/5868d90b3567d2b1c7df1b6916d638ae.png" class="" title="img"><h1 id="二、Win上测试"><a href="#二、Win上测试" class="headerlink" title="二、Win上测试"></a>二、Win上测试</h1><p>此次测试的目的是尝试使用USB给NorFlash烧录镜像。</p><h2 id="1、安装USB驱动。使用的操作系统是win8。"><a href="#1、安装USB驱动。使用的操作系统是win8。" class="headerlink" title="1、安装USB驱动。使用的操作系统是win8。"></a>1、安装USB驱动。使用的操作系统是win8。</h2><p>在网上下载zadig-2.3.exe。接入设备后，会产生未知设备。然后进行如图操作即可。</p><img src="/posts/2989473239/ceb654f5e3cc3026636ea6cc177cee5c.png" class="" title="img"><h2 id="2、使硬件进入fel模式。"><a href="#2、使硬件进入fel模式。" class="headerlink" title="2、使硬件进入fel模式。"></a>2、使硬件进入fel模式。</h2><p>在FLASH和TF卡都没有系统或为空时，插电即可进入fel模式。如果没有进入，则</p><p>若FLASH中有系统，需通过：短接FLASH芯片的1、4两脚，即按住开发板上boot按键，重新拔插USB或电源开关重新开关一次，即可进入fel模式。</p><h2 id="3、刷机"><a href="#3、刷机" class="headerlink" title="3、刷机"></a>3、刷机</h2><ul><li>(1)、在网上下载或我的资源包中下载，用与在windows下刷机的工具。解压到某个文件下。</li></ul><img src="/posts/2989473239/78da5325456f9e0a5952c4c5e4af00b4.png" class="" title="img"><ul><li>(2)、使用win+R或其他方式打开windows命令行窗口</li></ul><p> 首先进入到刷机工具目录：cd C:\Users\Administrator\Downloads\刷机\sunxi-tools-win32_f1_flash</p><p>  查看信息：sunxi-fel.exe ver。我是用的是F1C100S的镜像，也可以驱动F1C200S。</p><p>  查看SPIFLASH信息：sunxi-fel.exe spiflash-info。我的demo板上使用的是32MFLASH，尽管镜像使用的是16MFLASH，也可以进行驱动，理论上只会无法访问后半段FLASH。</p><p>  烧录镜像：sunxi-fel.exe -p spiflash-write 0 sysimage-nor.img 100%。这里我将sysimge-nor.img文件拷贝到sunxi-tools-win32_f1_flash文件夹内。</p><img src="/posts/2989473239/56b6f108417cbc7c297081a304e74b5d.png" class="" title="img"><h2 id="4、运行结果"><a href="#4、运行结果" class="headerlink" title="4、运行结果"></a>4、运行结果</h2><img src="/posts/2989473239/6e49e6c1f8b30c484152108a60c231b1.png" class="" title="img"><h1 id="三、Linux上测试"><a href="#三、Linux上测试" class="headerlink" title="三、Linux上测试"></a>三、Linux上测试</h1><p>原思路即是在Linux系统下，对SPIFLASH进行烧录测试，但遇到了一些问题，导致Linux虚拟机无法识别到该设备。进而产生了上一文档的windows下烧录测试。通过在Windows下烧录测试，也验证了设备烧录、测试、各个文件均没有问题。</p><p>主要导致在Linux下无法测试的问题是：Vbox无法筛选USB设备，导致Linux虚拟机加载不到开发板。</p><p>正确过程：</p><h2 id="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"><a href="#1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN" class="headerlink" title="1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN"></a>1、要使windows能正确安装设备驱动。按照上一章文档进行CSDN</h2><h2 id="2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html"><a href="#2、在Vbox里添加增强功能。按照某度经验进行https-jingyan-baidu-com-article-22a299b5e0198a9e19376a38-html" class="headerlink" title="2、在Vbox里添加增强功能。按照某度经验进行https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html"></a>2、在Vbox里添加增强功能。按照某度经验进行<a href="https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html">https://jingyan.baidu.com/article/22a299b5e0198a9e19376a38.html</a></h2><h2 id="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"><a href="#3、增强功能安装后，添加筛选器。我这里使用的手动添加。" class="headerlink" title="3、增强功能安装后，添加筛选器。我这里使用的手动添加。"></a>3、增强功能安装后，添加筛选器。我这里使用的手动添加。</h2><img src="/posts/2989473239/90387ee3726d69a3b29bbe5199f51246.png" class="" title="img"><p>筛选参数按照window系统中驱动信息进行填写。</p><img src="/posts/2989473239/c9aa769a65e154ab6c169874bb7b1a87.png" class="" title="img"><img src="/posts/2989473239/3b9ea6465b78d60106599a3b835fd03d.png" class="" title="img"><h2 id="4、打开Linux虚拟机后，进入到命令行模式。"><a href="#4、打开Linux虚拟机后，进入到命令行模式。" class="headerlink" title="4、打开Linux虚拟机后，进入到命令行模式。"></a>4、打开Linux虚拟机后，进入到命令行模式。</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br><span class="line">sudo apt install libz libusb-1.0-0-dev</span><br><span class="line">make &amp;&amp; sudo make install</span><br><span class="line">sudo sunxi-fel ver</span><br><span class="line">输出信息：</span><br><span class="line"><span class="string">&quot;AWUSBFEX soc=00001663(F1C100s) 00000001 ver=0001 44 08 scratchpad=00007e00 00000000 00000000&quot;</span></span><br><span class="line">sudo sunxi-fel -l</span><br><span class="line">sudo sunxi-fel -p spiflash-write 0 u-boot-sunxi-with-spl.bin</span><br></pre></td></tr></table></figure><p>  查看支持的芯片：sudo sunxi-fel -l。</p><p>  查看开发板信息：sudo sunxi-fel ver。</p><p>  查看SPIFLASH信息：sudo sunxi-fel spiflash-info。</p><p>  烧录镜像到SPIFLASH：sudo sunxi-fel -p spiflash-write 0 Nano_flash_800480.bin 100%。这里使用的是荔枝派的Nano的FLASH。</p><img src="/posts/2989473239/f5874d781e692131970602d2112159f9.png" class="" title="img"><img src="/posts/2989473239/703b2a3d086d8ecdbbaf9ccd795f5760.png" class="" title="img"><h2 id="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"><a href="#5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。" class="headerlink" title="5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。"></a>5、显示正常，使用串口调试助手能看到有效信息。表示操作无误。</h2><img src="/posts/2989473239/3748a8399b66fad40291531b2f1c688b.png" class="" title="img"><h1 id="四、TF卡启动"><a href="#四、TF卡启动" class="headerlink" title="四、TF卡启动"></a>四、TF卡启动</h1><p>思来想去，发现使用SIPFLASH也不是百分百完美，也终于明白为何最小demo板要首推TF卡启动了。</p><p>主要是现在想学Linux驱动，但使用SPIFLASH就需要用uboot和kernel两个同时打包为一个镜像，这样编译和打包都会影响速度。使用TF卡，就可以把三个板块分开，单独操作而互不干扰。</p><p>这里操作步骤需要摸清楚：1、uboot获取，编译，烧录。2、kernel获取，编译，烧录。3、文件系统搭建。</p><p>获取uboot：git clone <a href="https://github.com/Lichee-Pi/u-boot">https://github.com/Lichee-Pi/u-boot</a> -b nano-v2018.01&amp;&amp;cd u-boot</p><p>获取时出现的问题：从网上别人博客里是：git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01&amp;&amp;cd u-boot，发现获取不到。</p><p>解决方法：去掉.git后获取正常。</p><p>编译uboot：make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- licheepi_nano_defconfig</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><p>编译时出现的问题：make: arm-linux-gnueabi-gcc: Command not found。</p><p>解决方法：sudo apt install gcc-arm-linux-gnueabi。</p><p>编译时出现的问题：unable to execute ‘swig’: No such file or directory。</p><p>解决方法：sudo apt install swig。</p><p>编译时出现的问题：scripts&#x2F;dtc&#x2F;pylibfdt&#x2F;libfdt_wrap.c:149:11: fatal error: Python.h: 没有那个文件或目录。</p><p>解决方法：1、查看版本：python -V，2、获取对应文件：sudo apt install python2.7-dev。（这里的2.7要修改为和查看的版本相匹配）</p><p>烧录uboot：sudo dd if&#x3D;u-boot-tf.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</p><p>sudo cp suniv-f1c100s-licheepi-nano.dtb &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝镜像文件：sudo cp tf-zImage &#x2F;media&#x2F;one&#x2F;UBOOT&#x2F;</p><p>拷贝文件系统：sudo tar -xvf rootfs-tf.tar.gz -C &#x2F;media&#x2F;one&#x2F;rootfs&#x2F;</p><p>需要将TF卡分成两个区：uboot fat16 64M 和 rootfs ext4 (TF卡剩余所有空间）。</p><p>查看磁盘：sudo fdisk -l  和 查看挂载：df|grep sd</p><p>以上烧录使用的是Lichee-pi-nano的标准文件，并未使用我编译的文件，可以正常运行，输出启动参数。</p><p>经过测试，当SPIFLASH和TF卡里都有系统时，优先运行TF卡中系统。</p><p>在2021年9月16日，终于指导了uboot和Linux等的关联和基本操作了。虽然前面都在串口调试助手上显示了启动信息，但仔细查看，始终没看到运行kernel。今天终于搞明白了，这三大板块放到TF卡中应该正确操作的流程了。</p><p>开机后，串口调试助手上会输出信息，但仅仅是输出uboot的信息，会停留在uboot的命令行。需要在这里使用命令行，配置kernel引导参数，从而执行Linux。</p><p>也可以按照<a href="http://nano.lichee.pro/build_sys/bootargs.html">uboot传递参数 — 荔枝派Nano 全流程指南 documentation</a> 生成一个boot.scr文件，复制到TF卡的第一分区，就能自动运行LINUX，无需再再串口调试助手中输入这些指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br></pre></td><td class="code"><pre><span class="line">以下是串口调试助手完整输出信息，红色部分则是要人为发送的启动信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.143] RX：</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.311] RX：</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd (Sep 03 2021 - 09:23:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.842] RX：MMC:   SUNXI SD/MMC: 0</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:07.918] RX：*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[2021-09-16 12:03:08.942] RX： 1 </span><br><span class="line">[2021-09-16 12:03:09.943] RX： 0 </span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.006] RX：switch to partitions <span class="comment">#0, OK</span></span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.556] RX：Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.705] RX：reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:10.773] RX：starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue <span class="string">&#x27;usb start&#x27;</span> first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:12.310] TX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:12.313] RX：setenv bootargs console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:13.539] TX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:13.544] RX：load mmc 0:1 0x80C00000 suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">7583 bytes <span class="built_in">read</span> <span class="keyword">in</span> 21 ms (352.5 KiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:15.421] TX：load mmc 0:1 0x80008000 zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.424] RX：load mmc 0:1 0x80008000 zImage</span><br><span class="line">reading zImage</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:15.635] RX：3838016 bytes <span class="built_in">read</span> <span class="keyword">in</span> 194 ms (18.9 MiB/s)</span><br><span class="line">=&gt; </span><br><span class="line">=&gt; 人为发送的启动信息</span><br><span class="line">[2021-09-16 12:03:17.540] TX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:17.543] RX：bootz 0x80008000 - 0x80C00000</span><br><span class="line"><span class="comment">## Flattened Device Tree blob at 80c00000</span></span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ffd9e ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:18.737] RX：[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 4.15.0-rc8-licheepi-nano+ (one@one-VirtualBox) (gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04)) <span class="comment">#1 Tue Sep 14 17:09:09 CST 2021</span></span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: Lichee Pi Nano</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] random: fast init <span class="keyword">done</span></span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 16256</span><br><span class="line">[    0.000000] Kernel <span class="built_in">command</span> line: console=tty0 console=ttyS0,115200 panic=5 rootwait root=/dev/mmcblk0p2 rw</span><br><span class="line">[    0.000000] Dentry cache <span class="built_in">hash</span> table entries: 8192 (order: 3, 32768 bytes)</span><br><span class="line">[    0.000000] Inode-cache <span class="built_in">hash</span> table entries: 4096 (order: 2, 16384 bytes)</span><br><span class="line">[    0.000000] Memory: 55172K/65536K available (6144K kernel code, 236K rwdata, 1388K rodata, 1024K init, 244K bss, 10364K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] Virtual kernel memory layout:</span><br><span class="line">[    0.000000]     vector  : 0xffff0000 - 0xffff1000   (   4 kB)</span><br><span class="line">[    0.000000]     fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)</span><br><span class="line">[    0.000000]     vmalloc : 0xc4800000 - 0xff800000   ( 944 MB)</span><br><span class="line">[    0.000000]     lowmem  : 0xc0000000 - 0xc4000000   (  64 MB)</span><br><span class="line">[    0.000000]     pkmap   : 0xbfe00000 - 0xc0000000   (   2 MB)</span><br><span class="line">[    0.000000]     modules : 0xbf000000 - 0xbfe00000   (  14 MB)</span><br><span class="line">[    0.000000]       .text : 0x(ptrval) - 0x(ptrval)   (7136 kB)</span><br><span class="line">[    0.000000]       .init : 0x(ptrval) - 0x(ptrval)   (1024 kB)</span><br><span class="line">[    0.000000]       .data : 0x(ptrval) - 0x(ptrval)   ( 237 kB)</span><br><span class="line">[    0.000000]        .bss : 0x(ptrval) - 0x(ptrval)   ( 245 kB)</span><br><span class="line">[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1</span><br><span class="line">[    0.000000] NR_IRQS: 16, nr_irqs: 16, preallocated irqs: 16</span><br><span class="line">[    0.000044] sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 89478484971ns</span><br><span class="line">[    0.000107] clocksource: timer: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635851949 ns</span><br><span class="line">[    0.000634] Console: colour dummy device 80x30</span><br><span class="line">[    0.001547] console [tty0] enabled</span><br><span class="line">[    0.001649] Calibrating delay loop... 203.16 BogoMIPS (lpj=1015808)</span><br><span class="line">[    0.070270] pid_max: default: 32768 minimum: 301</span><br><span class="line">[    0.070605] Mount-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.070691] Mountpoint-cache <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.072128] CPU: Testing write buffer coherency: ok</span><br><span class="line">[    0.073790] Setting up static identity map <span class="keyword">for</span> 0x80100000 - 0x80100058</span><br><span class="line">[    0.076353] devtmpfs: initialized</span><br><span class="line">[    0.082594] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns</span><br><span class="line">[    0.082753] futex <span class="built_in">hash</span> table entries: 256 (order: -1, 3072 bytes)</span><br><span class="line">[    0.083054] pinctrl core: initialized pinctrl subsystem</span><br><span class="line">[    0.085012] NET: Registered protocol family 16</span><br><span class="line">[    0.086414] DMA: preallocated 256 KiB pool <span class="keyword">for</span> atomic coherent allocations</span><br><span class="line">[    0.088228] cpuidle: using governor menu</span><br><span class="line">[    0.112653] SCSI subsystem initialized</span><br><span class="line">[    0.113054] usbcore: registered new interface driver usbfs</span><br><span class="line">[    0.113256] usbcore: registered new interface driver hub</span><br><span class="line">[    0.113505] usbcore: registered new device driver usb</span><br><span class="line">[    0.113994] pps_core: LinuxPPS API ver. 1 registered</span><br><span class="line">[    0.114073] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;</span><br><span class="line">[    0.114196] PTP clock support registered</span><br><span class="line">[    0.114675] Advanced Linux Sound Architecture Driver Initialized.</span><br><span class="line">[    0.116219] clocksource: Switched to clocksource timer</span><br><span class="line">[    0.141314] NET: Registered protocol family 2</span><br><span class="line">[    0.142762] TCP established <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.142912] TCP <span class="built_in">bind</span> <span class="built_in">hash</span> table entries: 1024 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143002] TCP: Hash tables configured (established 1024 <span class="built_in">bind</span> 1024)</span><br><span class="line">[    0.143302] UDP <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143408] UDP-Lite <span class="built_in">hash</span> table entries: 256 (order: 0, 4096 bytes)</span><br><span class="line">[    0.143903] NET: Registered protocol family 1</span><br><span class="line">[    0.145154] RPC: Registered named UNIX socket transport module.</span><br><span class="line">[    0.145261] RPC: Registered udp transport module.</span><br><span class="line">[    0.145309] RPC: Registered tcp transport module.</span><br><span class="line">[    0.145352] RPC: Registered tcp NFSv4.1 backchannel transport module.</span><br><span class="line">[    0.147636] NetWinder Floating Point Emulator V0.97 (double precision)</span><br><span class="line">[    0.149450] Initialise system trusted keyrings</span><br><span class="line">[    0.150062] workingset: timestamp_bits=30 max_order=14 bucket_order=0</span><br><span class="line">[    0.167180] NFS: Registering the id_resolver key <span class="built_in">type</span></span><br><span class="line">[    0.167334] Key <span class="built_in">type</span> id_resolver registered</span><br><span class="line">[    0.167393] Key <span class="built_in">type</span> id_legacy registered</span><br><span class="line">[    0.180354] Key <span class="built_in">type</span> asymmetric registered</span><br><span class="line">[    0.180460] Asymmetric key parser <span class="string">&#x27;x509&#x27;</span> registered</span><br><span class="line">[    0.180692] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 251)</span><br><span class="line">[    0.180785] io scheduler noop registered</span><br><span class="line">[    0.180833] io scheduler deadline registered</span><br><span class="line">[    0.181596] io scheduler cfq registered (default)</span><br><span class="line">[    0.181690] io scheduler mq-deadline registered</span><br><span class="line">[    0.181743] io scheduler kyber registered</span><br><span class="line">[    0.182841] sun4i-usb-phy 1c13400.phy: Couldn<span class="string">&#x27;t request ID GPIO</span></span><br><span class="line"><span class="string">[    0.192424] suniv-pinctrl 1c20800.pinctrl: initialized sunXi PIO driver</span></span><br><span class="line"><span class="string">[    0.354497] Serial: 8250/16550 driver, 8 ports, IRQ sharing disabled</span></span><br><span class="line"><span class="string">[    0.361118] console [ttyS0] disabled</span></span><br><span class="line"><span class="string">[    0.381429] 1c25000.serial: ttyS0 at MMIO 0x1c25000 (irq = 23, base_baud = 6250000) is a 16550A</span></span><br><span class="line"><span class="string">[    0.852908] console [ttyS0] enabled</span></span><br><span class="line"><span class="string">[    0.863244] panel-simple panel: panel supply power not found, using dummy regulator</span></span><br><span class="line"><span class="string">[    0.872677] SCSI Media Changer driver v0.25 </span></span><br><span class="line"><span class="string">[    0.880398] m25p80 spi0.0: found w25q256, expected w25q128</span></span><br><span class="line"><span class="string">[    0.886477] m25p80 spi0.0: w25q256 (32768 Kbytes)</span></span><br><span class="line"><span class="string">[    0.893635] ehci_hcd: USB 2.0 &#x27;</span>Enhanced<span class="string">&#x27; Host Controller (EHCI) Driver</span></span><br><span class="line"><span class="string">[    0.900355] ehci-platform: EHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.905917] ohci_hcd: USB 1.1 &#x27;</span>Open<span class="string">&#x27; Host Controller (OHCI) Driver</span></span><br><span class="line"><span class="string">[    0.912272] ohci-platform: OHCI generic platform driver</span></span><br><span class="line"><span class="string">[    0.918003] usbcore: registered new interface driver usb-storage</span></span><br><span class="line"><span class="string">[    0.924980] udc-core: couldn&#x27;</span>t find an available UDC - added [g_cdc] to list of pending drivers</span><br><span class="line">[    0.934113] i2c /dev entries driver</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.352] RX：[    0.996353] sunxi-mmc 1c0f000.mmc: base:0x0db647ea irq:19</span><br><span class="line">[    1.003836] usbcore: registered new interface driver usbhid</span><br><span class="line">[    1.009596] usbhid: USB HID core driver</span><br><span class="line">[    1.031128] NET: Registered protocol family 17</span><br><span class="line">[    1.035884] Key <span class="built_in">type</span> dns_resolver registered</span><br><span class="line">[    1.042602] Loading compiled-in X.509 certificates</span><br><span class="line">[    1.058564] sun4i-drm display-engine: bound 1e60000.display-backend (ops 0xc0739498)</span><br><span class="line">[    1.067512] sun4i-drm display-engine: bound 1c0c000.lcd-controller (ops 0xc073877c)</span><br><span class="line">[    1.075259] [drm] Supports vblank timestamp caching Rev 2 (21.10.2013).</span><br><span class="line">[    1.082015] [drm] No driver support <span class="keyword">for</span> vblank timestamp query.</span><br><span class="line"></span><br><span class="line">[2021-09-16 12:03:19.511] RX：[    1.138455] Console: switching to colour frame buffer device 60x34</span><br><span class="line">[    1.140705] mmc0: host does not support reading read-only switch, assuming write-enable</span><br><span class="line">[    1.142989] mmc0: new high speed SDHC card at address 59b4</span><br><span class="line">[    1.144075] mmcblk0: mmc0:59b4 SD    15.0 GiB </span><br><span class="line">[    1.146386]  mmcblk0: p1 p2</span><br><span class="line">[    1.208313] sun4i-drm display-engine: fb0:  frame buffer device</span><br><span class="line">[    1.227575] [drm] Initialized sun4i-drm 1.0.0 20150629 <span class="keyword">for</span> display-engine on minor 0</span><br><span class="line">[    1.249110] usb_phy_generic usb_phy_generic.0.auto: usb_phy_generic.0.auto supply vcc not found, using dummy regulator</span><br><span class="line">[    1.279822] musb-hdrc musb-hdrc.1.auto: MUSB HDRC host driver</span><br><span class="line">[    1.298514] musb-hdrc musb-hdrc.1.auto: new USB bus registered, assigned bus number 1</span><br><span class="line">[    1.321574] hub 1-0:1.0: USB hub found</span><br><span class="line">[    1.332130] hub 1-0:1.0: 1 port detected</span><br><span class="line">[    1.344233] using random self ethernet address</span><br><span class="line">[    1.355304] using random host ethernet address</span><br><span class="line">[    1.367912] usb0: HOST MAC 96:a7:62:ad:40:54</span><br><span class="line">[    1.378730] usb0: MAC 32:68:5e:ee:7c:4e</span><br><span class="line">[    1.389004] g_cdc gadget: CDC Composite Gadget, version: King Kamehameha Day 2008</span><br><span class="line">[    1.408933] g_cdc gadget: g_cdc ready</span><br><span class="line">[    1.419690] cfg80211: Loading compiled-in X.509 certificates <span class="keyword">for</span> regulatory database</span><br><span class="line">[    1.449709] cfg80211: Loaded X.509 cert <span class="string">&#x27;sforshee: 00b28ddf47aef9cea7&#x27;</span></span><br><span class="line">[    1.468828] ALSA device list:</span><br><span class="line">[    1.478044]   <span class="comment">#0: Loopback 1</span></span><br><span class="line">[    1.487901] platform regulatory.0: Direct firmware load <span class="keyword">for</span> regulatory.db failed with error -2</span><br><span class="line">[    1.508671] cfg80211: failed to load regulatory.db</span><br><span class="line">[    1.521906] EXT4-fs (mmcblk0p2): couldn<span class="string">&#x27;t mount as ext3 due to feature incompatibilities</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.009] RX：[    1.653047] EXT4-fs (mmcblk0p2): recovery complete</span></span><br><span class="line"><span class="string">[    1.669691] EXT4-fs (mmcblk0p2): mounted filesystem with ordered data mode. Opts: (null)</span></span><br><span class="line"><span class="string">[    1.690011] VFS: Mounted root (ext4 filesystem) on device 179:2.</span></span><br><span class="line"><span class="string">[    1.710548] devtmpfs: mounted</span></span><br><span class="line"><span class="string">[    1.724192] Freeing unused kernel memory: 1024K</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.248] RX：[    1.892543] EXT4-fs (mmcblk0p2): re-mounted. Opts: data=ordered</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.361] RX：Starting logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.403] RX：OK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.483] RX：Initializing random number generator... </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.591] RX：done.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:20.710] RX：</span></span><br><span class="line"><span class="string">Welcome to Lichee Pi</span></span><br><span class="line"><span class="string">Lichee login: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.235] TX：root</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:26.239] RX：root</span></span><br><span class="line"><span class="string">Password: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.220] TX：licheepi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.224] RX：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:27.283] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.020] TX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.025] RX：poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.148] RX：# </span></span><br><span class="line"><span class="string"># </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.212] RX：Saving random seed... done.</span></span><br><span class="line"><span class="string">Stopping logging: </span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.275] RX：OK</span></span><br><span class="line"><span class="string">umount: devtmpfs busy - remounted read-only</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:29.403] RX：[   11.047017] EXT4-fs (mmcblk0p2): re-mounted. Opts: (null)</span></span><br><span class="line"><span class="string">The system is going down NOW!</span></span><br><span class="line"><span class="string">Sent SIGTERM to all processes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:30.425] RX： Sent SIGKILL to all processes</span></span><br><span class="line"><span class="string">Requesting system poweroff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[2021-09-16 12:03:31.428] RX：[   13.072847] reboot: System halted</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure><h1 id="五、Linux初学1"><a href="#五、Linux初学1" class="headerlink" title="五、Linux初学1"></a>五、Linux初学1</h1><p>1、获取源码；2、编译源码；3、烧录可执行文件；4、显示效果</p><p>一直在了解源码，但怎么都学不会，直到现在也没能在屏幕上输出个hello world。现在想要在自己的板上，一步一步学习使用。第一件事就是把别人做好的源码进行编译输出个东西，然后再去修改。</p><h2 id="一、u-boot"><a href="#一、u-boot" class="headerlink" title="一、u-boot"></a>一、u-boot</h2><p>1、获取源码<br>git clone <a href="https://github.com/Lichee-Pi/u-boot.git">https://github.com/Lichee-Pi/u-boot.git</a> -b nano-v2018.01</p><p>2、生成配置文件</p><ul><li><p>如果需要生成在sdram里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_defconfig</p></li><li><p>如果需要生成在spiflash里启动的uboot</p></li><li><p>make ARCH&#x3D;arm licheepi_nano_spiflash_defconfig</p></li></ul><p>3、编译</p><ul><li>make V&#x3D;1 ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabihf- -j12</li></ul><h2 id="二、Linux"><a href="#二、Linux" class="headerlink" title="二、Linux"></a>二、Linux</h2><p>1、获取源码：</p><p>git clone –depth&#x3D;1 -b f1c100s-480272lcd-test <a href="https://github.com/Icenowy/linux.git">https://github.com/Icenowy/linux.git</a></p><p>不知道为何我克隆时，上面.git后缀必须要去掉。</p><p>wget <a href="http://dl.sipeed.com/LICHEE/Nano/SDK/config">http://dl.sipeed.com/LICHEE/Nano/SDK/config</a></p><p>mv config .config</p><p>2、编译源码：</p><p>make ARCH&#x3D;arm menuconfig</p><p>make ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-gnueabi- -j12</p><h2 id="三、烧录可执行文件："><a href="#三、烧录可执行文件：" class="headerlink" title="三、烧录可执行文件："></a>三、烧录可执行文件：</h2><p>编译完成后将linux&#x2F;arch&#x2F;arm&#x2F;boot下的“zImage”文件和linux&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts下的“suniv-f1c100s-licheepi-nano.dtb”文件拷贝到TF卡第一分区。</p><p>在第一分区中放入boot.scr文件。其他按照前面文章进行即可运行。</p><h2 id="四、显示效果："><a href="#四、显示效果：" class="headerlink" title="四、显示效果："></a>四、显示效果：</h2><p>串口调试助手会输出运行信息，界面也会显示信息。在串口调试助手上可以使用Linux命令进行基本操作。</p><p>使用的是800x480的屏，但Linux配置的是480x272的显示，因此显示不是全屏。这也变成了后期学习的一点。</p><img src="/posts/2989473239/30e2c79f8392e1c8392cade7396bee20.png" class="" title="img"><h1 id="六、裸机寄存器点灯"><a href="#六、裸机寄存器点灯" class="headerlink" title="六、裸机寄存器点灯"></a>六、裸机寄存器点灯</h1><p>按照《嵌入式Linux应用开发 完全手册》，了解寄存器的操作，编译流程，硬件执行流程。</p><h2 id="1、修改LED源码"><a href="#1、修改LED源码" class="headerlink" title="1、修改LED源码"></a>1、修改LED源码</h2><p>按照书上编辑修改LED源代码：其中寄存器地址与IO偏移按照芯片手册和电路实际IO进行修改。我的电路使用PA0、PA1作为按键输入，PA2、PA3作为LED输出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File led_on_c.c</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_CFG0(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x00)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PA_DAT(*(volatile unsigned long *)(0x01C20800+(0*0x24+0x10)))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT00</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT33</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT0));<span class="comment">//PA0 in</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT1));<span class="comment">//PA1 in</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT2));<span class="comment">//PA2 clear</span></span><br><span class="line">PA_CFG0 &amp;= ~(<span class="number">0x7</span> &lt;&lt; (<span class="number">4</span> * BIT3));<span class="comment">//PA3 clear</span></span><br><span class="line"> </span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT2);<span class="comment">//PA2 out</span></span><br><span class="line">PA_CFG0 |= <span class="number">0x1</span> &lt;&lt; (<span class="number">4</span> * BIT3);<span class="comment">//PA3 out</span></span><br><span class="line"> </span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT2);<span class="comment">//PA2 reset</span></span><br><span class="line">delay();</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT2;<span class="comment">//PA2 set</span></span><br><span class="line">delay();</span><br><span class="line"><span class="keyword">if</span>((PA_DAT &amp; (<span class="number">0x1</span> &lt;&lt; BIT0)) != <span class="number">0x0</span>)</span><br><span class="line">&#123;</span><br><span class="line">PA_DAT |= <span class="number">0x1</span> &lt;&lt; BIT3;<span class="comment">//PA3 set</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">PA_DAT &amp;= ~(<span class="number">0x1</span> &lt;&lt; BIT3);<span class="comment">//PA3 reset</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">// about 408ms when CPU_CLK_SRC uses OSC24M</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">__asm <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; ldr r0, =76480\n&quot;</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; loop:cmp r0,#0\n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; beq exit \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; sub r0,r0,#1 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot; b loop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="string">&quot;exit:nop \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、编写start-s文件，makefile文件"><a href="#2、编写start-s文件，makefile文件" class="headerlink" title="2、编写start.s文件，makefile文件"></a>2、编写start.s文件，makefile文件</h2><p>原本按照书上编写了start.s文件，makefile文件，但经过多次尝试后发现书上的不能照抄。在网上查资料，发现全志的芯片需要一个tools工具，能够将代码端放到指定位置，以及各种初始化。从网上下载源码后，发现其中有F1C100.s对应了书上的start.s。但并不能按照书上简单组合，还需要各种辅助文件。文件已上传在我的资源中。</p><img src="/posts/2989473239/4cbeacf8920f070734f393a22043e28f.png" class="" title="img"><h2 id="3、编译后，烧写到SD卡，运行效果"><a href="#3、编译后，烧写到SD卡，运行效果" class="headerlink" title="3、编译后，烧写到SD卡，运行效果"></a>3、编译后，烧写到SD卡，运行效果</h2><img src="/posts/2989473239/5c768d84974c935a5e386ffc5c94ea0f.png" class="" title="img"><p>这个灯在500ms闪烁。按住PA0，会使PA3点亮。</p><p>参考：<a href="https://www.bilibili.com/read/cv9477324">【荔枝派Nano】F1C100S的boothead和BROM - 哔哩哔哩</a></p><h1 id="七、Linux初学2"><a href="#七、Linux初学2" class="headerlink" title="七、Linux初学2"></a>七、Linux初学2</h1><p>1、uboot移植、修改LED灯；2、学习uboot代码；3、阅读代码的取巧方法</p><h2 id="1、uboot移植"><a href="#1、uboot移植" class="headerlink" title="1、uboot移植"></a>1、uboot移植</h2><p>认知：使用uboot指令控制LED灯，在uboot&#x2F;cmd文件中找到led指令文件，在uboot&#x2F;cmd&#x2F;makefile文件中查看是否链接led指令文件，如果未链接则需要添加。原有添加方式中需要判断UBOOT_CMD_LED的值，需要在uboot&#x2F;.config中设置UBOOT_CMD_LED&#x3D;y，将led指令文件编译连接到指令中。</p><p>编译后，下载到demo板，打开串口调试工具，输入help指令，可以看到有led指令，在输入了的指令，可以看到介绍，对比介绍与led指令文件中一致，表示指令过程正确。</p><p>但现在的指令不能执行硬件动作，猜测需要修改驱动和设备树，以支持led设备。</p><h2 id="2、学习uboot代码"><a href="#2、学习uboot代码" class="headerlink" title="2、学习uboot代码"></a>2、学习uboot代码</h2><p>利用正确的Uboot代码，输出信息到串口调试助手：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">[20:57:46.566]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line">[20:57:46.926]收←◆</span><br><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21)preloader_console_init\spl.c</span><br><span class="line">DRAM: 64 MiBsunxi_board_init\board.c</span><br><span class="line">Trying to boot from MMC1boot_from_devices\spl.c</span><br><span class="line"></span><br><span class="line">[20:57:47.096]收←◆</span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner TechnologyU_BOOT_VERSION_STRING\version.h  display_options_get_banner_priv\display_options.c</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)print_cpuinfo\cpu_info.c</span><br><span class="line">Model: Lichee Pi Nanoshow_board_info\board_info.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DRAM:  64 MiBannounce_dram_init+show_dram_config\board_f.c+display_options.c</span><br><span class="line"></span><br><span class="line">[20:57:47.628]收←◆MMC:   SUNXI SD/MMC: 0initr_mmc+mmc_initialize+print_mmc_devices\board_r.c+mmc.c+mmc_legasy.c</span><br><span class="line"></span><br><span class="line">[20:57:47.706]收←◆*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">__led_init: failed requesting GPIO0!</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  2 </span><br><span class="line">[20:57:48.734]收←◆ 1 </span><br><span class="line">[20:57:49.735]收←◆ 0 </span><br><span class="line"></span><br><span class="line">[20:57:49.798]收←◆switch to partitions #0, OK</span><br><span class="line">mmc0 is current device</span><br><span class="line"></span><br><span class="line">[20:57:50.345]收←◆Scanning mmc 0:1...</span><br><span class="line"></span><br><span class="line">[20:57:50.489]收←◆reading /suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line"><span class="symbol">4393 </span>bytes <span class="keyword">read</span> in <span class="number">25</span> ms (<span class="number">170.9</span> KiB/s)</span><br><span class="line"></span><br><span class="line">[20:57:50.561]收←◆starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">USB is stopped. Please issue &#x27;usb start&#x27; first.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: pxeuuid</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/000</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/00</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/0</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm-sunxi</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default-arm</span><br><span class="line">No ethernet found.</span><br><span class="line">missing environment variable: bootfile</span><br><span class="line">Retrieving file: pxelinux.cfg/default</span><br><span class="line">No ethernet found.</span><br><span class="line">Config file not found</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">No ethernet found.</span><br><span class="line">No ethernet found.</span><br><span class="line">=&gt; </span><br></pre></td></tr></table></figure><p>然后按照这个输出信息，一条一条找到执行位置，上面标红为函数接口，蓝色为接口所在源文件。</p><img src="/posts/2989473239/10cdaf8614a42f1d79e87f6a0000ba29.png" class="" title="img"><p>屏蔽以上代码后，下面的输出信息依旧存在，表示下面的输出信息位于执行borad_init_f()之前。</p><img src="/posts/2989473239/0f737d68dc200a9f2776188a7cd996d1.png" class="" title="img"><p>在指定位置添加调试信息，发现以下部分信息属于borad_init_f()内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Feb 16 2022 - 14:45:21 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">++++++++</span><br><span class="line"></span><br><span class="line">DRAM:  64 MiB</span><br></pre></td></tr></table></figure><p>这之后的信息属于board_init_r()内。</p><p><strong>前几天不是纠结uboot中函数在何处调用问题吗，今天找到一个笨办法了，就是把函数本身名修改成另一个，然后再编译，就会提示哪个位置有错误或警告，那就是被调用位置呐。****阅读代码的取巧方法。</strong></p><p>使用上述方法后终于找到了所有输出信息对应的位置。</p><img src="/posts/2989473239/3d5bb221c3db83abc167c2220fc285b1.png" class="" title="img"><p>时发现了这个BUG，就是代码是灰色的，但是却是会执行的。下一步是想办法控制LED亮灭。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119389552">自制F1C200S demo板（一、电路）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119393266">自制F1C200S demo板（二、Win上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/119460667">自制F1C200S demo板（三、Linux上测试）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120074618">自制F1C200S demo板（四、TF卡启动）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120291080">自制F1C200S demo板（五、Linux初学1）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/121530962">自制F1C200S demo板（六、裸机寄存器点灯）</a></li><li><a href="https://blog.csdn.net/weixin_37214729/article/details/120330444">自制F1C200S demo板（七、Linux初学2）</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C200S demo板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="demo板" scheme="https://zml3589110.github.io/tags/demo%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>f1c100sf1c200s 裸机程序</title>
    <link href="https://zml3589110.github.io/posts/931990122.html"/>
    <id>https://zml3589110.github.io/posts/931990122.html</id>
    <published>2025-09-10T07:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.277Z</updated>
    
    <content type="html"><![CDATA[<p>整理了F1C200S的裸机学习过程，只实现了一些基础的应用。<br>直接上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/F1C200S.git</span><br></pre></td></tr></table></figure><p>使用make构建工程，编译工具 arm-none-eab-gcc 10.3 下载使用XBOOT 大神的 xfel<br>详细编译说明readme.md ：<a href="https://gitee.com/dmcus/F1C200S/blob/master/README.md">https://gitee.com/dmcus/F1C200S/blob/master/README.md</a></p><p>没接触过make构建的参考学习例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://gitee.com/dmcus/makefile-notes</span><br></pre></td></tr></table></figure><p>开发板使用：LC-PI-200S Board CherryPi ,其他开发板未测试，请根据实际情况调整代码。</p><p>已实现功能：<br>外设：        GPIO I2C SPI UART USB-CDC DISPLAY SD<br>移植其他开源库： SFUD LVGL8 LVGL9 FatFs infoNes VNes CherryUSB-CDC<br>外围设备：     GT911 24C02 W25Q128<br>RTOS:        RT-Thread 4.1 原版本使用scons构建，主要添加Makfe构建，移植RT-Thread Studio自动生成的代码。</p><p>暂未实现：音频、视频编解码、摄像头、麦克。</p><p>bootloader下载到flash 地址0，例子下载到 0x10000地址，运行后会拷贝到 DRAM 中运行，串口打印使用UART1。</p><p>目录结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">doc  ------文档和原理图 使用LCPI F1C200S 开发板 集成CH340E -&gt; UART1</span><br><span class="line">sources ---源码</span><br><span class="line">    |bootloader -----SPL 烧录FLASH 0,log 使用 UART1</span><br><span class="line">    |drivers---------f1c200s驱动</span><br><span class="line">    |fc200s_brom ----sram运行的独立程序 烧录FLASH 0 支持串口</span><br><span class="line">    |examples--------peripherals examples 外设样例，裸机程序 使用LCPI F1C200S 开发板</span><br><span class="line">    |mksunxi --------.bin文件添加校验头工具</span><br><span class="line">    |rtt-------------rt-thread 烧录到FLASH 0X10000 log 使用 UART1</span><br><span class="line">tools -----make 工具 添加到环境变量</span><br><span class="line">1.bootload下载</span><br><span class="line"> cd sources&#x2F;bootloader</span><br><span class="line">   make all</span><br><span class="line">   make download</span><br><span class="line"> </span><br><span class="line">2.i2c uart gpio 等例子编译下载</span><br><span class="line">  cd sources&#x2F;examples&#x2F;uart</span><br><span class="line">  make all</span><br><span class="line">  make download</span><br></pre></td></tr></table></figure><p>感谢大神们的无私奉献，主要参考以下开源工程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;nminaylov&#x2F;F1C100s_projects.git</span><br><span class="line">https:&#x2F;&#x2F;gitee.com&#x2F;lhdjply&#x2F;f1c200s_library</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;VeiLiang&#x2F;BoloRTT.git</span><br></pre></td></tr></table></figure><hr><p>这个包里有个make download，因为我没有编译成功linux下的sunsi，所以我用windows的sunxi-fel下载到芯片，但串口没有任何响应，请问我的操作是否有误？</p><p>window 下操作，linux没测试过。需要先编译下载bootloader到 flash 0 ，然后下载例子到 flash 0x10000。串口使用的是 UART1输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">download:$(BIN)</span><br><span class="line">    ifeq ($(TARGET),bootloader)</span><br><span class="line">xfel spinor write 0 $(BIN)</span><br><span class="line">    else</span><br><span class="line">xfel spinor write 0x10000 $(BIN)</span><br><span class="line">    endif</span><br></pre></td></tr></table></figure><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11525.html">f1c100s&#x2F;f1c200s 裸机程序。</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">f1c100sf1c200s 裸机程序</summary>
    
    
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/categories/%E8%A3%B8%E6%9C%BA/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="裸机" scheme="https://zml3589110.github.io/tags/%E8%A3%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</title>
    <link href="https://zml3589110.github.io/posts/246263880.html"/>
    <id>https://zml3589110.github.io/posts/246263880.html</id>
    <published>2025-09-10T07:41:20.000Z</published>
    <updated>2025-09-10T13:10:14.184Z</updated>
    
    <content type="html"><![CDATA[<p>原始工程使用f1c100s&#x2F;f1c200s 裸机程序，参见 <a href="https://whycan.com/t_11525.html">https://whycan.com/t_11525.html</a></p><p>工程构建：make<br>操作系统：windows</p><p>FreeRTOS没有ARM9的例子，ARM7和ARM9内核很相似，主要参考ARM7_LPC2000 移植。</p><p>FreeRTOS源码下载：<br>哇酷下载：<a href="https://whycan.com/files/members/15085/RTOS-KernelV11.1.0.zip">RTOS-KernelV11.1.0.zip</a><br>github下载：<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/releases">https://github.com/FreeRTOS/FreeRTOS-Kernel/releases</a></p><p>一、文件目录结构搭建</p><p>1.解压重命名为FreeRTOS ，新建文件夹port</p><p>2.复制 FreeRTOS&#x2F;portable&#x2F;GCC&#x2F;ARM7_LPC2000 下 port.c portISR.c portmacro.h 到 port目录下</p><p>3.复制FreeRTOS&#x2F;portable&#x2F;MemMang 到FreeRTOS&#x2F;MemMang</p><p>4.复制 FreeRTOS&#x2F;examples&#x2F;template_configuration&#x2F;FreeRTOSConfig.h 到 include目录下</p><p>\5. 删除examples portable 文件夹。完成后的目录结构如下</p><img src="/posts/246263880/rtpng.png" class="" title="目录结构"><p>移植过程：</p><p>添加FreeRTOS 中断，修改工程文件 vectors.S，定义宏 <strong>USE_FREERTOS</strong> ， 修改 _software_interrupt 和 _irq 两个中断，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*任务切换*&#x2F; </span><br><span class="line">_software_interrupt: </span><br><span class="line">#if defined (USE_FREERTOS)</span><br><span class="line">    .word vPortYieldProcessor</span><br><span class="line">#else</span><br><span class="line">    .word software_interrupt</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#x2F;*系统嘀嗒心跳*&#x2F; </span><br><span class="line">_irq:</span><br><span class="line">#if defined (USE_FREERTOS) </span><br><span class="line">    .word vFreeRTOS_ISR</span><br><span class="line">#else</span><br><span class="line">    .word irq</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>port.c 和 portISR.c ，添加定时器初始化和定时器中断切换任务功能</p><p>port.c 添加头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;f1c100s_timer.h&quot;</span><br><span class="line">#include &quot;f1c100s_intc.h&quot;</span><br></pre></td></tr></table></figure><p>定时器time0初始化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Setup the timer 0 to generate the tick interrupts at the required frequency.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static void prvSetupTimerInterrupt(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void vTickISR(void); </span><br><span class="line"> </span><br><span class="line">    tim_init(TIM0, TIM_MODE_CONT, TIM_SRC_HOSC, TIM_PSC_1);</span><br><span class="line">    tim_set_period(TIM0, 24000000UL&#x2F;1000UL);&#x2F;&#x2F;1ms中断</span><br><span class="line">    tim_int_enable(TIM0); </span><br><span class="line">    intc_set_irq_handler(IRQ_TIMER0, vTickISR); </span><br><span class="line">    intc_enable_irq(IRQ_TIMER0); </span><br><span class="line">    tim_start(TIM0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 接管所有的中断，添加上下文切换保存和恢复，添加naked属性，禁用编译器上下文管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*__attribute__((naked)) 很关键 不加调度</span><br><span class="line"> *使用naked属性可以告诉编译器不生成函数的prologue和epilogue代码，</span><br><span class="line"> *这样任务切换函数可以自行管理寄存器的入栈和恢复，从而简化上下文管理*&#x2F;</span><br><span class="line">void vFreeRTOS_ISR(void) __attribute__((naked));</span><br><span class="line">void vFreeRTOS_ISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern void irq_handler(void);</span><br><span class="line">    &#x2F;* Save the context of the interrupted task. *&#x2F;</span><br><span class="line">    portSAVE_CONTEXT();</span><br><span class="line">    &#x2F;* irq all*&#x2F;</span><br><span class="line">    irq_handler();</span><br><span class="line">    &#x2F;* Restore the context of the new task. *&#x2F;</span><br><span class="line">    portRESTORE_CONTEXT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 系统嘀嗒中断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#ifndef write32</span><br><span class="line">#define write32(x, y) (*((volatile uint32_t *)(x)) &#x3D; y)</span><br><span class="line">#endif</span><br><span class="line">#include &quot;task.h&quot;</span><br><span class="line">void vTickISR(void)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;* Increment the RTOS tick count, then look for the highest priority</span><br><span class="line">     * task that is ready to run. *&#x2F;</span><br><span class="line">    if (xTaskIncrementTick() !&#x3D; pdFALSE)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskSwitchContext();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;* Ready for the next interrupt. *&#x2F;</span><br><span class="line">    write32((0x01C20C00) + 0x04, (1 &lt;&lt; 0));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>portISR.c 添加 堆栈溢出 回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void vApplicationStackOverflowHook(TaskHandle_t xTask,</span><br><span class="line">                                   char *pcTaskName)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;statck over flow:%s&quot;,pcTaskName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeRTOSConfig.h 修改heap大小 和 位宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define configTOTAL_HEAP_SIZE                        512*1024</span><br><span class="line">#define configTICK_TYPE_WIDTH_IN_BITS              TICK_TYPE_WIDTH_32_BITS</span><br></pre></td></tr></table></figure><p>makefile 添加 <strong>CFLAGS+&#x3D;-DUSE_FREERTOS</strong><br>至此移植完成。</p><p>gcc和xfel：<br>usb下载工具 xfel 和USB驱动下载： <a href="https://github.com/xboot/xfel/releases/download/v1.3.2/xfel-windows-v1.3.2.7z">xfel-v1.3.2</a><br>gcc：<a href="https://developer.arm.com/-/media/Files/downloads/gnu-rm/10.3-2021.10/gcc-arm-none-eabi-10.3-2021.10-win32.exe?rev=29bb46cfa0434fbda93abb33c1d480e6&hash=3C58D05EA5D32EF127B9E4D13B3244D26188713C">arm-none-eab-gcc-10.3</a><br>make rm工具在工程目录下</p><p>完整移植好的FreeRTOS 11.1工程下载：<a href="https://whycan.com/files/members/15085/F1C200S_FreeRTOS.zip">F1C200S_FreeRTOS.zip</a></p><p>编译: arm-none-eabi-gcc 和xfel添加到环境变量 ，打开cmd命令行 ，进入 F1C200S_FreeRTOS 目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make all</span><br><span class="line">make download</span><br></pre></td></tr></table></figure><hr><p>花了五块验证程序可以用，只是FreeRTOS部分移到自己工程后，切换上下文有点问题。<br>修改汇编里面的中断后成功启动，感谢楼主</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_11538.html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">F1C100SF1C200S 移植FreeRTOS全过程 GCC 版本</summary>
    
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/categories/FreeRtos/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="FreeRtos" scheme="https://zml3589110.github.io/tags/FreeRtos/"/>
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>USB转串口芯片</title>
    <link href="https://zml3589110.github.io/posts/4211420882.html"/>
    <id>https://zml3589110.github.io/posts/4211420882.html</id>
    <published>2025-09-10T03:03:20.000Z</published>
    <updated>2025-09-10T13:10:14.230Z</updated>
    
    <content type="html"><![CDATA[<h1 id="沁恒"><a href="#沁恒" class="headerlink" title="沁恒"></a>沁恒</h1><h2 id="CH9102X"><a href="#CH9102X" class="headerlink" title="CH9102X"></a>CH9102X</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="CP2102-GMR替换为CH9102X后无法识别USB设备"><a href="#CP2102-GMR替换为CH9102X后无法识别USB设备" class="headerlink" title="CP2102-GMR替换为CH9102X后无法识别USB设备"></a>CP2102-GMR替换为CH9102X后无法识别USB设备</h4><p>我做了两块板子，一块是用CP2102-GMR的，另一块以为货期问题，使用CH9102X作为替换，百度上很多都说<a href="https://bbs.elecfans.com/zhuti_dianlu_1.html">电路</a>不用修改就可以直接替换的，但是使用CP2102的板子能正常被电脑识别，使用CH9102X的板子连接上USB后，系统提示无法识别USB设备描述，安装官方的VCP也是无法识别，下附电路图为CP2102的，CH9102X为直接替换，是需要修改什么电路吗？</p><img src="/posts/4211420882/pYYBAGK1MI6AOJkUAAIpE9sw_p0850.png" class="" title="img"><p>解答:</p><p>如上提示代表USB设备枚举不成功。原理图影响USB识别的原因应该为芯片#6脚在5V供电模式下没有外接退耦电容所致（建议容值104）。手册说明如下所示：</p><img src="/posts/4211420882/1652858167945200.png" class="" title="img"><p>加了电容之后可以识别到了，但是DTR的引脚可以正常控制，RTS引脚控制不了，一直是高电平状态，用调试助手打开关闭也没有效果</p><p>CH9102等第三代USB转串口芯片同时支持VCP和CDC两种驱动模式，如上现象应该是您使用的是CDC串口驱动导致，请更新使用如下VCP驱动即可，驱动链接：<a href="http://www.wch.cn/downloads/CH343SER_EXE.html">http://www.wch.cn/downloads/CH343SER_EXE.html</a>?<br>关于CDC串口和VCP串口等区别，也看下方案中相关说明：<a href="http://www.wch.cn/application/357.html">http://www.wch.cn/application/357.html</a>?</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://bbs.elecfans.com/jishu_2289360_1_1.html">CP2102-GMR替换为CH9102X后无法识别USB设备是为什么？</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">CH9102X沁恒USB转串口芯片</summary>
    
    
    
    <category term="通讯类" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/%E9%80%9A%E8%AE%AF%E7%B1%BB/UART/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/categories/CH9102X/"/>
    
    
    <category term="通讯" scheme="https://zml3589110.github.io/tags/%E9%80%9A%E8%AE%AF/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="沁恒" scheme="https://zml3589110.github.io/tags/%E6%B2%81%E6%81%92/"/>
    
    <category term="CH9102X" scheme="https://zml3589110.github.io/tags/CH9102X/"/>
    
    <category term="CP2102" scheme="https://zml3589110.github.io/tags/CP2102/"/>
    
  </entry>
  
  <entry>
    <title>DNS自动选择最佳服务器的实战指南</title>
    <link href="https://zml3589110.github.io/posts/2322562202.html"/>
    <id>https://zml3589110.github.io/posts/2322562202.html</id>
    <published>2025-09-09T08:25:20.000Z</published>
    <updated>2025-09-10T13:10:14.372Z</updated>
    
    <content type="html"><![CDATA[<p>简介：DNS，作为互联网的关键服务，负责将域名转换为IP地址以优化网络连接。DNS自动选取功能使系统能根据网络条件选择响应最快的服务器。DNS跳跃（DnsJumper）工具可帮助用户测试和切换到最佳DNS服务器。文章概述了DNS解析过程、服务器选择、缓存机制、优选技术和DnsJumper的使用方法，还讨论了安全性和网络性能改善等实用知识点。</p><img src="/posts/2322562202/350a1c87c7b83de0dc9e8ba252434266.png" class="" title="dns自动选取"><h2 id="1-DNS作用及解析过程"><a href="#1-DNS作用及解析过程" class="headerlink" title="1. DNS作用及解析过程"></a>1. DNS作用及解析过程</h2><h3 id="1-1-DNS定义与作用"><a href="#1-1-DNS定义与作用" class="headerlink" title="1.1 DNS定义与作用"></a>1.1 DNS定义与作用</h3><p>域名系统（Domain Name System, DNS）是互联网的一项核心服务，它负责将人类可读的域名转换为机器可识别的IP地址。DNS的存在使得用户无需记忆复杂的数字序列，而只需要输入易于理解的域名即可访问网站，极大地提高了互联网的易用性。</p><h3 id="1-2-DNS解析过程"><a href="#1-2-DNS解析过程" class="headerlink" title="1.2 DNS解析过程"></a>1.2 DNS解析过程</h3><p>DNS解析过程涉及用户请求域名到获得IP地址的转换，主要步骤如下：</p><ol><li>用户输入域名后，设备首先查询本地缓存是否有对应的域名解析记录。</li><li>若本地缓存未命中，则请求会到达配置的递归DNS服务器。</li><li>递归DNS服务器会启动迭代解析流程，依次查询根域名服务器、顶级域名服务器及权威域名服务器，最终返回目标域名对应的IP地址给用户。</li></ol><p>在整个解析过程中，可能涉及多种缓存机制，以优化响应时间并减轻根服务器的负载</p><h2 id="2-DNS服务器选择与缓存机制"><a href="#2-DNS服务器选择与缓存机制" class="headerlink" title="2. DNS服务器选择与缓存机制"></a>2. DNS服务器选择与缓存机制</h2><h3 id="2-1-DNS服务器的工作原理"><a href="#2-1-DNS服务器的工作原理" class="headerlink" title="2.1 DNS服务器的工作原理"></a>2.1 DNS服务器的工作原理</h3><p>DNS服务器在处理查询请求时主要采用两种方法：递归解析和迭代解析。</p><ul><li><strong>递归解析</strong> ：在这种方式中，当一个DNS解析器（比如，用户的电脑）向DNS服务器发起请求时，如果该服务器没有所请求域名的记录，则会代替请求者去别的DNS服务器查询，直至找到记录并返回给请求者。递归查询对于客户端来说比较简单，因为客户端只需要向一个服务器发出请求，就可以得到最终结果。</li><li><strong>迭代解析</strong> ：这种方式中，DNS服务器不会代替请求者查询，而是返回一个更靠近所查询域名记录的DNS服务器的地址，请求者需要向这个新的地址发出请求。如果新的服务器也无记录，则再次返回另一个地址，如此迭代，直到找到记录为止，或者返回错误信息表示未找到。</li></ul><p>递归解析和迭代解析的对比：</p><ul><li><strong>性能影响</strong> ：递归解析可能导致服务器过载，因为需要为大量请求进行多次查询；而迭代解析将查询工作分散到多个服务器，减轻单个服务器的压力。</li><li><strong>效率</strong> ：递归解析通常更快，因为它为请求者隐藏了查询过程；迭代解析则对客户端的智能程度要求更高。</li><li><strong>实现复杂性</strong> ：递归解析对DNS服务器来说更复杂，因为它需要管理查询状态并可能与多个服务器通信；迭代解析的逻辑相对简单。</li></ul><h4 id="2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色"><a href="#2-1-2-根域名服务器、顶级域名服务器、权威域名服务器的角色" class="headerlink" title="2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色"></a>2.1.2 根域名服务器、顶级域名服务器、权威域名服务器的角色</h4><p>DNS系统由多个层级的服务器组成，每个层级的服务器都有其特定的角色和职责：</p><ul><li><strong>根域名服务器</strong> ：它们是DNS层级结构的最顶层，负责解析顶级域名（如.com、.org、.net等）的地址。当本地DNS服务器没有相关记录时，它会首先联系根域名服务器来获取顶级域名服务器的地址。</li><li><strong>顶级域名服务器（TLD）</strong> ：管理着所有二级域名的DNS记录。例如，在请求 <code>google.com </code>时，根域名服务器会提供 <code>.com </code>顶级域名服务器的地址，之后本地DNS服务器将查询发送至 <code>.com </code>顶级域名服务器。</li><li><strong>权威域名服务器</strong> ：这些服务器拥有特定域名的完整数据记录。它们要么是域名注册商提供的，要么是自行管理的。当顶级域名服务器指向了相应的权威服务器后，解析过程便会在这里完成，返回给查询者IP地址或其他相关信息。</li></ul><p>DNS层级结构保证了域名查询的高效和分摊管理责任，通过逐级查询，最终获得准确的IP地址映射信息。</p><h3 id="2-2-DNS缓存机制的原理与作用"><a href="#2-2-DNS缓存机制的原理与作用" class="headerlink" title="2.2 DNS缓存机制的原理与作用"></a>2.2 DNS缓存机制的原理与作用</h3><h4 id="2-2-1-缓存的作用与优势"><a href="#2-2-1-缓存的作用与优势" class="headerlink" title="2.2.1 缓存的作用与优势"></a>2.2.1 缓存的作用与优势</h4><p>DNS缓存是在本地存储域名到IP地址映射记录的过程，这样可以加快后续相同域名查询的速度，并减轻上游DNS服务器的负担。</p><ul><li><strong>减少查询延迟</strong> ：由于缓存记录了之前解析过的域名信息，因此在本地进行快速查询，避免了重复查询整个DNS层级结构的时间损耗。</li><li><strong>降低网络负载</strong> ：缓存减少了对上游服务器的请求，从而减少了网络流量。</li><li><strong>提高系统可靠性</strong> ：在本地有缓存的情况下，即使上游服务器不可用，部分查询也可能得到快速响应。</li></ul><h4 id="2-2-2-缓存过程中的常见问题及解决方案"><a href="#2-2-2-缓存过程中的常见问题及解决方案" class="headerlink" title="2.2.2 缓存过程中的常见问题及解决方案"></a>2.2.2 缓存过程中的常见问题及解决方案</h4><p>尽管缓存机制有很多优点，但也存在一些问题：</p><ul><li><strong>缓存过时问题</strong> ：如果域名记录发生变化，而本地缓存尚未更新，就可能出现解析错误的情况。解决这个问题的一种方法是设置一个合理的缓存超时时间，这样记录在一定时间后会过期，迫使DNS服务器重新从权威服务器获取最新信息。</li><li><strong>缓存污染问题</strong> ：恶意的DNS服务器可能会发送错误的记录到缓存中，导致解析错误。对于这个问题，可以通过验证记录的来源和配置安全的DNS解析器来加强防护。</li><li><strong>缓存策略优化</strong> ：需要针对不同的应用场景和记录类型，制定合理、灵活的缓存策略，以平衡速度与准确性。例如，对于经常变动的网站，可以设置较短的缓存时间，而对于相对稳定的域名，则可以设置较长的缓存时间。</li></ul><p>缓存机制是DNS系统高效运行的关键组成部分，但必须合理管理和优化，以保证其长期稳定提供服务。接下来的章节将进一步探讨与DNS缓存相关的技术细节，包括缓存策略的优化和实际应用中的最佳实践。</p><p>为了更好地理解DNS缓存策略和常见的DNS问题，下文将展示一个具体的DNS服务器配置缓存的代码示例，并进行详细分析。</p><h2 id="3-DNS优选技术与自动选取原理"><a href="#3-DNS优选技术与自动选取原理" class="headerlink" title="3. DNS优选技术与自动选取原理"></a>3. DNS优选技术与自动选取原理</h2><h3 id="3-1-DNS优选技术概述"><a href="#3-1-DNS优选技术概述" class="headerlink" title="3.1 DNS优选技术概述"></a>3.1 DNS优选技术概述</h3><h4 id="3-1-1-测速技术"><a href="#3-1-1-测速技术" class="headerlink" title="3.1.1 测速技术"></a>3.1.1 测速技术</h4><p>DNS优选技术的核心是能够快速准确地为用户选择出响应速度最快、服务质量最佳的DNS服务器。为了实现这一目标，必须先对DNS服务器的响应时间进行准确的测量。</p><p>测速技术可以通过发送查询请求到不同的DNS服务器并记录它们响应的时间来实现。这些时间测量包括但不限于：</p><ul><li><strong>请求时间（RTT）</strong> ：从发出查询请求到收到响应的时间。RTT越低，说明距离客户端越近或处理速度越快。</li><li><strong>丢包率</strong> ：在测试过程中数据包丢失的比例。一个稳定的DNS服务器应具备低丢包率。</li><li><strong>服务质量（QoS）</strong> ：对响应速度和丢包率之外的其他因素的综合评估，如服务器的负载状况。</li></ul><p>现代网络工具如 <code>dig </code>, <code>nslookup </code>, 或专用的DNS测速工具可以用来进行这些测量。实践中，通过编写脚本或使用现成的网络管理工具，可以自动化这一过程并持续监测DNS服务器的性能。</p><h4 id="3-1-2-智能决策算法"><a href="#3-1-2-智能决策算法" class="headerlink" title="3.1.2 智能决策算法"></a>3.1.2 智能决策算法</h4><p>优选技术不仅依赖于准确的测速，还需要智能决策算法来分析测速结果，并据此做出最优的DNS选择。这些算法可以采用不同的策略和参数进行决策，例如：</p><ul><li><strong>加权轮询</strong> ：为每个DNS服务器基于其性能表现赋予不同的权重，然后按照权重进行轮询。</li><li><strong>最快响应优先</strong> ：简单选择最近一次测量中响应最快的服务器。</li><li><strong>自适应算法</strong> ：依据网络状况和历史数据动态调整决策策略。</li></ul><p>智能算法的设计必须考虑各种可能影响DNS查询性能的因素，并且能够适应网络环境的变化。例如，当某个服务器突然变得不可用或响应变慢时，算法需要能够迅速调整，将流量转移到表现更好的服务器上。</p><h3 id="3-2-DNS自动选取机制"><a href="#3-2-DNS自动选取机制" class="headerlink" title="3.2 DNS自动选取机制"></a>3.2 DNS自动选取机制</h3><h4 id="3-2-1-自动选取的实现方式"><a href="#3-2-1-自动选取的实现方式" class="headerlink" title="3.2.1 自动选取的实现方式"></a>3.2.1 自动选取的实现方式</h4><p>DNS自动选取机制主要通过在设备或系统级别实现智能DNS客户端来达成。智能DNS客户端会监听系统的DNS查询请求，并根据优选技术的结果动态地选择最佳DNS服务器进行响应。实现这一机制的基本步骤如下：</p><ol><li><strong>初始化</strong> ：客户端启动时，向多个DNS服务器发送查询请求，收集初步的性能数据。</li><li><strong>监控</strong> ：在正常运行过程中，持续监控所有已知DNS服务器的性能状态。</li><li><strong>决策</strong> ：根据实时或准实时的性能数据，利用决策算法动态选择最优DNS服务器。</li><li><strong>更新</strong> ：当网络条件或性能数据发生变化时，更新DNS选择决策，并通知系统的其余部分。</li></ol><h4 id="3-2-2-自动选取的算法分析"><a href="#3-2-2-自动选取的算法分析" class="headerlink" title="3.2.2 自动选取的算法分析"></a>3.2.2 自动选取的算法分析</h4><p>自动选取算法的效率和效果直接关系到DNS优选技术的成功与否。我们以一个简化的伪代码例子来说明这一算法过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码展示DNS自动选取算法</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 初始化权重字典</span></span><br><span class="line">server_weights = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.5</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.3</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_weights</span>(<span class="params">server_performance</span>):</span></span><br><span class="line">    <span class="comment"># 更新服务器权重</span></span><br><span class="line">    <span class="comment"># 此处省略权重计算的具体逻辑</span></span><br><span class="line">    <span class="keyword">for</span> server <span class="keyword">in</span> server_performance:</span><br><span class="line">        server_weights[server] = calculate_weight(server_performance[server])</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_dns</span>():</span></span><br><span class="line">    <span class="comment"># 根据权重选择DNS服务器</span></span><br><span class="line">    selected_dns = <span class="built_in">max</span>(server_weights, key=server_weights.get)</span><br><span class="line">    <span class="keyword">return</span> selected_dns</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 模拟性能监控更新</span></span><br><span class="line">server_performance = &#123;</span><br><span class="line">    <span class="string">&#x27;dns1&#x27;</span>: <span class="number">0.4</span>,</span><br><span class="line">    <span class="string">&#x27;dns2&#x27;</span>: <span class="number">0.45</span>,</span><br><span class="line">    <span class="string">&#x27;dns3&#x27;</span>: <span class="number">0.15</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 更新权重</span></span><br><span class="line">update_weights(server_performance)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 选择最佳DNS</span></span><br><span class="line">best_dns = select_dns()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前最佳DNS服务器为:&quot;</span>, best_dns)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了一个权重字典 server_weights ，用于存储每个DNS服务器当前的权重。 update_weights 函数根据每个服务器的性能表现来更新权重，而 select_dns 函数则根据当前的权重来选择最佳的DNS服务器。实际应用中， calculate_weight 函数会非常复杂，它需要综合考虑多个性能参数并最终输出权重值。</p><p>值得注意的是，实际的自动选取算法可能还会包含容错逻辑，例如在选择过程中剔除掉响应异常的DNS服务器，或者在所有DNS服务器都表现不佳时提供默认备选方案。</p><p>本章节介绍了DNS优选技术及其背后的测速技术和智能决策算法。同时，深入探讨了DNS自动选取机制的实现方式和关键算法，为下一章节深入分析DnsJumper等软件提供了理论基础。</p><h2 id="4-DnsJumper功能与使用场景"><a href="#4-DnsJumper功能与使用场景" class="headerlink" title="4. DnsJumper功能与使用场景"></a>4. DnsJumper功能与使用场景</h2><p>DnsJumper 是一款小巧的网络工具软件，旨在帮助用户轻松管理和优化 DNS 设置。它不仅支持多种操作系统，还具有友好的用户界面，使得普通用户也能进行专业级别的 DNS 设置。本章节将对 DnsJumper 的功能特性进行深入解析，并分享其在不同使用场景中的实际应用案例。</p><h3 id="4-1-DnsJumper软件介绍"><a href="#4-1-DnsJumper软件介绍" class="headerlink" title="4.1 DnsJumper软件介绍"></a>4.1 DnsJumper软件介绍</h3><h4 id="4-1-1-DnsJumper的功能特性"><a href="#4-1-1-DnsJumper的功能特性" class="headerlink" title="4.1.1 DnsJumper的功能特性"></a>4.1.1 DnsJumper的功能特性</h4><p>DnsJumper 以其轻量级和多功能性著称，它集成了 DNS 测速、切换、备份和恢复等多种功能。这些功能可以在不需要深入了解网络技术的情况下，简单快捷地帮助用户优化网络连接。</p><ul><li><strong>DNS 测速功能</strong> ：通过内置的测速功能，DnsJumper 能够测试多个 DNS 服务器的响应时间，帮助用户找出速度最快的 DNS 服务器进行连接。</li><li><strong>智能 DNS 切换</strong> ：DnsJumper 支持自动选择最佳的 DNS 服务器，采用智能算法根据响应时间进行优化。</li><li><strong>一键备份和恢复</strong> ：软件提供了简单快捷的 DNS 设置备份和恢复功能，确保在出现问题时能快速恢复到稳定状态。</li></ul><h4 id="4-1-2-软件界面与操作流程"><a href="#4-1-2-软件界面与操作流程" class="headerlink" title="4.1.2 软件界面与操作流程"></a>4.1.2 软件界面与操作流程</h4><p>DnsJumper 的用户界面直观明了，即使没有专业知识背景的用户也能快速上手。</p><ol><li><strong>打开 DnsJumper 软件</strong> ：用户可以双击桌面快捷方式或在程序文件夹中找到软件图标来启动 DnsJumper。</li><li><strong>使用测速功能</strong> ：在主界面中，用户可以看到“测试 DNS”按钮，点击之后软件会自动测试网络环境中的 DNS 服务器速度，并将结果以列表形式展示出来。</li><li><strong>切换 DNS</strong> ：用户可以根据测速结果，选择其中响应时间最短的 DNS 服务器，点击“应用”按钮来更改当前系统配置。</li><li><strong>备份与恢复</strong> ：如果用户想要备份当前的 DNS 设置，可以在菜单选项中选择“备份 DNS 设置”，并在需要时通过“恢复 DNS 设置”来还原。</li></ol><h3 id="4-2-DnsJumper的实际应用"><a href="#4-2-DnsJumper的实际应用" class="headerlink" title="4.2 DnsJumper的实际应用"></a>4.2 DnsJumper的实际应用</h3><h4 id="4-2-1-常见使用场景分析"><a href="#4-2-1-常见使用场景分析" class="headerlink" title="4.2.1 常见使用场景分析"></a>4.2.1 常见使用场景分析</h4><p>DnsJumper 的应用非常广泛，下面是几个常见使用场景的详细分析：</p><ul><li><strong>家庭网络优化</strong> ：对于家庭用户来说，使用 DnsJumper 可以有效地解决网络慢、打开网页卡顿等问题。通过简单几步操作，用户就可以找到最适合本地网络环境的 DNS 服务器，从而提高上网速度和稳定性。</li><li><strong>网吧或公共热点</strong> ：在网吧或咖啡厅等公共 Wi-Fi 环境，由于用户量大，DNS 服务器的响应时间可能会延长。使用 DnsJumper 可以帮助管理员快速找到并切换到响应速度更快的 DNS 服务器，改善上网体验。</li><li><strong>跨国办公网络</strong> ：对于跨国公司而言，不同国家和地区的网络环境差异较大。DnsJumper 可以帮助 IT 管理员快速评估和优化各个分支的 DNS 设置，提高办公效率。</li></ul><h4 id="4-2-2-使用DnsJumper进行DNS切换的实际案例"><a href="#4-2-2-使用DnsJumper进行DNS切换的实际案例" class="headerlink" title="4.2.2 使用DnsJumper进行DNS切换的实际案例"></a>4.2.2 使用DnsJumper进行DNS切换的实际案例</h4><p>让我们通过一个案例来看一下如何使用 DnsJumper 来进行 DNS 切换：</p><p>假设你是一名 IT 管理员，在一家拥有多个办公地点的跨国公司工作。某天，你接到报告称，位于纽约的办公室的网络访问速度很慢。为了诊断并解决问题，你决定使用 DnsJumper 进行以下步骤：</p><ol><li><strong>下载并安装 DnsJumper</strong> ：首先，你需要在受影响的办公室的电脑上下载并安装 DnsJumper。</li><li><strong>运行软件并测试 DNS</strong> ：打开 DnsJumper，使用其内置的测速功能来测试当前纽约办公室连接的 DNS 服务器速度。</li><li><strong>分析测试结果</strong> ：将测试结果与全球各大 DNS 服务器的平均响应时间进行比较，寻找是否存在明显的延迟。</li><li><strong>选择最佳 DNS 服务器</strong> ：根据测试数据，选择一个响应时间更短的 DNS 服务器。</li><li><strong>应用更改并监控效果</strong> ：使用 DnsJumper 应用新选的 DNS 服务器，并监控网络速度的提升情况。如果效果良好，则进行长期设置；如果效果不明显，可以尝试测试其他的 DNS 服务器。</li></ol><p>通过本案例可以清晰看到 DnsJumper 如何帮助解决网络性能问题，通过几步简单的操作，便可以大大改善网络访问质量。</p><h2 id="5-网络安全与设置方法"><a href="#5-网络安全与设置方法" class="headerlink" title="5. 网络安全与设置方法"></a>5. 网络安全与设置方法</h2><h3 id="5-1-DNS与网络安全的关系"><a href="#5-1-DNS与网络安全的关系" class="headerlink" title="5.1 DNS与网络安全的关系"></a>5.1 DNS与网络安全的关系</h3><h4 id="5-1-1-DNS劫持与防护措施"><a href="#5-1-1-DNS劫持与防护措施" class="headerlink" title="5.1.1 DNS劫持与防护措施"></a>5.1.1 DNS劫持与防护措施</h4><p>DNS劫持是一种常见的网络安全威胁，攻击者通过篡改DNS服务器的记录，使用户在访问网站时被重定向到恶意网站。这种攻击通常发生在用户访问不安全的网站，或者在用户设备被植入恶意软件的情况下。</p><p>为了防范DNS劫持，用户可以采取以下几种措施： - 使用安全的DNS服务，例如Google Public DNS（8.8.8.8和8.8.4.4）和Cloudflare（1.1.1.1）。 - 启用DNSSEC（域名系统安全扩展），通过加密DNS查询和响应来确保数据的完整性。 - 使用HTTPS来访问网站，而不是HTTP，因为HTTPS为数据传输提供加密保护。 - 维护操作系统和浏览器的最新安全补丁，防止恶意软件的入侵。</p><h4 id="5-1-2-安全的DNS设置指南"><a href="#5-1-2-安全的DNS设置指南" class="headerlink" title="5.1.2 安全的DNS设置指南"></a>5.1.2 安全的DNS设置指南</h4><p>设置一个安全的DNS环境是保护网络不受DNS劫持影响的关键步骤。以下是设置安全DNS的指南：- 首先，选择一个可靠的DNS提供商，并获取他们的DNS服务器地址。 - 在本地网络设备（如路由器）或操作系统中配置这些地址。如果设备支持，启用DNSSEC选项。 - 对于高级用户，可以配置防火墙规则，限制非授权的DNS查询。 - 定期检查DNS服务器的健康状态和响应时间，确保服务的可靠性。 - 对于企业用户，可以实施内部DNS系统，利用内部DNS服务器提供保护，同时减少对外部DNS服务的依赖。</p><h3 id="5-2-DNS切换对网络的影响"><a href="#5-2-DNS切换对网络的影响" class="headerlink" title="5.2 DNS切换对网络的影响"></a>5.2 DNS切换对网络的影响</h3><h4 id="5-2-1-正面与负面影响分析"><a href="#5-2-1-正面与负面影响分析" class="headerlink" title="5.2.1 正面与负面影响分析"></a>5.2.1 正面与负面影响分析</h4><p>DNS切换可以带来正面与负面影响。正面影响包括： - 提高网络速度：切换到更快的DNS服务器可以加快域名解析速度，从而提高整个网络的加载速度。 - 避免网络中断：在原DNS服务器出现问题时，切换到备用DNS可以减少或避免服务中断。 - 提升安全性：如前所述，切换到安全的DNS设置可以提升网络整体的安全性。</p><p>然而，DNS切换也可能带来一些负面影响： - 增加延迟：如果新DNS服务器响应较慢，那么可能会在短时间内增加DNS解析的延迟。 - 网络不稳定：频繁的DNS切换可能会导致网络连接不稳定。 - 配置错误风险：错误配置DNS设置可能会导致访问控制问题和网络服务中断。</p><h4 id="5-2-2-DNS切换的监控与调整策略"><a href="#5-2-2-DNS切换的监控与调整策略" class="headerlink" title="5.2.2 DNS切换的监控与调整策略"></a>5.2.2 DNS切换的监控与调整策略</h4><p>为了监控DNS切换带来的影响并及时调整策略，可以采取以下措施： - 使用网络监控工具（如Nagios或Zabbix）来跟踪DNS解析时间和网络性能指标。 - 制定监控阈值，一旦DNS解析时间超过设定阈值，系统就会发出警报。 - 定期检查DNS查询日志，以确定是否有异常的查询模式或频繁的失败。 - 实施DNS故障转移计划，确保在发现DNS问题时可以迅速切换到备用服务器。 - 根据监控结果和用户反馈调整DNS设置，并对策略进行优化。</p><p>通过上述方法，可以确保DNS切换既能够提升网络性能和安全性，又能够最小化可能产生的负面影响。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/weixin_42510243/article/details/147699615">DNS自动选择最佳服务器的实战指南</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">DNS</summary>
    
    
    
    <category term="编程类" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/"/>
    
    <category term="网络编程" scheme="https://zml3589110.github.io/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/categories/DnsJumper/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/categories/DNS/"/>
    
    
    <category term="网络协议" scheme="https://zml3589110.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="WIFI" scheme="https://zml3589110.github.io/tags/WIFI/"/>
    
    <category term="TCP/IP" scheme="https://zml3589110.github.io/tags/TCP-IP/"/>
    
    <category term="DNS" scheme="https://zml3589110.github.io/tags/DNS/"/>
    
    <category term="域名" scheme="https://zml3589110.github.io/tags/%E5%9F%9F%E5%90%8D/"/>
    
    <category term="DnsJumper" scheme="https://zml3589110.github.io/tags/DnsJumper/"/>
    
  </entry>
  
  <entry>
    <title>ESP01S基础资料</title>
    <link href="https://zml3589110.github.io/posts/1451356382.html"/>
    <id>https://zml3589110.github.io/posts/1451356382.html</id>
    <published>2025-09-09T03:45:20.000Z</published>
    <updated>2025-09-10T13:10:14.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="esp01和esp01s的区别"><a href="#esp01和esp01s的区别" class="headerlink" title="esp01和esp01s的区别"></a>esp01和esp01s的区别</h1><p>其实，两者都是安信可公司出的两款物联网模块。ESP-01S其实是ESP-01的升级版，具体修改了哪些地方，我们详细看下。</p><p><strong>首先</strong>，安信可目前在售的模块如下（图片转自安信可官网）：</p><img src="/posts/1451356382/word-image-22.png" class="" title="img"><p>你会发现目前ESP-01S在售，而ESP-01已经不卖了。所以，网上有些店铺依然在卖ESP-01的，个人推测有两种可能：1、清库存；2、个别用户专门用这个。</p><p><strong>其次</strong>，管脚定义如下：</p><img src="/posts/1451356382/word-image-23.png" class="" title="img"><img src="/posts/1451356382/word-image-24.png" class="" title="img"><p>你会发现，两者都是8个管脚，而且管脚定义一样。不光管脚定义一样，模块尺寸也一样：</p><img src="/posts/1451356382/word-image-25.png" class="" title="img"><p><strong>第三</strong>，指示灯与上拉电阻。根据官方提供的模组选型表，我们可以知道：</p><img src="/posts/1451356382/word-image-26.png" class="" title="img"><p>指示灯的管脚，由ESP-01的TXD0变成了ESP-01S的GPIO2。然后ESP-01S模块的IO0、RST、EN管脚上增加了上拉电阻。</p><p>增加这些电阻有什么用？看下一条！</p><p><strong>第四</strong>，典型应用电路。第三点提到了ESP-01S模块中增加了上拉电阻，而增加上拉电阻的意义在于，对典型应用电路进行优化。效果如下：</p><img src="/posts/1451356382/word-image-27.png" class="" title="img"><p>ESP-01</p><img src="/posts/1451356382/word-image-28.png" class="" title="img"><p>ESP-01S</p><p>对比两者，你会发现ESP-01S的应用电路简化了，省掉了两个上拉电阻。</p><p>其实，综上所述，你会发现ESP-01S是官方用来替换ESP-01的。毕竟在选型表里已经给出了建议。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="http://www.mcublog.cn/esp8266/2020_03/esp01-esp01s/">esp01和esp01s的区别</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">ESP01S基础资料收集</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="ESP8266" scheme="https://zml3589110.github.io/categories/ESP8266/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/categories/%E4%B9%90%E9%91%AB/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/categories/UART/"/>
    
    
    <category term="Ubuntu" scheme="https://zml3589110.github.io/tags/Ubuntu/"/>
    
    <category term="串口" scheme="https://zml3589110.github.io/tags/%E4%B8%B2%E5%8F%A3/"/>
    
    <category term="UART" scheme="https://zml3589110.github.io/tags/UART/"/>
    
    <category term="乐鑫" scheme="https://zml3589110.github.io/tags/%E4%B9%90%E9%91%AB/"/>
    
    <category term="ESP01S" scheme="https://zml3589110.github.io/tags/ESP01S/"/>
    
    <category term="ESP8266-12E/F" scheme="https://zml3589110.github.io/tags/ESP8266-12E-F/"/>
    
  </entry>
  
  <entry>
    <title>小白自制Linux开发板</title>
    <link href="https://zml3589110.github.io/posts/3433483963.html"/>
    <id>https://zml3589110.github.io/posts/3433483963.html</id>
    <published>2025-09-05T12:43:20.000Z</published>
    <updated>2025-09-10T13:10:14.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-瞎抄原理图与乱画PCB"><a href="#一-瞎抄原理图与乱画PCB" class="headerlink" title="一. 瞎抄原理图与乱画PCB"></a>一. 瞎抄原理图与乱画PCB</h1><p>因为墨云是基于高中物理水平的电路知识来学习、而且此前也就玩过树莓派、Esp8266之类的开发板，水平基础趋近于零，所以在写这个系列的时候抱着记录的心态、还望不足之处还望大佬们指正。</p><p>《论语》说：见贤思齐焉。所以现在墨云又开始瞎折腾了</p><p>为啥突然想做嵌入式开发呢，因为看见了下面两位牛人</p><p>【稚晖君】</p><p><a href="https://www.bilibili.com/video/av65365123/">https://www.bilibili.com/video/av65365123/</a></p><p>【在名片上运行的Business Card Linux】</p><p><a href="https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/"> https://www.thirtythreeforty.net/posts/2019/12/my-business-card-runs-linux/</a></p><p>于是躁动的心开始蠢蠢欲动。</p><p>先定个小目标：</p><p>　　<em>设计一个没啥作用，但是可以运行Linux的小板。</em></p><p>样子大概长这样：</p><p>　　<a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210609081210227-1578860150.png"><img src="/posts/3433483963/483434-20210609081210227-1578860150.png" class="" title="img"></a></p><p> 所以有了初步想法，那开始吧</p><h2 id="1-工具与芯片说明"><a href="#1-工具与芯片说明" class="headerlink" title="1. 工具与芯片说明#"></a>1. 工具与芯片说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#1.-%E5%B7%A5%E5%85%B7%E4%B8%8E%E8%8A%AF%E7%89%87%E8%AF%B4%E6%98%8E">#</a></h2><p><strong>立创EDA</strong>：电路图与PCB设计工具，本次硬件部分设计全部使用立创EDA完成</p><p><strong>F1C100s</strong> ：全志的一款基于Arm的小型Soc，自带32MB的内存，其升级版F1C200s为64MB内存，因为其极其便宜(当然最近因为芯片涨价影响)，可以运行Linux，最典型的基于该芯片的荔枝派开发板。</p><p><strong>CH340E</strong>：USB转串口通信芯片，是作为与外界通信的唯一接口 、CH340E个头小、外围电路少，使用简单。</p><p><strong>原理图</strong>：先后参考了(baipiao)了Licheepi Nano、Business LinuxCard、LiShanwenGit(<a href="https://www.oshwhub.com/LSW12315)%E7%AB%8B%E5%88%9B%E5%BC%80%E6%BA%90%E5%B9%BF%E5%9C%BA%E7%9A%84%E4%B8%80%E7%B3%BB%E5%88%97%E9%A1%B9%E7%9B%AE">https://www.oshwhub.com/LSW12315)立创开源广场的一系列项目</a></p><h2 id="2-原理图说明"><a href="#2-原理图说明" class="headerlink" title="2.原理图说明#"></a>2.原理图说明<a href="https://www.cnblogs.com/twzy/p/14714651.html#2.%E5%8E%9F%E7%90%86%E5%9B%BE%E8%AF%B4%E6%98%8E">#</a></h2><p> <strong>电源管理</strong></p><p> 电源部分使用USB方式供电，输入电压为5V，这里供电部分和串口电路共用相同USB端口。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100226272-904592004.png"><img src="/posts/3433483963/483434-20210607100226272-904592004.png" class="" title="img"></a></p><p>  通过查询F1c100s数据手册：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100558506-389190797.png"><img src="/posts/3433483963/483434-20210607100558506-389190797.png" class="" title="img"></a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210607100617030-1539276821.png"><img src="/posts/3433483963/483434-20210607100617030-1539276821.png" class="" title="img"></a></p><p> 通过综合分析，我们可以大概把电源分为4类</p><p>  Vdd-Core：1.1V</p><p>  Vcc-Dram：2.5V</p><p>  AVCC : 3.0V</p><p>  UVCC&#x2F;VCC-IO&#x2F;TV-AVCC&#x2F;TTL：3.3</p><p>  这里主要使用 SY8088AAC 同步降压DC-DC稳压器，为SOT32-5的封装方式，通过使用外围电阻调整输出电压。</p><p>  公式为：</p><p>​      <strong>Vout &#x3D; 0.6 * (&#96;1+Ra&#x2F;Rb)</strong> </p><p>而AVCC使用XC6206P302MR-SOT23的封装方式，输入5V 输出为3.0V</p><p>因为 AVCC为模拟电源电压，为了避免引入电源干扰，通常需要把把模拟电路与数字电路分开隔离开(这个地方解释可能不对，欢迎指正)。</p><p>电源部分的原理图如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075511811-1722536141.png"><img src="/posts/3433483963/483434-20210518075511811-1722536141.png" class="" title="img"></a></p><p>电压输入输出端都使用滤波电容进行处理，使用还要接入2.2uH的功率电感，注意一定要用功率电感，电流要求可以达到1A以及以上的才行</p><p>这个板子使用0805的功率电感，建议最好使用CD32类型的绕线功率电感。</p><p><strong>核心原理图</strong></p><p>对于核心部分的原理图如下，因为本次电路设计主要以验证为主，所以并没有做太多的外设电路。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075644565-3556161.png"><img src="/posts/3433483963/483434-20210518075644565-3556161.png" class="" title="img"></a></p><p>除了常规的核心、外围、DRAM工单引脚，核心部分还引出了</p><p> \1. TF卡引脚，作为本板子唯一的系统加载电路，这是必须的</p><p> 2.晶振，使用规格为24Mhz的有源晶振、加两个15pf的负载电容</p><p> 3.串口调试 作为板子与外界唯一交互的通道，这个也是必须的，然而在做这个成功的给自己挖坑了。</p><p> 4.LED灯，这是这个板子唯一的外设，也是用来学习驱动开发的第一步。</p><p> 5.dram_vref、Var1、Var2 这是必须要接的、外围电路，我也不知道的干啥的 <del>_</del>…</p><p> 6.USB OTG 也是作为一个通信接口来使用，通过这个接口可以为板载Flash下载程序，但是因为本板没有做Flash，所以目前唯一的作用就是放到验证fel是否可以调通。</p><p> 7.复位按钮</p><p><strong>挖坑点</strong></p><p>一直以来认为发光二极管也是二极管，所以就有下面的设计(乱画)，于是后来感觉板子没问题，但是就是串口死活不显示数据、在众多大佬的帮助下，才发现了这个其妙(naocan)</p><p>的接线方法，于是将两个发光二极管位置放了两个0欧的电阻，一下子就成功调通了。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518081301718-1938463553.png"><img src="/posts/3433483963/483434-20210518081301718-1938463553.png" class="" title="img"></a></p><p>对于芯片电源输入端的滤波电容与Dram_vref接线如下：</p><p>对于滤波电容简单的说法就是，对于供电端的电压，因为电路设计或者外界干扰等等，其实不是完美的电压，总会存在高频或是低频的噪声，而用小容量的电容就可以降低这些干扰。</p><p>常规的容值就是 10uf 、1uf、100nf</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075706884-1416748722.png"><img src="/posts/3433483963/483434-20210518075706884-1416748722.png" class="" title="img"></a></p><p><strong>通信电路</strong></p><p>我们在核心原理图中看到了引出的串口线路，而串口的接口如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608075946061-1759039430.png"><img src="/posts/3433483963/483434-20210608075946061-1759039430.png" class="" title="img"></a> <a href="https://img2020.cnblogs.com/blog/483434/202106/483434-20210608080015029-894589865.png"><img src="/posts/3433483963/483434-20210608080015029-894589865.png" class="" title="img"></a></p><p>显然在你看看你超博的笔记本机身，并没有发现这个接口，偶尔还有一些老的笔记本上面可以看到类似的接口，对不起——那是显示屏的VGA接口。</p><p>那我们如何使用串口传输的信息呢，我们需要一个USB转串口的芯片，usb转串口的芯片很多，这里选择 CH340E 这个型号，因为其很小，接线也方便。</p><p>原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075726899-441537012.png"><img src="/posts/3433483963/483434-20210518075726899-441537012.png" class="" title="img"></a></p><p>前面提到，这个板子共用了电源与TTL共用了一套设计，也就是是说USB线插上就可以启动小板，并且开始进入串口调试。</p><p>原理图中的U5是一个自恢复保险丝。</p><p><em>这里需要注意一下：</em></p><p> 根据CH340E官方的原理图，当VCC接入5V的时候，V3 需要接一个100nf的电容，但是此处在V3直接接入5V，也可以工作。</p><p> 实际使用的时候最好不要这样做。</p><p><strong>TF卡接口</strong></p><p>和电脑主机在BIOS选择启动方式一样， F1C100s 支持多种方式的系统加载机制比如通过SPI接口加载Flash芯片中的镜像，或者通过TF卡接口加载镜像。</p><p>这里使用TF卡作为启动源，这样做是因为</p><p> 1.TF卡容量可以自己控制。</p><p> 2.系统烧写调试方便</p><p>这部分电路相对简单，原理图如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075745633-24558076.png"><img src="/posts/3433483963/483434-20210518075745633-24558076.png" class="" title="img"></a></p><p><strong>OTG 与唯一的外设LED灯</strong></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075809957-1231071962.png"><img src="/posts/3433483963/483434-20210518075809957-1231071962.png" class="" title="img"></a></p><h2 id="3-PCB绘制"><a href="#3-PCB绘制" class="headerlink" title="3.PCB绘制#"></a>3.PCB绘制<a href="https://www.cnblogs.com/twzy/p/14714651.html#3.pcb%E7%BB%98%E5%88%B6">#</a></h2><p> PCB尺寸为42mm*29mm ，可以说非常小了，为了便于焊接，所有容阻都是用0805的封装方式</p><p> 电源走线为14mil ，信号线为8mil</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518075900597-2044589685.png"><img src="/posts/3433483963/483434-20210518075900597-2044589685.png" class="" title="img"></a></p><h2 id="4-PCB焊接"><a href="#4-PCB焊接" class="headerlink" title="4.PCB焊接#"></a>4.PCB焊接<a href="https://www.cnblogs.com/twzy/p/14714651.html#4.pcb%E7%84%8A%E6%8E%A5">#</a></h2><p> 焊接PCB是一项手艺活，尤其是QFN方式封装的F1C100s 更是难到发指，还好借助焊台和热风枪，完美的完成了焊接，当然放大镜、洗板水是不可缺少的。</p><p> 并且因为板子时长需要在手上把玩（盘PCB）。所以选择了无铅稀浆进行焊接。</p><p>效果如下：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080628282-1076112978.png"><img src="/posts/3433483963/483434-20210518080628282-1076112978.png" class="" title="img"></a><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080325298-910819870.png"><img src="/posts/3433483963/483434-20210518080325298-910819870.png" class="" title="img"></a></p><p>成功运行Linux，</p><p>因为还没开始着手做Linux移植，暂时使用LicheePi 的镜像，下一节开始做Linux的移植。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080244837-276955395.png"><img src="/posts/3433483963/483434-20210518080244837-276955395.png" class="" title="img"></a></p><h2 id="5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记"><a href="#5-后记-https-www-cnblogs-com-twzy-p-14714651-html-5-后记" class="headerlink" title="5. 后记[#](https://www.cnblogs.com/twzy/p/14714651.html# 5.-后记)"></a>5. 后记[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 5.-后记)</h2><p>事实上世界上从来没有所谓轻易的成功，对于初次玩PCB的小白更是如此，现在这个小板能成功也是经历三四个月，五六次打板才成功的。以下是早期的趟雷PCB场景与先烈。 (右下角为成功的小板)</p><p><a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080712817-696267996.png"><img src="/posts/3433483963/483434-20210518080712817-696267996.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202105/483434-20210518080742813-715067385.png"><img src="/posts/3433483963/483434-20210518080742813-715067385.png" class="" title="img"></a></p><h3 id="硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包："><a href="#硬件资料包：-https-www-cnblogs-com-twzy-p-14714651-html-硬件资料包：" class="headerlink" title="硬件资料包：[#](https://www.cnblogs.com/twzy/p/14714651.html# 硬件资料包：)"></a>硬件资料包：[#](<a href="https://www.cnblogs.com/twzy/p/14714651.html#">https://www.cnblogs.com/twzy/p/14714651.html#</a> 硬件资料包：)</h3><p><a href="https://files.cnblogs.com/files/twzy/LinuxNano%E5%B7%A5%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%E5%9B%BE-%E5%A2%A8%E4%BA%91.zip"> 下载</a></p><h1 id="二-u-boot移植"><a href="#二-u-boot移植" class="headerlink" title="二. u-boot移植"></a>二. u-boot移植</h1><p>我们都知道，PC在启动的时候，首先是进入BIOS，再根据BIOS中配置信息引导后续的启动操作系统，比如配置Windows启动。</p><p>而对于嵌入式linux中，并没有BIOS，这时候就需要一种类似引导程序来处理。于是就有了BootLoader。</p><p>BootLoader是一段小程序，可以把它想象成PC机linux上的GRUB&#x2F;LILO引导程序，可以直接从flash或TF卡中运行，来装载内核。它可以初始化硬件设备，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统做好准备。</p><h2 id="1-嵌入式开发板的启动过程"><a href="#1-嵌入式开发板的启动过程" class="headerlink" title="1. 嵌入式开发板的启动过程#"></a>1. 嵌入式开发板的启动过程<a href="https://www.cnblogs.com/twzy/p/14865952.html#1.-%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">#</a></h2><p>一个嵌入式系统从软件角度来看分为三个层次：</p><ul><li>引导加载程序</li></ul><p>​      包括固化在芯片中的boot程序（可选）和BootLoader两大部分，对于固化的boot程序。主要是芯片通过外围电路连接的实际情况选择读入程序的位置，比如：通过TF卡或是SPI以及其他方式启动，至于优先顺序这就要具体看芯片的数据手册，个人没做过具体测试。</p><ul><li>linux内核</li></ul><p>​     特定于嵌入式平台的定制内核</p><ul><li>文件系统</li></ul><p>​     包括了系统命令和应用程序</p><table><thead><tr><th>BootLoader</th><th>Boot Parameters</th><th>Kernel</th><th>Root Filesystem</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>BootLoader</strong>启动过程可分为单阶段和多阶段(stage1、stage2),其中stage1完成初始化硬件，如CPU寄存器、内存控制器，为stage2准备内存空间。一般stage1是可以直接在nor flash中运行的，并将stage2复制到内存RAM中，设置堆栈，然后跳转到stage2(从这也可以看出stage2是在RAM中运行的，与stage1不同)</p><p><strong>Boot Parameters</strong> 顾名思义，就是配置了要启动内核的参数，包含要加载系统内核相关文件的位置，要加载到内存中的位置，定位到文件系统的位置，相关输入输出的呈现等一系列参数。</p><p><strong>kernel</strong> 在存放在bootloader之后，对于SoC来说，代码都需要在RAM中运行，这里与MCU不一样的地方就是引入了MMU（内存管理单元）。对于MCU而言，由于其执行速度低，因此运行代码都在ROM中直接运行，而对于Flash而言，其读取速度远不及RAM的速度，因此对于运行速度非常快的SoC而言，所有的代码都需要在RAM中运行。但是这里有一个问题，RAM掉电数据将会丢失，故代码保存不可能放在RAM中，当前所有的嵌入式设备而言，代码保存都是放在ROM中，因此在SoC中运行代码需要将代码搬运到RAM中然后再执行。</p><p><strong>Root Filesystem</strong> 由于其执行过程需要对ROM进行读写操作，因此可以不用搬运到RAM中，但是实际过程中内核启动后会产生一个虚拟的文件系统，该文件系统是挂在根文件系统的关键所在，这里不详细讲解。整体来说，大致的过程为，嵌入式设备上电后将执行bootloader，对硬件进行硬件和堆栈初始化，然后搬运内核到RAM中并启动内核，紧接着挂载根文件系统。</p><h2 id="2-环境配置与参考项目"><a href="#2-环境配置与参考项目" class="headerlink" title="2. 环境配置与参考项目#"></a>2. 环境配置与参考项目<a href="https://www.cnblogs.com/twzy/p/14865952.html#2.-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%8E%E5%8F%82%E8%80%83%E9%A1%B9%E7%9B%AE">#</a></h2><p>系统：Ubuntu 16</p><p>编辑器：VSCode</p><p>参考项目：Lichee-Pi Nano </p><p>地址：<a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080525817-1455821238.png"><img src="/posts/3433483963/483434-20210826080525817-1455821238.png" class="" title="img"></a></p><p>Lichee-Pi Nano</p><p>需要注意的是一定要选择Nano版本，因为我们开发板使用的主控芯片和Nano的主控是一致的，所以后续我们要编译U-boot，内核都可以参考(bai piao)这里面的配置。</p><p>主控芯片：F1c100s&#x2F;F1c200s，100s内置32MB DDR1内存，200s内置64MB DDR1内存，200s贵一点，他们都是QFN88封装。</p><p>ARM926ejs内核，主频默认408MHz，据了解做产品出货的一般在600M左右。</p><p>带有100M的SPI接口2个，SDIO接口1个，USB OTG接口，还有CSI摄像头接口，LCD RGB显示屏接口，音频接口，I2C I2S UART PWM等等。</p><p>还有就是他们不支持硬件浮点，所以浮点运算使用软浮点方式。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210826080450826-950498006.png"><img src="/posts/3433483963/483434-20210826080450826-950498006.png" class="" title="img"></a></p><p> F1c100s&#x2F;F1c200s芯片功能</p><h2 id="3-交叉编译器"><a href="#3-交叉编译器" class="headerlink" title="3.交叉编译器#"></a>3.交叉编译器<a href="https://www.cnblogs.com/twzy/p/14865952.html#3.%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%99%A8">#</a></h2><p>  我们通过PC版的Linux自带的gcc编译的程序只能在当前系统架构下的cpu架构(x86)下运行，如果我们想要编写的程序在嵌入式Linux下运行，那么就需要用到对应的编译器。</p><p>  我们做的开发板主控芯片F1C200S，内核为ARM9，其架构使用的是ARMv5架构，所以我们也要选用对应的编译器，同样，这样的编译器很多，这里我们使用最常用的arm-linux-gnueabi- ，因为交叉编译器F1C200S必须高于6.0版本，这里我们使用7.2版本</p><p>  <a href="https://releases.linaro.org/components/toolchain/binaries/7.2-2017.11/arm-linux-gnueabi/gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz"> 点击下载</a></p><p>  <em>下载较慢时使用下载工具</em></p><p>下载完成后解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxjf gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi.tar.xz</span><br></pre></td></tr></table></figure><p>然后在&#x2F;usr&#x2F;local目录下新建arm-linux-gcc目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc</span><br></pre></td></tr></table></figure><p>进入解压目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd gcc-linaro-7.2.1-2017.11-x86_64_arm-linux-gnueabi&#x2F;</span><br></pre></td></tr></table></figure><p>将该目录下的所有文件复制到新建的目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -rd * &#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;</span><br></pre></td></tr></table></figure><p>最后需要添加该工具链的环境变量使其可以在任何目录下执行，打开&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>在文件末尾添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;arm-linux-gcc&#x2F;bin</span><br></pre></td></tr></table></figure><p>添加完毕，使路径生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>接下来在终端输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-</span><br></pre></td></tr></table></figure><p>然后连按两次Tab键，如图在表示成功：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202108/483434-20210823161114895-675144161.png"><img src="/posts/3433483963/483434-20210823161114895-675144161.png" class="" title="img"></a></p><p>如果没有出现，则进行下面操作，安装必要的动态链接库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lib32ncurses5 lib32z1</span><br></pre></td></tr></table></figure><p>至此，我们完成了编译工具的配置。</p><h2 id="4-编译U-boot"><a href="#4-编译U-boot" class="headerlink" title="4. 编译U-boot#"></a>4. 编译U-boot<a href="https://www.cnblogs.com/twzy/p/14865952.html#4.-%E7%BC%96%E8%AF%91u-boot">#</a></h2><p> 当Arm开发板上电以后第一个要加载到内存并运行的程序就是**BootLoader，**BootLoader****的同类型程序很多，如U-boot、X-boot、Rt-Thread，这里我们依然选中最常用的U-boot作为目标(因为其他的我也不会呀)，</p><p> 最新版本的uboot几乎包含当前主流的SoC芯片，前面提到本开发板使用的芯片和licheePI nano相同，大部分硬件也是兼容的，为了快速移植该部分，这里采用licheePI nano的u-boot来进行移植。在终端输入如下命令克隆u-boot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;Lichee-Pi&#x2F;u-boot.git -b nano-v2018.01</span><br></pre></td></tr></table></figure><p>克隆完毕文件会保存在当前目录下，进入该目录，*<br>*</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd u-boot</span><br></pre></td></tr></table></figure><p>在该文件夹下有很多分支，我们可以查看所有分支，使用如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><p>现在我们使用的是nano开发板，所以将当前分支切换到nano分支，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout nano-v2018.01u-boot</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928150820570-1873390261.png"><img src="/posts/3433483963/483434-20210928150820570-1873390261.png" class="" title="img"></a></p><p> 切换到Nano分支</p><p>默认的没有指定交叉工具链和架构，因此在编译之前需要指定交叉工具链和芯片架构，u-boot的交叉编译器在u-boot 的根目录下中的<strong>Makefile</strong>文件中定义了。打开文件找到<strong>CROSS_COMPILE</strong>变量，修改为如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH&#x3D;arm</span><br><span class="line">CROSS_COMPILE&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151000818-1228538185.png"><img src="/posts/3433483963/483434-20210928151000818-1228538185.png" class="" title="img"></a></p><p> 配制交叉编译环境</p><p>这样我们就能使用我们指定的编译器来编译u-boot了。</p><p>在u-boot项目的config目录下存在对多种板子的配置描述文件，由于每个板子的外设不同，因此编译之前必须要对u-boot进行配置。然而配置是一件比较繁琐的事情，特别是像u-boot这种比较复杂的项目而言，初学者几乎无法完成。幸运的是对于大部分开发板而言，config目录下有其配置好的默认配置文件。进入config目录中，然后执行ls查看当前所有的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd config</span><br><span class="line">ls</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151205314-374311839.png"><img src="/posts/3433483963/483434-20210928151205314-374311839.png" class="" title="img"></a></p><p> 查看配制文件</p><p>找到<strong>licheepi_nano_defconfig</strong> 和 <strong>licheepi_nano_spiflash_defconfig</strong>，前者表示为TF卡启动，后者表示从SPI 设备启动，因为我们做的小板只有从TF卡启动，所以我们需要使用 <strong>licheepi_nano_defconfig</strong> 。</p><p>现在回到上级目录，然后执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make licheepi_nano_defconfig</span><br></pre></td></tr></table></figure><p>这样我们把<strong>licheepi_nano_defconfig</strong> 作为默认配置项。</p><p>接下来我们就可以用图形界面进行配置了，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时出现图形配置选项，如下图所示</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928151406633-1920865408.png"><img src="/posts/3433483963/483434-20210928151406633-1920865408.png" class="" title="img"></a></p><p> u-boot Menuconfig配制，注意红框中的配置，我们后续要用到。</p><p>至此我们的u-boot环境配置就完成了，但是我们还有个问题要解决：<strong>如何让u-boot引导系统</strong></p><p>我们在PC端安装Windows系统的时候往往需要选择启动顺序，比如需要优先通过光驱或u盘启动等。</p><p>同样在u-boot中也需要这样的配置，当然u-boot比PC配置稍微复杂一丢丢。我们前面提到Linux嵌入式系统结构分布中有个Boot Parameters 部分，这部分就是做引导配置的，那怎么配置呢，总体来说可以分为两部分：</p><ol><li>bootcmd，主要用于描述控制Linux内核文件以及其他描述文件加载到内存中位置以及启动Linux内核系统等</li><li>bootargs，用于配制文件系统、串口信息等。</li></ol><p><strong>bootcmd</strong></p><p>在最开始提到过，内核一般不在flash中运行，这样就需要将内核搬运到内存中，这个过程需要u-boot来完成。对于mmc (TF卡)而言，在u-boot有专门的命令<strong>load mmc</strong>，该命令可以将mmc中的代码从flash搬运到指定的地址处。</p><p>当u-boot中环境变量bootdelay计数到0时，此时uboot就会开始执行bootcmd中的命令。</p><p>bootdelay这个环境变量是一个计数器，当u-boot主体运行完毕后，此时bootdelay该变量的值将会开始递减，递减时间为1s，当递减到0时，此时u-boot将会跳转到bootcmd处开始执行bootcmd命令，（你可以简单理解为PC启动后有一两秒时间等待，你可以可以通过F8或Enter键打断进入Bios设置的过程，这个等待时间就由u-boot中的bootdelay来控制）。</p><p>下面我们需要记住这句指令，这就是我们当前制作的开发板需要用到的bootcmd全部内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>如果你需要详细了解这句话那就接着往下看，如果不需要则可以跳到 下面的u-boot参数配置环节</p><p>对于上面命令，我们根据分号拆分为3部分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt; load mmc 0:1 0x80008000 zImage;</span><br><span class="line">2&gt; load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;</span><br><span class="line">3&gt; bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p>其中两个 load mmc 命令、一个bootz 命令。</p><p>先看第一条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage</span><br></pre></td></tr></table></figure><p>load mmc有三个参数：第一个参数是mmc(TF卡)分区，第二个参数是内存中目标地址，第三个参数是源文件。</p><p>即上面的命令意思是<strong>将mmc的0:1 分区中的zImage复制到内存中的0x80008000地址处。</strong>这里的zimage就是Linux内核，后续会提到该文件编译，0:1这个可以这样理解0表示TF卡(TF卡属于mmc存储器的一种)，1这表示TF卡的第一个分区(boot分区)后面会提到。</p><p>而对于内存位置 <strong>0x80008000</strong> 地址位置，将其理解为默认值就行了。这样完成了zImage的加载。</p><p>下面分析第二条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb</span><br></pre></td></tr></table></figure><p>有了上面的加载zImage的说明，可以很轻松的理解上面的命令意思是将mmc的0:1分区中的suniv-f1c100s-licheepi-nano.dtb文件加载到内存中的0x80c08000地址处。对于<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 这个文件，叫做设备树文件，简单来说就是当前开发板上面所有外设备描述文件，这部分将会在后续内核编译部分进行详细说明。</p><p>对于第三条命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootz 0x80008000 - 0x80c08000</span><br></pre></td></tr></table></figure><p>的意思是告诉内核镜像的起始地址为0x80008000，加载的设备树地址为0x80c08000。这里是告诉cpu从这里开始启动Linux， bootz命令的格式是：bootz空格0x80008000空格-空格0x80c08000,注意-左右有空格。</p><p>除了bootz 命令外，有些系统里面还可能存在一个叫做bootm命令，这是是对没有使用设备树内核的镜像启动命令，早期版本的内核没有引入设备树，因此对于早期的内核一般使用的是bootm，其命令格式为bootm内核地址，比如bootm x0x30008000，意思是从0x30008000开始启动内核，启动内核的过程其实是将pc指针指向该地址，这样处理器就会从该地址处运行代码。</p><p> 这里我们就完成了bootcmd的说明，接下来我们看另外一个参数。</p><p><strong>bootargs</strong></p><p>bootargs也是u-boot环境变量中一个非常重要的变量，上面已经讲解了内核的启动可以通过bootcmd来完成，那接下来内核启动完毕后必须挂在根文件系统(rootfs)。但是内核并不知道根文件系统的具体位置，我们必须要告诉根文件的位置后内核才能将其挂载，这时就需要有bootargs变量。该变量的作用是告诉内核根文件系统的位置和属性以及必要的配置，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p>同上面分析的方法一样，我们依然将这部分命令拆成几部分来说明。这里需要说明的是，这部分配置信息是由u-boot 直接按照参数字符串方式提供给Linux内核，然后由Linux内核进行执行的，这也说明里为什么格式与bootcmd配置方式不一致。</p><p><strong>console&#x3D;ttyS0,115200</strong> 表示终端为ttyS0即串口0,波特率为115200；</p><p><strong>panic&#x3D;5</strong> 字面意思是恐慌，即linux内核恐慌，其实就是linux不知道怎么执行了，此时内核就需要做一些相关的处理，这里的5表示超时时间，当Linux卡住5秒后仍未成功就会执行Linux恐慌异常的一些操作。</p><p><strong>rootwait</strong> 该参数是告诉内核挂在文件系统之前需要先加载相关驱动，这样做的目的是防止因mmc驱动还未加载就开始挂载驱动而导致文件系统挂载失败，所以一般bootargs中都要加上这个参数。</p><p><strong>root&#x3D;&#x2F;dev&#x2F;mmcblk0p2</strong> 表示根文件系统的位置在mmc的0:2分区处，**&#x2F;dev<strong>是设备文件夹，内核在加载mmc中的时候就会在根文件系统中生成</strong>mmcblk0p2**设备文件，这个设备文件其实就是mmc的0:2分区(这里对应TF卡的第二个分区：rootfs)，这样内核对文件系统的读写操作方式本质上就是读写&#x2F;dev&#x2F;mmcblk0p2该设备文件。</p><p><strong>earlyprintk</strong> 参数是指在内核加载的过程中打印输出信息，这样内核在加载的时候终端就会输出相应的启动信息。rw表示文件系统的操作属性，此处rw表示可读可写。</p><h2 id="5-u-boot参数配置"><a href="#5-u-boot参数配置" class="headerlink" title="5.u-boot参数配置 #"></a>5.u-boot参数配置 <a href="https://www.cnblogs.com/twzy/p/14865952.html#5.u-boot%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE">#</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p> 选中  <strong>Enable boot arguments</strong> 按空格选中，下面会显示：() <strong>Boot arguments</strong></p><p>然后选中<strong>Boot arguments</strong> ,按回车，进入配置窗口，接下来上面解释过的<strong>bootargs</strong> 参数信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2 earlyprintk rw</span><br></pre></td></tr></table></figure><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152101050-1297588046.png"><img src="/posts/3433483963/483434-20210928152101050-1297588046.png" class="" title="img"></a></p><p> 配置bootargs信息</p><p>然后按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><p>同理配置：<strong>Enable a default value for bootcmd</strong> 按空格选中，下面会显示：**() bootcmd value** 配置项，</p><p>选中<strong>bootcmd value</strong> 进入配置界面，输入bootcmd命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 0x80008000 zImage;load mmc 0:1 0x80c08000 suniv-f1c100s-licheepi-nano.dtb;bootz 0x80008000 - 0x80c08000;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152626755-371939279.png"><img src="/posts/3433483963/483434-20210928152626755-371939279.png" class="" title="img"></a></p><p> 配置bootcmd参数</p><p> 按<strong>Tab</strong>键选中**<OK>**，保存并进入主菜单。</p><h2 id="6-u-boot编译与烧录"><a href="#6-u-boot编译与烧录" class="headerlink" title="6.u-boot编译与烧录#"></a>6.u-boot编译与烧录<a href="https://www.cnblogs.com/twzy/p/14865952.html#6.u-boot%E7%BC%96%E8%AF%91%E4%B8%8E%E7%83%A7%E5%BD%95">#</a></h2><p>先保存图形配置界面后推出界面，在终端执行make -j4即可对整个u-boot进行编译。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928152943605-978425396.png"><img src="/posts/3433483963/483434-20210928152943605-978425396.png" class="" title="img"></a></p><p>编译u-boot</p><p><strong>make -j4</strong>后面的-j4表示4个核心进行编译，若电脑的处理器是2核心，请使用make -j2进行编译。</p><p>编译完成后会在当前目录生成<strong>u-boot-sunxi-with-spl.bin</strong>烧录文件。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210928153312700-1418379375.png"><img src="/posts/3433483963/483434-20210928153312700-1418379375.png" class="" title="img"></a></p><p>根目录下找到 <strong>u-boot-sunxi-with-spl.bin</strong> 文件</p><p>该文件就是我们最终要烧录的二进制文件。</p><p>在当前目录下会有一个隐藏的文件.config，该文件是u-boot编译后根据各个选项产生的配置文件，这个配置文件记录了所有配置选项的宏开关，编译的时候是根据最终的.config文件来进行编译的，当然编译前是需要有脚本解析.config文件然后进行相应的编译。</p><p>烧录到TF卡</p><p>只要将u-boot-sunxi-with-spl.bin烧录到tf卡的8k偏移处地址就可以了，烧录步骤如下：使用dd命令进行块搬移：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dd if&#x3D;u-boot-sunxi-with-spl.bin of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1024 seek&#x3D;8</span><br></pre></td></tr></table></figure><p>该命令中：</p><p>​    <strong>if</strong>  文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if&#x3D;input file &gt;</p><p>​    <strong>of</strong>  文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of&#x3D;output file &gt;</p><p>​    <strong>bs</strong> bytes：同时设置读入&#x2F;输出的块大小为bytes个字节。</p><p>​    <strong>seek</strong> blocks：从输出文件开头跳过blocks个块后再开始复制。</p><p>这里的输出文件(<strong>of</strong>)为主机电脑的&#x2F;dev&#x2F;sdb文件，也就是TF卡，这里也体现了Linux一切皆文件的思想。</p><p><strong>&#x2F;dev&#x2F;sdb</strong> 这个可以用gparted 软件查看，该软件可以直接用命令安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>此时在Ubuntu下面可以看到如下软件：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081032210-139894885.png"><img src="/posts/3433483963/483434-20210930081032210-139894885.png" class="" title="img"></a></p><p>安装好GParted软件</p><p> 打开软件</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930081827917-1823480007.png"><img src="/posts/3433483963/483434-20210930081827917-1823480007.png" class="" title="img"></a></p><p>GParted</p><p>在右上角可以看到两个硬盘，&#x2F;dev&#x2F;sda 为本地硬盘，&#x2F;dev&#x2F;sdb 是我们将要写数据的TF(当然这只是墨云自己的配置使然，具体情况请根据实际情况而定)，因此这里的of&#x3D;&#x2F;dev&#x2F;sdb 烧录到8k偏移地址处是指绝对地址，这个绝对地址指的是TF卡的物理地址。这8K的值是由F1C200S 中固化的启动代码决定的，所以照抄即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930082436650-910788822.png"><img src="/posts/3433483963/483434-20210930082436650-910788822.png" class="" title="img"></a></p><p>烧写u-boot</p><p>然后我们正常退出TF卡，然后插入我们自制的开发板，通过USB线连接电脑，</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085606475-1688206025.png"><img src="/posts/3433483963/483434-20210930085606475-1688206025.png" class="" title="img"></a></p><p>连接开发板</p><p>打开电脑中的命令行工具，我这里使用Xshell，</p><p>打开Xshell，新建连接：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084928442-133473812.png"><img src="/posts/3433483963/483434-20210930084928442-133473812.png" class="" title="img"></a></p><p>配置名称 ，协议选择Serial,</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930085149724-1946801432.png"><img src="/posts/3433483963/483434-20210930085149724-1946801432.png" class="" title="img"></a></p><p> 配置串口</p><p>通过下拉选中com端口，波特率为115200，其他默认即可，点击确定，然后双击主界面左侧会话管理中的刚建立的会话，此时进入连接状态。</p><p>因为在你插入USB通电的时候开发板就已经启动了，所以当你打开串口连接的时候可能未必会看到信息，所以按一下重启键，就可以看到如下的输出信息了，这就是我们的u-boot，执行到u-bbot计数完成后会产生错误，那是因为我们还没有进行系统内核的移植，所以默认就会进入u-boot命令模式。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930084405807-1935485286.png"><img src="/posts/3433483963/483434-20210930084405807-1935485286.png" class="" title="img"></a></p><p> 启动信息</p><p> 输入pri命令打印环境变量的所有值，可以找到已经配置的bootcmd 和bootargs</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930090109593-1345294928.png"><img src="/posts/3433483963/483434-20210930090109593-1345294928.png" class="" title="img"></a></p><p> pri命令结果</p><p>至此完成了u-boot移植的全部内容，对于u-boot的移植方法，在后续移植Linux内核和文件系统时都会用到，都是大同小异的，所以有了本篇的说明，之后操作将会非常简单。</p><p>而关于u-boot的内容事实上非常的复杂繁琐，有兴趣的可以自行去了解到，毕竟作为一个小白的我初衷只是先让小板先跑起来。</p><h2 id=""><a href="#" class="headerlink" title="#"></a><a href="https://www.cnblogs.com/twzy/p/14865952.html#">#</a></h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料#"></a>参考资料<a href="https://www.cnblogs.com/twzy/p/14865952.html#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">#</a></h2><blockquote><p>Lite200 (lishanwen) – <a href="https://lishanwen.cn/index.php/2021/07/03/lite200/">https://lishanwen.cn/index.php/2021/07/03/lite200/</a></p><p>全志F1C200S F1C100S 介绍 ( 迪卡魏曼依奇君 ) <a href="https://blog.csdn.net/tunqimai9331/article/details/95938903">https://blog.csdn.net/tunqimai9331/article/details/95938903</a></p><p>荔枝派Nano 全流程指南 (矽速科技) <a href="https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html">https://wiki.sipeed.com/soft/Lichee/zh/Nano-Doc-Backup/index.html</a></p></blockquote><h1 id="三-Linux内核与文件系统移植"><a href="#三-Linux内核与文件系统移植" class="headerlink" title="三. Linux内核与文件系统移植"></a>三. Linux内核与文件系统移植</h1><h2 id="1-Linux内核"><a href="#1-Linux内核" class="headerlink" title="1.Linux内核#"></a>1.Linux内核<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.linux%E5%86%85%E6%A0%B8">#</a></h2><p>事实上对于F1C100S&#x2F;F1C200S，Linux官方源码已经对licheepi nano进行支持。所以我们完全可以通过licheepi nano的配置文件进行移植。</p><h3 id="1-1-下载内核源码"><a href="#1-1-下载内核源码" class="headerlink" title="1.1. 下载内核源码#"></a>1.1. 下载内核源码<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.1.-%E4%B8%8B%E8%BD%BD%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81">#</a></h3><p>进入Linux系统官网：</p><p><a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145110377-1315647665.png"><img src="/posts/3433483963/483434-20210930145110377-1315647665.png" class="" title="img"></a></p><p>这里面列出的都是一些主要版本，如主线版本，上时间支持版本，个人推荐使用最新的长时间支持版本（5.10.69）。但是因为我这个项目是在参考一位大神的文档的基础上构建的，所以使用的是5.7.1版本，接下来就给一个选择其他版本的方式。</p><p>选择任意一项点击 [browse]</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145220044-1573759475.png"><img src="/posts/3433483963/483434-20210930145220044-1573759475.png" class="" title="img"></a></p><p>在新打开页面选择 【summary】点击【tag】中的【…】切换下载</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930145316299-265231365.png"><img src="/posts/3433483963/483434-20210930145316299-265231365.png" class="" title="img"></a></p><p> 如果想要直接下载5.7.1版本，请直接使用下面的连接</p><p><a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz">https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/linux-5.7.1.tar.gz</a></p><p>下载后完成后，将代码复制到Ubuntu虚拟机并解压源码。</p><h3 id="1-2-配置编译"><a href="#1-2-配置编译" class="headerlink" title="1.2.配置编译#"></a>1.2.配置编译<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.2.%E9%85%8D%E7%BD%AE%E7%BC%96%E8%AF%91">#</a></h3><p>与上一篇中编译u-boot一样，我们也需要配置对Linux编译进行配置：</p><ul><li>指定架构类型</li><li>指定交叉编译工具</li><li>项目配置</li></ul><p>指定架构，就这个很好理解，就是指定CPU类型，就是配置为Arm就行，交叉编译工具即为上一篇已经安装好的编译工具。</p><p>用VS打开Linux内核代码，找到<strong>Makefile</strong>文件：</p><p>修改如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH              ?&#x3D; arm</span><br><span class="line">CROSS_COMPILE     ?&#x3D;arm-linux-gnueabi-</span><br></pre></td></tr></table></figure><p>如果没找到ARCH 或 CROSS_COMPILE字段，自己手动添加也行，如下图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930151530833-1001068341.png"><img src="/posts/3433483963/483434-20210930151530833-1001068341.png" class="" title="img"></a></p><blockquote><p> 事实上这两个字段可以不用指定，在进行make的时候加上对应的参数就行，这里为了避免麻烦，所以直接放到了makefile文件中</p></blockquote><p>接下来就是指定项目配置了，这个操作就是让Linux内核认F1C100S&#x2F;F1C200S这颗soc。</p><p>进入内核源码中的<strong>arch&#x2F;arm&#x2F;configs</strong>目录中，可以看到有很多开发板的配置文件，其中<strong>sunxi_defconfig</strong>是全志的配置文件，但是该配置文件非常不全，需要额外配置大量的选项，一般选项多大上千个，这里先使用licheepi_nano的配置文件。</p><p><a href="https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip"> https://files.cnblogs.com/files/twzy/linux-licheepi_nano_defconfig.zip</a></p><p>下载该文件，解压出<strong>linux-licheepi_nano_defconfig</strong>，然后将其放到arch&#x2F;arm&#x2F;configs&#x2F;目录下</p><p><a href="https://img2020.cnblogs.com/blog/483434/202109/483434-20210930154001937-799886630.png"><img src="/posts/3433483963/483434-20210930154001937-799886630.png" class="" title="img"></a></p><p> 然后通过终端进入Linux-5.7.1根目录，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005103913552-1730316057.png"><img src="/posts/3433483963/483434-20211005103913552-1730316057.png" class="" title="img"></a></p><p> 进入图形配置界面，如图所示：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211005104057991-2077580949.png"><img src="/posts/3433483963/483434-20211005104057991-2077580949.png" class="" title="img"></a></p><p>该界面和u-boot配置一样，所以操作方式也是一样的，上下键移动选项，使用空格键进行选中或取消选择，同样通过空格键或回车键，进入子选项配置，通过Tab键选择保存和退出即可返回上级菜单或命令行界面，也可以直接双击Esc键返回上级目录。</p><h3 id="1-3-配置TF卡设备树信息"><a href="#1-3-配置TF卡设备树信息" class="headerlink" title="1.3 配置TF卡设备树信息#"></a>1.3 配置TF卡设备树信息<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.3-%E9%85%8D%E7%BD%AEtf%E5%8D%A1%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BF%A1%E6%81%AF">#</a></h3><p>我们在完成内核配置后还需要配置TF卡的设备树配置，否则即便是能正常运行内核，在加载文件系统的时候还是会有问题，在这里配置很简单：</p><p>在<strong>linux-5.7.1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts</strong> 目录下，分别修改<strong>suniv-f1c100s.dtsi</strong>、<strong>suniv-f1c100s-licheepi-nano.dts</strong> 两个文件（记住这两个文件、以后我们修改的地方多了^_^）</p><p>修改<strong>suniv-f1c100s.dtsi</strong>文件</p><p>首先添加头文件(如果有则忽略)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;dt-bindings&#x2F;clock&#x2F;suniv-ccu-f1c100s.h&gt;</span><br><span class="line">#include &lt;dt-bindings&#x2F;reset&#x2F;suniv-ccu-f1c100s.h&gt;</span><br></pre></td></tr></table></figure><p>在soc-&gt;pio 下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mmc0_pins: mmc0-pins &#123;</span><br><span class="line">                pins &#x3D; &quot;PF0&quot;, &quot;PF1&quot;, &quot;PF2&quot;, &quot;PF3&quot;, &quot;PF4&quot;, &quot;PF5&quot;;</span><br><span class="line">                function &#x3D; &quot;mmc0&quot;;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure><p>soc下添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mmc0: mmc@1c0f000 &#123;</span><br><span class="line">            compatible &#x3D; &quot;allwinner,suniv-f1c100s-mmc&quot;,</span><br><span class="line">                     &quot;allwinner,sun7i-a20-mmc&quot;;</span><br><span class="line">            reg &#x3D; &lt;0x01c0f000 0x1000&gt;;</span><br><span class="line">            clocks &#x3D; &lt;&amp;ccu CLK_BUS_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_OUTPUT&gt;,</span><br><span class="line">                 &lt;&amp;ccu CLK_MMC0_SAMPLE&gt;;</span><br><span class="line">            clock-names &#x3D; &quot;ahb&quot;,</span><br><span class="line">                          &quot;mmc&quot;,</span><br><span class="line">                          &quot;output&quot;,</span><br><span class="line">                          &quot;sample&quot;;</span><br><span class="line">            resets &#x3D; &lt;&amp;ccu RST_BUS_MMC0&gt;;</span><br><span class="line">            reset-names &#x3D; &quot;ahb&quot;;</span><br><span class="line">            interrupts &#x3D; &lt;23&gt;;</span><br><span class="line">            pinctrl-names &#x3D; &quot;default&quot;;</span><br><span class="line">            pinctrl-0 &#x3D; &lt;&amp;mmc0_pins&gt;;</span><br><span class="line">            status &#x3D; &quot;disabled&quot;;</span><br><span class="line">            #address-cells &#x3D; &lt;1&gt;;</span><br><span class="line">            #size-cells &#x3D; &lt;0&gt;;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>如图，图中的配置可能与读者实际内容不一致，这是因为我改了很多东西，忽略即可，只需要关注红色框中的内容即可。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009162310863-1685576565.png"><img src="/posts/3433483963/483434-20211009162310863-1685576565.png" class="" title="img"></a></p><p> 修改<strong>suniv-f1c100s-licheepi-nano.dts</strong>文件，在根节点添加如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg_vcc3v3: vcc3v3 &#123;</span><br><span class="line">        compatible &#x3D; &quot;regulator-fixed&quot;;</span><br><span class="line">        regulator-name &#x3D; &quot;vcc3v3&quot;;</span><br><span class="line">        regulator-min-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">        regulator-max-microvolt &#x3D; &lt;3300000&gt;;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>外部添加mmc0使能代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;mmc0 &#123;</span><br><span class="line">        vmmc-supply &#x3D; &lt;&amp;reg_vcc3v3&gt;;</span><br><span class="line">        bus-width &#x3D; &lt;4&gt;;</span><br><span class="line">        broken-cd;</span><br><span class="line">        status &#x3D; &quot;okay&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位置如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202201/483434-20220114080223936-810553130.png"><img src="/posts/3433483963/483434-20220114080223936-810553130.png" class="" title="img"></a></p><p>接下来执行make命令开始编译内核和设备树相关的文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>首次进行编译，通常会需要很长时间，编译完成后，就会在在<strong>arch&#x2F;arm&#x2F;boot</strong>目录下生成内核文件：<strong>zImage</strong>，在<strong>arch&#x2F;arm&#x2F;boot&#x2F;dts</strong>目录下设备树文件：<strong>suniv-f1c100s-licheepi-nano.dtb</strong> 。</p><p>在编译过程中，因为所配置Ubuntu系统的差异，可能会因缺少某些组件导致编译报错，不要慌，将对应的错误关键信息复制到搜索引擎后安装即可，一下是作者碰到的两个编译报错，如果有必要可以提前安装：</p><p> <strong>linux-内核编译配置 lexer.lex.c错误</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wu@ubuntu:~&#x2F;linux-5.4.8$ make exynos_defconfig</span><br><span class="line">HOSTCC scripts&#x2F;basic&#x2F;fixdep</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;conf.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;confdata.o</span><br><span class="line">HOSTCC scripts&#x2F;kconfig&#x2F;expr.o</span><br><span class="line">LEX scripts&#x2F;kconfig&#x2F;lexer.lex.c</span><br><span class="line">&#x2F;bin&#x2F;sh: 1: flex: not found</span><br><span class="line">scripts&#x2F;Makefile.host:9: recipe for target ‘scripts&#x2F;kconfig&#x2F;lexer.lex.c’ failed</span><br><span class="line">make[1]: * [scripts&#x2F;kconfig&#x2F;lexer.lex.c] Error 127</span><br><span class="line">Makefile:567: recipe for target ‘exynos_defconfig’ failed</span><br><span class="line">make: * [exynos_defconfig] Error 2 </span><br></pre></td></tr></table></figure><p>解决方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bison</span><br><span class="line">sudo apt-get install flex</span><br></pre></td></tr></table></figure><p><strong>编译Linux内核时遇到：“error : openssl&#x2F;bio.h :No such file or folder”</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scripts&#x2F;extract-cert.c:21:25: fatal error: openssl&#x2F;bio.h: No such file or directory</span><br><span class="line">compilation terminated.</span><br><span class="line">scripts&#x2F;Makefile.host:90: recipe for target &#39;scripts&#x2F;extract-cert&#39; failed</span><br><span class="line">make[1]: * [scripts&#x2F;extract-cert] Error 1</span><br><span class="line">Makefile:556: recipe for target &#39;scripts&#39; failed</span><br><span class="line">make: * [scripts] Error 2</span><br></pre></td></tr></table></figure><p>安装openssl：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libssl-dev</span><br></pre></td></tr></table></figure><h3 id="1-4-TF分区配置"><a href="#1-4-TF分区配置" class="headerlink" title="1.4 TF分区配置#"></a>1.4 TF分区配置<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.4-tf%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE">#</a></h3><p>在上一篇中提到过u-boot 中的bootcmd 配置了Linux内核文件和设备树文件存放位置，即TF卡的0:1分区中，而且我们已经得到了对应的文件，那我们应该怎么操作呢。</p><p>还记得我们在上一篇中安装的Gparted软件吗，如果不记得，可以通过以下命令安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gparted</span><br></pre></td></tr></table></figure><p>把需要写入系统的TF卡插到电脑的USB上，打开该软件，可以看到此时有两个存储设备，一个是sda另一个是sdb，其中sdb就是我们的TF卡。如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009080733737-2007833399.png"><img src="/posts/3433483963/483434-20211009080733737-2007833399.png" class="" title="img"></a></p><p>选中sdb，我们可以看到分区表中显示为未分配，对于常规Linux嵌入式系统我们需要分两个区，一个是存放zImage和dtb文件，即在bootcmd中配置的0:1分区，另一个区存放根文件系统。对于第一个分区，格式为fat16格式，因为u-boot只能识别这个格式，对于第二个区，一般为ext4格式，为Linux内核识别的格式。下面开始分区吧。</p><p>选中未分配空间并右击鼠标，点击[新建]，然后填写相关属性，然后点击[添加],所示。</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081003602-856502421.png"><img src="/posts/3433483963/483434-20211009081003602-856502421.png" class="" title="img"></a></p><p> 需要注意【之前的空余空间】选择1M，这是给u-boot预留的(u-boot在分区表中是无法看到的)，【新大小】选择32M ，【文件系统】选择fat16，【卷标】输入boot。</p><p>我们这里可以用相同的方式新建第二分区——ext4分区，如下图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009081827144-1948779214.png"><img src="/posts/3433483963/483434-20211009081827144-1948779214.png" class="" title="img"></a></p><p> 这里我们设置为100M，文件系统为ext4，卷标为rootfs，然后添加添加。</p><p>配置好分区表后，点击工具来中的【对钩】使配置的分区表生效。</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082014437-279426574.png"><img src="/posts/3433483963/483434-20211009082014437-279426574.png" class="" title="img"></a></p><p>配置分区完毕后，我们就可以在文件管理器中看到挂载的两个分区，如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082321646-1578987260.png"><img src="/posts/3433483963/483434-20211009082321646-1578987260.png" class="" title="img"></a></p><h3 id="1-5-内核复制与执行"><a href="#1-5-内核复制与执行" class="headerlink" title="1.5 内核复制与执行#"></a>1.5 内核复制与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#1.5-%E5%86%85%E6%A0%B8%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>那么，我们将刚才生成好的zImage和dtb文件复制到TF卡的BOOT分区中</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009082706512-1631849134.png"><img src="/posts/3433483963/483434-20211009082706512-1631849134.png" class="" title="img"></a></p><p>退出TF卡，插入开发板，上电，按重启，我们就可以看到u-boot启动完成后，自动进入了内核启动环节，但是启动后一会就报错了，因为挂载文件系统产生错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">U-Boot SPL 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32)</span><br><span class="line">DRAM: 32 MiB</span><br><span class="line">Trying to boot from MMC1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2018.01-05679-g013ca457fd-dirty (Sep 28 2021 - 15:29:32 +0800) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Snail Card</span><br><span class="line">DRAM:  32 MiB</span><br><span class="line">MMC:   SUNXI SD&#x2F;MMC: 0</span><br><span class="line">*** Warning - bad CRC, using default environment</span><br><span class="line"></span><br><span class="line">In:    serial@1c25000</span><br><span class="line">Out:   serial@1c25000</span><br><span class="line">Err:   serial@1c25000</span><br><span class="line">Net:   No ethernet found.</span><br><span class="line">starting USB...</span><br><span class="line">No controllers found</span><br><span class="line">Hit any key to stop autoboot:  0 </span><br><span class="line">reading zImage</span><br><span class="line">4515448 bytes read in 231 ms (18.6 MiB&#x2F;s)</span><br><span class="line">reading suniv-f1c100s-licheepi-nano.dtb</span><br><span class="line">6105 bytes read in 26 ms (228.5 KiB&#x2F;s)</span><br><span class="line">## Flattened Device Tree blob at 80c00000</span><br><span class="line">   Booting using the fdt blob at 0x80c00000</span><br><span class="line">   Loading Device Tree to 816fb000, end 816ff7d8 ... OK</span><br><span class="line"></span><br><span class="line">Starting kernel ...</span><br><span class="line"></span><br><span class="line">[    0.000000] Booting Linux on physical CPU 0x0</span><br><span class="line">[    0.000000] Linux version 5.7.1 (twzy@ubuntu) (gcc version 7.2.1 20171011 (Linaro GCC 7.2-2017.11), GNU ld (Linaro_Binutils-2017.11) 2.28.2.20170706) #55 Tue Sep 28 21:04:24 CST 2021</span><br><span class="line">[    0.000000] CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr&#x3D;0005317f</span><br><span class="line">[    0.000000] CPU: VIVT data cache, VIVT instruction cache</span><br><span class="line">[    0.000000] OF: fdt: Machine model: LinuxCard by Kevin</span><br><span class="line">[    0.000000] Memory policy: Data cache writeback</span><br><span class="line">[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 8128</span><br><span class="line">[    0.000000] Kernel command line: console&#x3D;tty0 console&#x3D;ttyS0,115200 panic&#x3D;5 rootwait root&#x3D;&#x2F;dev&#x2F;mmcblk0p2  rw</span><br><span class="line">[    0.000000] Dentry cache hash table entries: 4096 (order: 2, 16384 bytes, linear)</span><br><span class="line">[    0.000000] Inode-cache hash table entries: 2048 (order: 1, 8192 bytes, linear)</span><br><span class="line">[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off</span><br><span class="line">[    0.000000] Memory: 21496K&#x2F;32768K available (7168K kernel code, 403K rwdata, 1664K rodata, 1024K init, 246K bss, 11272K reserved, 0K cma-reserved, 0K highmem)</span><br><span class="line">[    0.000000] SLUB: HWalign&#x3D;32, Order&#x3D;0-3, MinObjects&#x3D;0, CPUs&#x3D;1, Nodes&#x3D;1</span><br><span class="line"></span><br><span class="line"> …………………</span><br><span class="line"></span><br><span class="line">[    6.598874] Run &#x2F;etc&#x2F;init as init process</span><br><span class="line">[    6.603993] Run &#x2F;bin&#x2F;init as init process</span><br><span class="line">[    6.609078] Run &#x2F;bin&#x2F;sh as init process</span><br><span class="line">[    6.613763] Kernel panic - not syncing: No working init found.  Try passing init&#x3D; option to kernel. See Linux Documentation&#x2F;admin-guide&#x2F;init.rst for guidance.</span><br><span class="line">[    6.629985] CPU: 0 PID: 1 Comm: swapper Not tainted 5.7.1 #55</span><br><span class="line">[    6.636727] Hardware name: Allwinner suniv Family</span><br><span class="line">[    6.642216] [&lt;c010d604&gt;] (unwind_backtrace) from [&lt;c010ab60&gt;] (show_stack+0x10&#x2F;0x14)</span><br><span class="line">[    6.651031] [&lt;c010ab60&gt;] (show_stack) from [&lt;c01165a4&gt;] (panic+0xe8&#x2F;0x2e4)</span><br><span class="line">[    6.658951] [&lt;c01165a4&gt;] (panic) from [&lt;c071d080&gt;] (kernel_init+0xd8&#x2F;0x110)</span><br><span class="line">[    6.666960] [&lt;c071d080&gt;] (kernel_init) from [&lt;c0100140&gt;] (ret_from_fork+0x14&#x2F;0x34)</span><br><span class="line">[    6.675547] Exception stack(0xc1835fb0 to 0xc1835ff8)</span><br><span class="line">[    6.681293] 5fa0:                                     00000000 00000000 00000000 00000000</span><br><span class="line">[    6.690714] 5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000</span><br><span class="line">[    6.700102] 5fe0: 00000000 00000000 00000000 00000000 00000013 00000000</span><br><span class="line">[    6.707633] Rebooting in 5 seconds..</span><br><span class="line">[   12.687513] Reboot failed -- System halted</span><br></pre></td></tr></table></figure><p>内核移植就基本结束了，要想让小板真正的运行起来，还需要Linux的文件系统，那开始吧。</p><h2 id="2-文件系统移植"><a href="#2-文件系统移植" class="headerlink" title="2.文件系统移植#"></a>2.文件系统移植<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D">#</a></h2><p> 根文件系统(rootfs)是内核启动后挂载的第一个文件系统，如果没有根文件系统，内核将无法开启shell以及其他进程。</p><blockquote><p>实际上内核启动后会先挂载一个虚拟的文件系统，这个虚拟文件系统是在内存中运行的，其主要运行核心进程，虚拟文件系统挂载之后才挂载硬盘（TF卡或者emmc）上的根文件系统。</p></blockquote><p>制作文件系统也有很多方式，如通过busyBox、Buildroot等工具制作。</p><p>本次使用Buildroot，制作过程相对简单，兼容性好，由于根文件系统制作比较简单。</p><p>进入buildroot官网</p><p><a href="https://buildroot.org/downloads">https://buildroot.org/downloads</a></p><p>这里选择buildroot2018.2.11版本，将下载好软件包传入Ubuntu系统中，然后解压并进入源码目录中，输入清理命令。主要用于初始化一些设置，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean</span><br></pre></td></tr></table></figure><p>然后输入以下命令进入配置界面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>此时会终端进入图形配置界面，如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144509521-972063330.png"><img src="/posts/3433483963/483434-20211009144509521-972063330.png" class="" title="img"></a></p><h3 id="2-1-Target-options配置"><a href="#2-1-Target-options配置" class="headerlink" title="2.1 Target options配置#"></a><strong>2.1 Target options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.1-target-options%E9%85%8D%E7%BD%AE">#</a></h3><p>先选择<strong>Target options</strong>选项，进行对应芯片soc相关的配置，如图：</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009144541062-504084831.png"><img src="/posts/3433483963/483434-20211009144541062-504084831.png" class="" title="img"></a></p><p>配置如图所示，下面是对其的解释</p><ul><li>第一个选项为架构选择，这里选择ARM架构小端模式，</li><li>第二个为输出的二进制文件格式，这里选择EFL格式，</li><li>第三个为架构体系，这里选择arm926t，因为F1C200S&#x2F;F1C100S的架构就是这个架构，</li><li>第四个为矢量浮点处理器，这里不勾选，因为对于F1C200S&#x2F;F1C100S而言，其内部没有浮点运算单元，只能进行软浮点运算，也就是模拟浮点预运算。</li><li>第五个为应用程序二进制接口，这里选择EABI，原因是该格式支持软件浮点和硬件实现浮点功能混用。</li><li>第六个为浮点运算规则，这里使用软件浮点</li><li>第七个选择指令集，这里选择ARM指令集，因为thumb主要针对Cortex M系列而言的，对于运行操作系统的A系列以及ARM9和ARM11而言，使用的都是32位的ARM指令集。</li></ul><p>按【Tab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-2-Build-options配置"><a href="#2-2-Build-options配置" class="headerlink" title="2.2 Build options配置#"></a><strong>2.2 Build options配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.2-build-options%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第二个<strong>Build options</strong>选项，配置如图</p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150105319-120500590.png"><img src="/posts/3433483963/483434-20211009150105319-120500590.png" class="" title="img"></a></p><p>按T【ab键】选择**<save>**进行保存，按【Esc键】回到上一级配置界面。</p><h3 id="2-3-Toolchain配置"><a href="#2-3-Toolchain配置" class="headerlink" title="2.3 Toolchain配置#"></a><strong>2.3 Toolchain配置</strong><a href="https://www.cnblogs.com/twzy/p/15355842.html#2.3-toolchain%E9%85%8D%E7%BD%AE">#</a></h3><p>进入第三个<strong>Toolchain</strong>选项，配置如图：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009150540766-1755147867.png"><img src="/posts/3433483963/483434-20211009150540766-1755147867.png" class="" title="img"></a></p><p>这里我们选择一些C\C++相关的库，这样我们就可以在开发板上直接编译程序了，保存返回。</p><h3 id="2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置"><a href="#2-4-System-configuration配置-https-www-cnblogs-com-twzy-p-15355842-html-2-4-system-configuration配置" class="headerlink" title="2.4 System configuration配置[#](https://www.cnblogs.com/twzy/p/15355842.html#2.4 system-configuration配置)"></a><strong>2.4 System configuration配置</strong>[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.4">https://www.cnblogs.com/twzy/p/15355842.html#2.4</a> system-configuration配置)</h3><p>对于<strong>System configuration</strong>选项，这里主要是配置一些系统登录时候显示的内容，配置如图</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009151624384-1186247221.png"><img src="/posts/3433483963/483434-20211009151624384-1186247221.png" class="" title="img"></a></p><p>这里主要配置了登录时候显示的内容和root账号登录密码，接下来保存配置并且退回到命令行界面。</p><p>然后执行构建文件系统命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>因为是首次编译，而且buildroot在制作文件系统的时候需要联网获取组件，所以会编译很久，那么“去和妲己玩耍吧”</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009153556289-1299034541.png"><img src="/posts/3433483963/483434-20211009153556289-1299034541.png" class="" title="img"></a></p><p>当你终于被别人坑的自闭的时候，文件系统大概也许可能已经编译完毕了。</p><h3 id="2-5-文件系统移植与执行"><a href="#2-5-文件系统移植与执行" class="headerlink" title="2.5 文件系统移植与执行#"></a>2.5 文件系统移植与执行<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E4%B8%8E%E6%89%A7%E8%A1%8C">#</a></h3><p>此时在源码的<strong>output&#x2F;images</strong>目录下有一个rootfs.tar，这个文件就是最终生成的根文件系统镜像，现在只需要将该镜像解压到TF卡的第二分区即可。插入TF卡到电脑端，进入<strong>out&#x2F;images</strong>目录，然后输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;&lt;你的用户名&gt;&#x2F;rootfs&#x2F;</span><br><span class="line"># 墨云的账号是twzy</span><br><span class="line">sudo tar -xvf rootfs.tar -C &#x2F;media&#x2F;twzy&#x2F;rootfs&#x2F;</span><br></pre></td></tr></table></figure><p>此时可以看到TF卡的rootfs分区中有文件系统了</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172303012-746246639.png"><img src="/posts/3433483963/483434-20211009172303012-746246639.png" class="" title="img"></a></p><p>插入开发板，连接好串口，打开串口助手或者其他串口终端软件，可以看到根文件系统成功挂载，同时进入shell交互，用户名默认为root，密码：123456，进入root账号后</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172655126-653041256.png"><img src="/posts/3433483963/483434-20211009172655126-653041256.png" class="" title="img"></a></p><p>那么恭喜，你已经拥有了自己的Linux发行版。</p><p>至此我们完成了全部的系统移植任务，从下一篇开始我们将会升级我们的硬件设备和做一些更加有意义的东西，期待吗？</p><h3 id="2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格"><a href="#2-6-升级逼格-https-www-cnblogs-com-twzy-p-15355842-html-2-6-升级逼格" class="headerlink" title="2.6 升级逼格[#](https://www.cnblogs.com/twzy/p/15355842.html#2.6 升级逼格)"></a>2.6 升级逼格[#](<a href="https://www.cnblogs.com/twzy/p/15355842.html#2.6">https://www.cnblogs.com/twzy/p/15355842.html#2.6</a> 升级逼格)</h3><p>我们发现登录进自制的Linux系统后，命令行前置无论怎样只显示一个**#**号，逼格略低呀，怎么处理呢？</p><p>修改&#x2F;etc&#x2F;profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PS1&#x3D;&#39;[\u@\h: \w\a\]$&#39;</span><br></pre></td></tr></table></figure><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009172755348-361576513.png"><img src="/posts/3433483963/483434-20211009172755348-361576513.png" class="" title="img"></a></p><p>重启小板，就可以看到与与常规Linux一样的操作体验了，只是root账号的时候还是显示 <strong>$</strong> 符号</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173048942-1924983487.png"><img src="/posts/3433483963/483434-20211009173048942-1924983487.png" class="" title="img"></a></p><p>需要注意的是，在开发板运行过程中，如果想要重启，请先执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poweroff</span><br></pre></td></tr></table></figure><p>命令正常关闭系统后，在按重启按钮，否则有很大概率回造成文件系统损坏。</p><h2 id="3-点个灯吧"><a href="#3-点个灯吧" class="headerlink" title="3. 点个灯吧#"></a>3. 点个灯吧<a href="https://www.cnblogs.com/twzy/p/15355842.html#3.-%E7%82%B9%E4%B8%AA%E7%81%AF%E5%90%A7">#</a></h2><p>还记得我们在第一篇中提到过的我们自制小开发板的唯一的那个外设——LED灯吗？</p><p>那我们就利用Linux提供的GPIO系统通过shell命令进行点灯实验吧。</p><p>我们首先需要回到文件系统制作菜单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers -&gt; </span><br><span class="line">        GPIO Support -&gt;</span><br><span class="line">                &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;… (sysfs interface)。</span><br></pre></td></tr></table></figure><p>按如下方式进行配置，然后编译完rootfs，重新写入小板</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173731029-1575334130.png"><img src="/posts/3433483963/483434-20211009173731029-1575334130.png" class="" title="img"></a></p><p> <a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009163731073-1479927383.png"><img src="/posts/3433483963/483434-20211009163731073-1479927383.png" class="" title="img"></a></p><p>通过硬件可知LED灯连接的是<strong>PE6</strong>接口，低电平亮灯</p><p>这里我们先要了解一下GPIO编号和值的计算方式</p><blockquote><p>引脚编号 &#x3D; 控制引脚的寄存器基数 + 控制引脚寄存器位数<br>批注：<br>引脚编号是gpiochipxxx下的base + 第几个GPIO，也就是base加偏移，偏移的是位数。<br>例如gpiochip34 下的第1个GPIO那么编号就是34 + 1 &#x3D; 35</p></blockquote><p>对于F1C200S&#x2F;F1C100S这里：A&#x3D;0、B&#x3D;1、C&#x3D;2D&#x3D;3、E&#x3D;4 ……、32是固定值、6就是偏移量</p><p>举个栗子（如果使想用 PE6，那么引脚编号就可能等于 4 x 32 + 6 &#x3D; 134。</p><p>这是一些参考命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 1、导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line"># 2、设置方向</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 3、查看方向</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction</span><br><span class="line"># 4、设置输出（对于LED 设置1 为高电平即LED灯灭，设置0 为低电平，LED灯亮）</span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 5、查看输出值</span><br><span class="line">cat &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value</span><br><span class="line"># 6、取消导出</span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>输入如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;export</span><br><span class="line">echo out &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;direction # 灯亮 （默认设置为高电平）</span><br><span class="line">echo 0 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯灭 </span><br><span class="line">echo 1 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;gpio134&#x2F;value        # 灯亮</span><br><span class="line"></span><br><span class="line">echo 134 &gt; &#x2F;sys&#x2F;class&#x2F;gpio&#x2F;unexport</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://img2020.cnblogs.com/blog/483434/202110/483434-20211009173632837-1965450968.png"><img src="/posts/3433483963/483434-20211009173632837-1965450968.png" class="" title="img"></a></p><p> 我们这里借助Linux内建的GPIO子系统进行了电灯实验，但是真正Linux灵魂点灯是要通过驱动方式来实现的，但是谁让我是小白呢，以后再说吧。</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://whycan.com/t_7275.html">小白自制Linux开发板(F1C200s)整理系列，持续更新中</a></li><li><a href="https://www.cnblogs.com/twzy/p/14714651.html">瞎抄原理图与乱画PCB</a></li><li><a href="https://www.cnblogs.com/twzy/p/14865952.html"> 二. u-boot移植</a></li><li><a href="https://www.cnblogs.com/twzy/p/15355842.html">三. Linux内核与文件系统移植</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">小白自制Linux开发板</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zml3589110.github.io/posts/0.html"/>
    <id>https://zml3589110.github.io/posts/0.html</id>
    <published>2025-09-05T08:43:20.000Z</published>
    <updated>2025-09-15T13:23:36.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="F1C200S一步到位编译法"><a href="#F1C200S一步到位编译法" class="headerlink" title="F1C200S一步到位编译法"></a>F1C200S一步到位编译法</h1><p>兜兜转转还是玩上了MangoPi-R3！因为是ARM9的芯片内核架构，所以总觉得过时了的，至少也要整个ARM-A7的架构芯片。</p><img src="/posts/0/f5689089589dcee6cd852c4468152336.png" class="" title="在这里插入图片描述"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://mangopi.cc/f1c_mainline">https://mangopi.cc/f1c_mainline</a><br><a href="https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780">https://wiki.dfrobot.com/MangoPi_R3_SKU_DFR0780</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这款微型开发板专为运行 Linux 而设计。尽管机身很小，但它具有所有重要功能。板载F1C200S作为主控芯片，提供多种常用外设端口：GPIO、I2C&amp;SPI、SDIO、Audio port(record,play), Video(RGB565 Display, touch, DVP), USB Host, OTG等. 此外，板卡内置64MB DDR和板载128MB Nand Flash，全面支持Linux生态，运行完整的Python。</p><p>目前该产品是完全开源的，用户可以根据自己的需求编译任意模块。但是，它主要面向 Python 开发人员和高级爱好者，因为它上手有点困难。</p><h3 id="规格"><a href="#规格" class="headerlink" title="规格"></a>规格</h3><table><thead><tr><th>芯片型号</th><th>F1C100S</th><th>F1C200S</th><th>F1C500S</th><th>F1C600</th></tr></thead><tbody><tr><td>内存</td><td>SIP 32MB DDR1</td><td>64MB DDR1</td><td>128MB DDR1</td><td>256MB DDR1</td></tr></tbody></table><ul><li>QFN88封装（10x10mm）</li><li>板载 128MB Nand Flash</li><li>ARM926EJ-S内核，420MHz系统时钟默认频率，可超频至700MHz及以上</li><li>丰富的 GPIO 引脚</li><li>板载 SDIO 接口，用于连接 SD 卡或 SDIO WiFi + BT 模块</li><li>DVP摄像头接口，支持OV2640、GC0328等摄像头。</li><li>RGB565显示接口和6线触摸接口</li><li>板载麦克风和功率放大器</li><li>低功耗</li><li>支持完整的Python运行</li></ul><h3 id="芯片优缺点"><a href="#芯片优缺点" class="headerlink" title="芯片优缺点"></a>芯片优缺点</h3><ul><li>缺点：主频过低，内核太古老（ARM9）</li><li>优点：便宜，内置DDR，资料丰富（老芯片的优势）</li></ul><h3 id="MangoPi的Buildroot一键编译"><a href="#MangoPi的Buildroot一键编译" class="headerlink" title="MangoPi的Buildroot一键编译"></a>MangoPi的Buildroot一键编译</h3><p>地址：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r">https://github.com/mangopi-sbc/buildroot-mangopi-r</a></p><p>安装软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install rsync wget unzip build-essential git bc swig libncurses-dev libpython3-dev libssl-dev</span><br><span class="line">sudo apt install python3-distutils</span><br></pre></td></tr></table></figure><p>下载BSP包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/mangopi-sbc/buildroot-mangopi-r</span><br></pre></td></tr></table></figure><h3 id="第一次编译"><a href="#第一次编译" class="headerlink" title="第一次编译"></a>第一次编译</h3><p>注意：构建固件不需要 Root 权限。</p><h3 id="应用默认配置"><a href="#应用默认配置" class="headerlink" title="应用默认配置"></a>应用默认配置</h3><p>注意：应用 defconfig 会将所有 buildroot 配置重置为默认值。</p><p>通常，您只需要应用一次。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> buildroot-mangopi-r</span><br><span class="line">make widora_mangopi_r3_defconfig</span><br></pre></td></tr></table></figure><h3 id="常规编译"><a href="#常规编译" class="headerlink" title="常规编译"></a>常规编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j16</span><br></pre></td></tr></table></figure><h3 id="如果更改了-DTS-或-kenrel-构建"><a href="#如果更改了-DTS-或-kenrel-构建" class="headerlink" title="如果更改了 DTS 或 kenrel 构建"></a>如果更改了 DTS 或 kenrel 构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-kernel.sh</span><br></pre></td></tr></table></figure><h3 id="如果更改了-Uboot，则构建"><a href="#如果更改了-Uboot，则构建" class="headerlink" title="如果更改了 Uboot，则构建"></a>如果更改了 Uboot，则构建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./rebuild-uboot.sh</span><br></pre></td></tr></table></figure><h3 id="加快构建进度"><a href="#加快构建进度" class="headerlink" title="加快构建进度"></a>加快构建进度</h3><p><strong>在百度云下载离线的 dl</strong><br>Buildroot 将在编译固件时下载源代码。您可以获取“dl”文件夹的可信存档以加快速度。 <a href="https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111">https://pan.baidu.com/s/1-5CiMwXMQWjZxsFhsyRC5Q?pwd=1111</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.make <span class="built_in">source</span></span><br></pre></td></tr></table></figure><p>没有搞清楚这里是怎么用的，现在是下载了两个包：</p><ul><li>buildroot-dl-20220130.zip</li><li>buildroot-mangopi-r-master.zip<br>是不是把buildroot-dl-20220130.zip解压到buildroot-mangopi-r-master目录里面呢？</li></ul><blockquote><p>明白了，把buildroot-dl-20220130.zip解压出来并改名为dl，然后再把dl移动到buildroot-mangopi-r-master.zip解压出来的文件夹目录里面去就行了，编译的好快 啊。</p></blockquote><p>最终编译完成了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;u-boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;u-boot-sunxi-with-spl.bin&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;boot&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;bootfs.vfat&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): adding partition <span class="string">&#x27;rootfs&#x27;</span> (<span class="keyword">in</span> MBR) from <span class="string">&#x27;rootfs.ext4&#x27;</span> ...</span><br><span class="line">INFO: hdimage(sysimage-sdcard.img): writing MBR</span><br><span class="line">board/allwinner/generic/genimage-nor.cfg:33: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.kqghzcncg8<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.kqghzcncg8/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nor.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0xa00000@0x600000)</span><br><span class="line">board/allwinner/generic/genimage-nand.cfg:39: no sub-section title/index <span class="keyword">for</span> <span class="string">&#x27;config&#x27;</span></span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;rm -rf &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;/*&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;cp -a &quot;</span>/tmp/tmp.cjWlxAkEjg<span class="string">&quot; &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;find &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root&#x27; -depth -type d -printf &#x27;%P\0&#x27; | xargs -0 -I &#123;&#125; touch -r &#x27;/tmp/tmp.cjWlxAkEjg/&#123;&#125;&#x27; &#x27;/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/build/genimage.tmp/root/&#123;&#125;&#x27;&quot;</span> (stderr):</span><br><span class="line">INFO: cmd: <span class="string">&quot;mkdir -p &quot;</span>/home/liefyuan/Liefyuan/mangopi-r/buildroot-mangopi-r-master/output/images<span class="string">&quot;&quot;</span> (stderr):</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;u-boot&#x27;</span> (0x80000@0x0)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;splash&#x27;</span> (0x80000@0x80000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;kernel&#x27;</span> (0x500000@0x100000)</span><br><span class="line">INFO: flash(sysimage-nand.img): writing image partition <span class="string">&#x27;rom&#x27;</span> (0x7700000@0x600000)</span><br><span class="line"></span><br><span class="line">real20m23.669s</span><br><span class="line">user93m8.759s</span><br><span class="line">sys31m2.006s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译出来的文件：buildroot-mangopi-r-master&#x2F;output&#x2F;images</p><p>一步到位，所有版本都编译出来了（牛逼！）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootfs.vfat     rootfs.ext4        sysimage-sdcard.img</span><br><span class="line">devicetree.dtb  rootfs.squashfs    u-boot.bin</span><br><span class="line">kernel.itb      rootfs.tar         u-boot-sunxi-with-nand-spl.bin</span><br><span class="line">rootfs.cpio     splash.bmp         u-boot-sunxi-with-spl.bin</span><br><span class="line">rootfs.cpio.gz  sysimage-nand.img  zImage</span><br><span class="line">rootfs.ext2     sysimage-nor.img</span><br></pre></td></tr></table></figure><h3 id="刷固件"><a href="#刷固件" class="headerlink" title="刷固件"></a>刷固件</h3><p>指导说明文档：<a href="https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md">https://github.com/mangopi-sbc/buildroot-mangopi-r/blob/master/flashutils/README.md</a></p><p>Windows下失败了，转战Linux下烧录</p><h2 id="Linux下烧录"><a href="#Linux下烧录" class="headerlink" title="Linux下烧录"></a>Linux下烧录</h2><h3 id="使用sunxi-tools"><a href="#使用sunxi-tools" class="headerlink" title="使用sunxi-tools"></a>使用sunxi-tools</h3><p>sunxi-tools 是全志 SoC（全志科技开发的智能应用处理器 SoC）ARM 设备的命令行工具集合。</p><p>设置和安装 sunxi-tools</p><p>安装依赖包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pkg-config zlib1g-dev libusb-dev libusb-1.0-0-dev</span><br></pre></td></tr></table></figure><p>下载代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Icenowy/sunxi-tools.git -b f1c100s-spiflash</span><br></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> sunxi-tools</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>什么是dfu？ 设备固件升级（DFU）是一种独立于分销商和设备的机制，用于通过其制造商提供的改进版本来升级USB设备的固件，从而提供（例如）一种部署固件错误的方法修复。在固件升级操作过程中，USB 设备将有效地改变其工作模式，从而成为 PROM 编程器。按照官方 DFU 规范，任何类型的 USB 设备都可以实现此功能。DFU 还允许用户自由使用备份固件来刷新 USB 设备。结果之一是刷新的 USB 设备可以充当多种设备类型。</p><p>什么是 dfu-util？ dfu-util 是一个实现 USB DFU（通用串行总线设备固件升级）协议的主机 (PC) 程序。DFU 会将固件下载到通过 USB 连接的设备，或从设备下载固件。其应用范围从微控制器板等小型设备到手机设备。使用 dfu-util，您可以从支持 DFU 的设备下载&#x2F;上传固件。</p><p>通过 apt-get 安装 dfu-util</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install dfu-util</span><br></pre></td></tr></table></figure><h3 id="安装putty"><a href="#安装putty" class="headerlink" title="安装putty"></a>安装putty</h3><p>putty 是一个 Telnet、SSH 和串口连接软件。</p><p>安装串口工具putty</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install putty</span><br></pre></td></tr></table></figure><p>打开串口调试软件putty</p><p>默认安装的情况下，putty被添加到&#x2F;usr&#x2F;bin目录下，所以可以直接在终端使用putty命令打开。</p><p>在ubuntu上找串口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ dmesg | grep tty</span><br><span class="line">[    0.004000] console [tty0] enabled</span><br><span class="line">[    1.247164] 00:05: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A</span><br><span class="line">[25931.988675] usb 2-2.2: ch341-uart converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><p>由此可知，板子的串口是ttyUSB0</p><p>一般串口的名字在dev下，如果没有外接串口卡，默认是dev。</p><p>使用命令<code>ls /dev/ttyUSB0</code>查看是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">liefyuan@ubuntu:~/Liefyuan/myGit$ ls /dev/ttyUSB0</span><br><span class="line">/dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>如果结果存在，则串口地址为&#x2F;dev&#x2F;ttyUSB0</p><p>在putty中填入串口，然后打开串口格式化</p><p>序列号：填写对应的序列号<br>速度：填写115200</p><img src="/posts/0/f788e924e13b4e0c9512ea233e08c6d4.png" class="" title="在这里插入图片描述"><blockquote><p>打开有问题时记得加<code>sudo putty</code></p></blockquote><h3 id="擦除"><a href="#擦除" class="headerlink" title="擦除"></a>擦除</h3><p>putty打开以后，就进入固件位置:<br>同时按下tiny200的开机键和rst键，然后松开</p><p>此时运行.\fel-uboot.sh脚本</p><img src="/posts/0/1e5e0df7bf4da9879602649309c9e1ef.png" class="" title="在这里插入图片描述"><p>putty里面就有打印数据了</p><p>然后等待操作完成后，在putty里面输入命令：mtd erase spi-nand0，格式化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">U-Boot SPL 2020.07 (Feb 16 2022 - 01:28:19 +0000)</span><br><span class="line">DRAM: 64 MiB</span><br><span class="line">Trying to boot from FEL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">U-Boot 2020.07 (Feb 16 2022 - 01:28:19 +0000) Allwinner Technology</span><br><span class="line"></span><br><span class="line">CPU:   Allwinner F Series (SUNIV)</span><br><span class="line">Model: Allwinner F1C100s Generic Device</span><br><span class="line">DRAM:  64 MiB</span><br><span class="line">MMC:   mmc@1c0f000: 0, mmc@1c10000: 1</span><br><span class="line">Setting up a 800x480 lcd console (overscan 0x0)</span><br><span class="line">In:    serial</span><br><span class="line">Out:   vga</span><br><span class="line">Err:   vga</span><br><span class="line">Allwinner mUSB OTG (Peripheral)</span><br><span class="line">Hit any key to stop autoboot:  0</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">Card did not respond to voltage select!</span><br><span class="line">unrecognized JEDEC id bytes: ff, c8, 51</span><br><span class="line">Failed to initialize SPI flash at 0:0 (error -2)</span><br><span class="line">List of MTD devices:</span><br><span class="line">* spi-nand0</span><br><span class="line">  - device: spi-nand@1</span><br><span class="line">  - parent: spi@1c05000</span><br><span class="line">  - driver: spi_nand</span><br><span class="line">  - <span class="built_in">type</span>: NAND flash</span><br><span class="line">  - block size: 0x20000 bytes</span><br><span class="line">  - min I/O: 0x800 bytes</span><br><span class="line">  - OOB size: 128 bytes</span><br><span class="line">  - OOB available: 4 bytes</span><br><span class="line">  - 0x000000000000-0x000008000000 : <span class="string">&quot;spi-nand0&quot;</span></span><br><span class="line">=========================</span><br><span class="line">Boot Device: fel</span><br><span class="line">Boot Slot 0: empty</span><br><span class="line">Boot Slot 1: spi-nand</span><br><span class="line">=========================</span><br><span class="line">Booting from FEL...</span><br><span class="line">DFU waiting on SPI-NAND...</span><br><span class="line">musb-hdrc: peripheral reset irq lost!</span><br><span class="line">=&gt; mtd erase spi-nand0</span><br><span class="line">Erasing 0x00000000 ... 0x07ffffff (1024 eraseblock(s))</span><br><span class="line">=&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加文件权限<br>使用ll命令查看文件权限。</p><p>如果文件没有执行权限，则需要添加权限，通过以下命令添加权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x fel-uboot.sh</span><br><span class="line">chmod +x dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><h3 id="开始烧录"><a href="#开始烧录" class="headerlink" title="开始烧录"></a>开始烧录</h3><p>输入固件文件夹</p><p>按下开发板子上的 boot 按钮和 rst 按钮，然后松开rst按钮并运行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./fel-uboot.sh &amp;&amp; ./dfu-nand-ubifs.sh</span><br></pre></td></tr></table></figure><p>开始烧录啦，挺壮观的！</p><hr><h1 id="相关链接（侵删）"><a href="#相关链接（侵删）" class="headerlink" title="相关链接（侵删）"></a>相关链接（侵删）</h1><ol><li><a href="https://blog.csdn.net/qq_28877125/article/details/123143116">mangopi R3–Allwinner F1C200S一步到位编译法</a></li></ol><hr><center><font color=red>=================我是分割线=================</font></center><p><strong>欢迎到公众号来唠嗑:</strong></p><img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">]]></content>
    
    
    <summary type="html">Allwinner F1C200S一步到位编译法</summary>
    
    
    
    <category term="Linux" scheme="https://zml3589110.github.io/categories/Linux/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/categories/F1C200S/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/categories/mangopi-R3/"/>
    
    
    <category term="全志" scheme="https://zml3589110.github.io/tags/%E5%85%A8%E5%BF%97/"/>
    
    <category term="F1C200S" scheme="https://zml3589110.github.io/tags/F1C200S/"/>
    
    <category term="开发板" scheme="https://zml3589110.github.io/tags/%E5%BC%80%E5%8F%91%E6%9D%BF/"/>
    
    <category term="Linux" scheme="https://zml3589110.github.io/tags/Linux/"/>
    
    <category term="mangopi R3" scheme="https://zml3589110.github.io/tags/mangopi-R3/"/>
    
  </entry>
  
</feed>
