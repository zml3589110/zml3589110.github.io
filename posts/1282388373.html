<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>STM32实现动态加载APP | 赵逸尘个人博客</title><meta name="keywords" content="C,STM32,APP,ELF,DLL,AXF"><meta name="author" content="ZhaoYichen"><meta name="copyright" content="ZhaoYichen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="STM32芯片使用12864串口屏(驱动为ST7567)">
<meta property="og:type" content="article">
<meta property="og:title" content="STM32实现动态加载APP">
<meta property="og:url" content="https://zml3589110.github.io/posts/1282388373.html">
<meta property="og:site_name" content="赵逸尘个人博客">
<meta property="og:description" content="STM32芯片使用12864串口屏(驱动为ST7567)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2025-06-24T08:07:20.000Z">
<meta property="article:modified_time" content="2025-07-07T01:02:27.324Z">
<meta property="article:author" content="ZhaoYichen">
<meta property="article:tag" content="C">
<meta property="article:tag" content="STM32">
<meta property="article:tag" content="APP">
<meta property="article:tag" content="ELF">
<meta property="article:tag" content="DLL">
<meta property="article:tag" content="AXF">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon_1.png"><link rel="canonical" href="https://zml3589110.github.io/posts/1282388373"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZhaoYichen","link":"链接: ","source":"来源: 赵逸尘个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'STM32实现动态加载APP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-07-07 09:02:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.1.1"><link rel="alternate" href="/atom.xml" title="赵逸尘个人博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">371</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">529</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">216</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fas fa-random"></i><span> Random | 随机文章</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">赵逸尘个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/random.html"><i class="fa-fw fas fa-random"></i><span> Random | 随机文章</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">STM32实现动态加载APP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-24T08:07:20.000Z" title="发表于 2025-06-24 16:07:20">2025-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-07-07T01:02:27.324Z" title="更新于 2025-07-07 09:02:27">2025-07-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/">编程类</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%B1%BB/C/">C</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STM32/">STM32</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/APP/">APP</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DLL/">DLL</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="STM32实现动态加载APP"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>最近看到好多嵌入式操作系统都具有动态加载的相关功能，如Threadx和RT-Thread的moudle功能，但这些功能都与自身系统耦合很严重，大部分都要依赖于自己的工具链。考虑到MDK5使用的人最多，因此决定采用MDK5的相关工具链实现一个方便移植的动态加载实现。本程序中elf文件解析部分参照了RT-Thread的Moudle实现。实现过程中查阅了很多的资料，中间也遇到了蛮多的问题，索性最后都解决了。非常感谢硬汉大哥的文档教程，在里面学到了很多东西，本帖也算是我对论坛的一点点回馈，希望能帮助到有需要的人，相关代码与工程我都会放到附件中，供大家参考。</p>
<h1 id="什么是动态加载？"><a href="#什么是动态加载？" class="headerlink" title="什么是动态加载？"></a>什么是动态加载？</h1><p>  按照程序的加载方式进行分类，可以分为静态加载和动态加载。静态加载是指所以程序代码都在编译期予以确定，所有程序都需要存储在ROM中，程序尺寸受限于flash的尺寸，运行速度较快，无需预加载。动态加载是在编译期间，依靠函数或者其他手段，从其他的存储介质中将程序加载ram中运行，与静态加载相比更加灵活，可以很方便的进行程序升级，可以把暂时不需要使用的库释放掉，在需要使用的时候在将其加载到内存中，程序尺寸可以做的很大，可以很方便的实现APP程序。</p>
<h1 id="程序功能介绍"><a href="#程序功能介绍" class="headerlink" title="程序功能介绍"></a>程序功能介绍</h1><p>  本程序实现的是在STM32中实现程序的动态加载，使用起来与windows的dll类似。程序使用dl_load_lib加载相应的库文件到句柄中，加载成功后可使用dl_get_func，通过函数名获得相应函数指针，在不需要使用时可使用dl_destroy_lib对句柄进行释放。</p>
<h1 id="程序使用平台介绍"><a href="#程序使用平台介绍" class="headerlink" title="程序使用平台介绍"></a>程序使用平台介绍</h1><p>  本程序使用软件平台位MDK5的V6编译器，语法标准采用C99，移植了FATFS作为文件系统，使用楼主自己编写的内存管理函数进行动态内存的管理，硬件平台位STM32H743。</p>
<h2 id="内存管理算法"><a href="#内存管理算法" class="headerlink" title="内存管理算法"></a>内存管理算法</h2><p><a target="_blank" rel="noopener" href="https://www.armbbs.cn/forum.php?mod=viewthread&tid=108596&fromuid=24016">论坛首发，内存管理算法，支持malloc,realloc,align_alloc，配有内存碎片合并算法（v1.2)</a><br>(出处: 硬汉嵌入式论坛)</p>
<p>本次算法进行了部分更新，主要添加内存池式的初始化与分配方法，与硬汉哥在H7教程中的内存管理方法使用方式完全一致，另外代码是根据C99标准编写的，因此编译时需要勾选C99选项。<br><strong>mem_manage.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File name: mem_manage.h</span></span><br><span class="line"><span class="comment">* @Author: wzh</span></span><br><span class="line"><span class="comment">* @Version: 1.2</span></span><br><span class="line"><span class="comment">* @Date: 2021-9-3</span></span><br><span class="line"><span class="comment">* @Description: 内存管理算法，带有内存碎片合并算法，支持malloc、align_alloc、</span></span><br><span class="line"><span class="comment">*                                realloc、free等常见的内存管理函数，支持多块内存合并管理</span></span><br><span class="line"><span class="comment">*更新记录：</span></span><br><span class="line"><span class="comment">*                v1.0 2021-8-13  添加Mem_Manage_Heap_Init、Mem_Manage_Malloc、Mem_Manage_Realloc</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Aligned_Alloc函数</span></span><br><span class="line"><span class="comment">                v1.1 2021-8-14        添加Mem_Manage_Get_State函数</span></span><br><span class="line"><span class="comment">                v1.2 2021-9-3        更改Mem_Root结构体成员；更改Mem_State结构体成员；</span></span><br><span class="line"><span class="comment">                                                添加枚举类型Mem_Err_Type；将函数Mem_Manage_Heap_Init重命名为</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Init；修改Mem_Manage_Init函数声明；添加函数Mem_Manage_Get_Total_Size、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Get_Remain_Size、Mem_Manage_Get_Errflag、Mem_Manage_Pool_Init、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Malloc、Mem_Manage_Pool_Realloc、Mem_Manage_Pool_Aligned_Alloc、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Free、Mem_Manage_Pool_Get_State、Mem_Manage_Pool_Get_Total_Size、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Get_Remain_Size、Mem_Manage_Pool_Get_Errflag；</span></span><br><span class="line"><span class="comment">* @Todo        具体使用方法如下</span></span><br><span class="line"><span class="comment">*                 1、使用Mem_Manage_Init(Mem_Root* pRoot, const Mem_Region* pRigon)初始化</span></span><br><span class="line"><span class="comment">*                        内存区，pRoot为句柄，pRigon描述了内存区个数以及内个内存区起始地址和大小</span></span><br><span class="line"><span class="comment">*                        pRigon的格式如下</span></span><br><span class="line"><span class="comment">*                        const Mem_Region pRigon[]=</span></span><br><span class="line"><span class="comment">*                        &#123;</span></span><br><span class="line"><span class="comment">*                                (void*)(0x20000000),512*1024,</span></span><br><span class="line"><span class="comment">*                                (void*)(0x80000000),256*1024,</span></span><br><span class="line"><span class="comment">*                                ....</span></span><br><span class="line"><span class="comment">*                                NULL,0</span></span><br><span class="line"><span class="comment">*                        &#125;</span></span><br><span class="line"><span class="comment">*                        注意地址必需由低到高排列，同时使用NULL，0标识结尾，内存区容量不要太小，至少大于64个字节</span></span><br><span class="line"><span class="comment">*                 2、使用Mem_Manage_Malloc、Mem_Manage_Realloc、Mem_Manage_Aligned_Alloc进行内存</span></span><br><span class="line"><span class="comment">*                        分配，其中Mem_Manage_Malloc、Mem_Manage_Realloc默认均为8字节对齐，可修改</span></span><br><span class="line"><span class="comment">*                        .c文件中的宏定义修改，Mem_Manage_Aligned_Alloc可以指定地址对齐，但对齐的参数</span></span><br><span class="line"><span class="comment">*                        有限制，align_size需要为2的整数次幂，否则会直接返回NULL。</span></span><br><span class="line"><span class="comment">*                 3、内存使用完毕后使用Mem_Manage_Free进行内存释放</span></span><br><span class="line"><span class="comment">*                 4、可通过Mem_Manage_Get_State查看空闲内存状态，通过Mem_Manage_Get_Total_Size获取总内存，</span></span><br><span class="line"><span class="comment">*                        通过Mem_Manage_Get_Remain_Size获取剩余内存                </span></span><br><span class="line"><span class="comment">*                 5、算法管理的单个内存上限为2GB（32位机）</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MEM_MANAGE_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        MEM_NO_ERR=<span class="number">0X1234</span>,                <span class="comment">//无错误</span></span><br><span class="line">        MEM_NO_INIT=<span class="number">0</span>,                        <span class="comment">//内存区未初始化</span></span><br><span class="line">        MEM_OVER_WRITE=<span class="number">1</span>                <span class="comment">//内存区节点信息位置数据损坏</span></span><br><span class="line">&#125;Mem_Err_Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mem_Region</span> &#123;</span></span><br><span class="line">        <span class="keyword">void</span>*        addr;<span class="comment">//内存区起始地址</span></span><br><span class="line">        <span class="keyword">size_t</span>        mem_size;<span class="comment">//内存大小</span></span><br><span class="line">&#125;Mem_Region;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mem_Node</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Mem_Node</span>* <span class="title">next_node</span>;</span></span><br><span class="line">        <span class="keyword">size_t</span> mem_size;</span><br><span class="line">&#125;Mem_Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mem_Root</span> &#123;</span></span><br><span class="line">        Mem_Node* pStart;</span><br><span class="line">        Mem_Node* pEnd;</span><br><span class="line">        <span class="keyword">size_t</span> total_size;                <span class="comment">//总内存</span></span><br><span class="line">        <span class="keyword">size_t</span> remain_size;                <span class="comment">//剩余内存</span></span><br><span class="line">        Mem_Err_Type err_flag;        <span class="comment">//错误标记</span></span><br><span class="line">&#125;Mem_Root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Mem_State</span> &#123;</span></span><br><span class="line">        <span class="keyword">size_t</span> free_node_num;        <span class="comment">//空闲节点个数</span></span><br><span class="line">        <span class="keyword">size_t</span> max_node_size;        <span class="comment">//最大节点内存</span></span><br><span class="line">        <span class="keyword">size_t</span> min_node_size;        <span class="comment">//最小节点内存</span></span><br><span class="line">&#125;Mem_State;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mem_Manage_Init</span><span class="params">(Mem_Root* pRoot, <span class="keyword">const</span> Mem_Region* pRigon)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Malloc</span><span class="params">(Mem_Root* pRoot, <span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Realloc</span><span class="params">(Mem_Root* pRoot, <span class="keyword">void</span>* src_addr, <span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Aligned_Alloc</span><span class="params">(Mem_Root* pRoot, <span class="keyword">size_t</span> align_size, <span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Free</span><span class="params">(Mem_Root* pRoot, <span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Get_State</span><span class="params">(Mem_Root* pRoot, Mem_State* pState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Get_Total_Size</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Get_Remain_Size</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>;</span><br><span class="line"><span class="function">Mem_Err_Type <span class="title">Mem_Manage_Get_Errflag</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mem_Manage_Pool_Init</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> mem_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Malloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Realloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">void</span>* src_addr,<span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Aligned_Alloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> align_byte,<span class="keyword">size_t</span> want_size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Pool_Free</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">void</span>* free_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Pool_Get_State</span><span class="params">(<span class="keyword">void</span>* mem_addr,Mem_State* pState)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Pool_Get_Total_Size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Pool_Get_Remain_Size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>;</span><br><span class="line"><span class="function">Mem_Err_Type <span class="title">Mem_Manage_Pool_Get_Errflag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>mem_manage.h</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********************************************************************************</span></span><br><span class="line"><span class="comment">* @File name: mem_manage.c</span></span><br><span class="line"><span class="comment">* @Author: wzh</span></span><br><span class="line"><span class="comment">* @Version: 1.2</span></span><br><span class="line"><span class="comment">* @Date: 2021-9-3</span></span><br><span class="line"><span class="comment">* @Description: 内存管理算法，带有内存碎片合并算法，支持malloc、align_alloc、</span></span><br><span class="line"><span class="comment">*                                realloc、free等常见的内存管理函数，支持多块内存合并管理</span></span><br><span class="line"><span class="comment">*更新记录：</span></span><br><span class="line"><span class="comment">*                v1.0 2021-8-13  添加Mem_Manage_Heap_Init、Mem_Manage_Malloc、Mem_Manage_Realloc</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Aligned_Alloc函数</span></span><br><span class="line"><span class="comment">                v1.1 2021-8-14        添加Mem_Manage_Get_State函数</span></span><br><span class="line"><span class="comment">                v1.2 2021-9-3        更改Mem_Root结构体成员；更改Mem_State结构体成员；</span></span><br><span class="line"><span class="comment">                                                添加枚举类型Mem_Err_Type；将函数Mem_Manage_Heap_Init重命名为</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Init；修改Mem_Manage_Init函数声明；添加函数Mem_Manage_Get_Total_Size、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Get_Remain_Size、Mem_Manage_Get_Errflag、Mem_Manage_Pool_Init、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Malloc、Mem_Manage_Pool_Realloc、Mem_Manage_Pool_Aligned_Alloc、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Free、Mem_Manage_Pool_Get_State、Mem_Manage_Pool_Get_Total_Size、</span></span><br><span class="line"><span class="comment">                                                Mem_Manage_Pool_Get_Remain_Size、Mem_Manage_Pool_Get_Errflag；</span></span><br><span class="line"><span class="comment">********************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;mem_manage.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT                8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_BITS_PER_BYTE                                8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_MEM_STRUCT_SIZE                                Mem_Manage_Align_Up(sizeof(Mem_Node),MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_MINUM_MEM_SIZE                                (MEM_MANAGE_MEM_STRUCT_SIZE&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_ALLOCA_LABAL                                        ((size_t)(1&lt;&lt;(sizeof(size_t)*MEM_MANAGE_BITS_PER_BYTE-1)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_MINUM_NODE_SIZE                                (MEM_MANAGE_MEM_STRUCT_SIZE+MEM_MANAGE_MINUM_MEM_SIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_MANAGE_MEM_ROOT_SIZE                                Mem_Manage_Align_Up(sizeof(Mem_Root),MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">size_t</span> <span class="title">Mem_Manage_Align_Down</span><span class="params">(<span class="keyword">size_t</span> data, <span class="keyword">size_t</span> align_byte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data&amp;~(align_byte - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">size_t</span> <span class="title">Mem_Manage_Align_Up</span><span class="params">(<span class="keyword">size_t</span> data, <span class="keyword">size_t</span> align_byte)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (data + align_byte - <span class="number">1</span>)&amp;~(align_byte - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline Mem_Node* <span class="title">Mem_Manage_Addr_To_Mem</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Mem_Node*)((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)addr - MEM_MANAGE_MEM_STRUCT_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">void</span>* <span class="title">Mem_Manage_Mem_To_Addr</span><span class="params">(<span class="keyword">const</span> Mem_Node* mem_node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mem_node + MEM_MANAGE_MEM_STRUCT_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存节点插入空闲列表中</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">void</span> <span class="title">Mem_Insert_Node_To_FreeList</span><span class="params">(Mem_Root* pRoot, Mem_Node* pNode)</span> </span>&#123;</span><br><span class="line">        Mem_Node* pPriv_Node;</span><br><span class="line">        Mem_Node* pNext_Node;</span><br><span class="line">        <span class="comment">//寻找地址与pNode相近的节点</span></span><br><span class="line">        <span class="keyword">for</span> (pPriv_Node = pRoot-&gt;pStart; pPriv_Node-&gt;next_node &lt; pNode; pPriv_Node = pPriv_Node-&gt;next_node);</span><br><span class="line">        pNext_Node = pPriv_Node-&gt;next_node;</span><br><span class="line">        pRoot-&gt;remain_size += pNode-&gt;mem_size;</span><br><span class="line">        <span class="comment">//尝试pNode与前一个块进行合并</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pPriv_Node) + pPriv_Node-&gt;mem_size == (<span class="keyword">uint8_t</span>*)pNode) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pPriv_Node != pRoot-&gt;pStart) &#123;<span class="comment">//不是Start块的话可以合并</span></span><br><span class="line">                        pPriv_Node-&gt;mem_size += MEM_MANAGE_MEM_STRUCT_SIZE + pNode-&gt;mem_size;</span><br><span class="line">                        pRoot-&gt;remain_size += MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                        pNode = pPriv_Node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//后面如果是Start块不进行合并，以免浪费内存</span></span><br><span class="line">                        pRoot-&gt;pStart-&gt;next_node = pNode;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//不能合并时直接插入到空闲单链表中</span></span><br><span class="line">                pPriv_Node-&gt;next_node = pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试后面一个块与pNode进行合并</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pNode) + pNode-&gt;mem_size == (<span class="keyword">uint8_t</span>*)pNext_Node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNext_Node != pRoot-&gt;pEnd) &#123;<span class="comment">//不是end块的话可以进行块合并</span></span><br><span class="line">                        pNode-&gt;mem_size += MEM_MANAGE_MEM_STRUCT_SIZE + pNext_Node-&gt;mem_size;</span><br><span class="line">                        pRoot-&gt;remain_size += MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                        pNode-&gt;next_node = pNext_Node-&gt;next_node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//后面如果是end块不进行合并，以免浪费内存</span></span><br><span class="line">                        pNode-&gt;next_node = pRoot-&gt;pEnd;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//不能合并时直接插入到空闲单链表中</span></span><br><span class="line">                pNode-&gt;next_node = pNext_Node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> __inline <span class="keyword">void</span> <span class="title">Mem_Settle</span><span class="params">(Mem_Root* pRoot)</span></span>&#123;</span><br><span class="line">        Mem_Node* pNode=pRoot-&gt;pStart-&gt;next_node;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;next_node!=pRoot-&gt;pEnd)&#123;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pNode)+pNode-&gt;mem_size==(<span class="keyword">uint8_t</span>*)pNode-&gt;next_node)&#123;</span><br><span class="line">                        pNode-&gt;mem_size += MEM_MANAGE_MEM_STRUCT_SIZE+pNode-&gt;next_node-&gt;mem_size;</span><br><span class="line">                        pRoot-&gt;remain_size += MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                        pNode-&gt;next_node=pNode-&gt;next_node-&gt;next_node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                        pNode=pNode-&gt;next_node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取管理内存的状态</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//pState:状态信息结构体指针</span></span><br><span class="line"><span class="comment">//return:无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Get_State</span><span class="params">(Mem_Root* pRoot,Mem_State* pState)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;err_flag!=MEM_NO_ERR)&#123;</span><br><span class="line">                pState-&gt;free_node_num=<span class="number">0</span>;</span><br><span class="line">                pState-&gt;max_node_size=<span class="number">0</span>;</span><br><span class="line">                pState-&gt;min_node_size=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;pStart==<span class="literal">NULL</span>||pRoot-&gt;pEnd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pRoot-&gt;err_flag=MEM_NO_INIT;</span><br><span class="line">                pState-&gt;free_node_num=<span class="number">0</span>;</span><br><span class="line">                pState-&gt;max_node_size=<span class="number">0</span>;</span><br><span class="line">                pState-&gt;min_node_size=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pState-&gt;max_node_size = pRoot-&gt;pStart-&gt;next_node-&gt;mem_size;</span><br><span class="line">        pState-&gt;min_node_size = pRoot-&gt;pStart-&gt;next_node-&gt;mem_size;</span><br><span class="line">        pState-&gt;free_node_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Mem_Node* pNode = pRoot-&gt;pStart-&gt;next_node; pNode-&gt;next_node != <span class="literal">NULL</span>; pNode = pNode-&gt;next_node) &#123;</span><br><span class="line">                pState-&gt;free_node_num ++;</span><br><span class="line">                <span class="keyword">if</span> (pNode-&gt;mem_size &gt; pState-&gt;max_node_size)</span><br><span class="line">                        pState-&gt;max_node_size = pNode-&gt;mem_size;</span><br><span class="line">                <span class="keyword">if</span> (pNode-&gt;mem_size &lt; pState-&gt;min_node_size)</span><br><span class="line">                        pState-&gt;min_node_size = pNode-&gt;mem_size;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数aligned_alloc作用一致</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//align_size:期望分配的内存几字节对齐（8、16、32...)</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Aligned_Alloc</span><span class="params">(Mem_Root* pRoot,<span class="keyword">size_t</span> align_size, <span class="keyword">size_t</span> want_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* pReturn = <span class="literal">NULL</span>;</span><br><span class="line">        Mem_Node* pPriv_Node,*pNow_Node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;err_flag!=MEM_NO_ERR)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;pStart==<span class="literal">NULL</span>||pRoot-&gt;pEnd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pRoot-&gt;err_flag=MEM_NO_INIT;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (want_size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((want_size&amp;MEM_MANAGE_ALLOCA_LABAL) != <span class="number">0</span>) &#123;<span class="comment">//内存过大</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (align_size&amp;(align_size - <span class="number">1</span>)) &#123;<span class="comment">//内存对齐输入非法值</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (want_size &lt; MEM_MANAGE_MINUM_MEM_SIZE)</span><br><span class="line">                want_size = MEM_MANAGE_MINUM_MEM_SIZE;</span><br><span class="line">        <span class="keyword">if</span> (align_size &lt; MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT)</span><br><span class="line">                align_size = MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT;</span><br><span class="line">        <span class="comment">//确保分配的单元都是MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT的整数倍</span></span><br><span class="line">        want_size = Mem_Manage_Align_Up(want_size, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line"></span><br><span class="line">        pPriv_Node = pRoot-&gt;pStart;</span><br><span class="line">        pNow_Node = pRoot-&gt;pStart-&gt;next_node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pNow_Node-&gt;next_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pNow_Node-&gt;mem_size &gt;= want_size+ MEM_MANAGE_MEM_STRUCT_SIZE) &#123;</span><br><span class="line">                        <span class="keyword">size_t</span> use_align_size;</span><br><span class="line">                        <span class="keyword">size_t</span> new_size;</span><br><span class="line">                        pReturn = (<span class="keyword">void</span>*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)Mem_Manage_Mem_To_Addr(pNow_Node), align_size);<span class="comment">//计算出对齐的地址</span></span><br><span class="line">                        use_align_size = (<span class="keyword">uint8_t</span>*)pReturn-(<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pNow_Node);<span class="comment">//计算对齐所消耗的内存</span></span><br><span class="line">                        <span class="keyword">if</span> (use_align_size != <span class="number">0</span>) &#123;<span class="comment">//内存不对齐</span></span><br><span class="line">                                <span class="keyword">if</span> (use_align_size &lt; MEM_MANAGE_MINUM_NODE_SIZE) &#123;<span class="comment">//不对齐的值过小</span></span><br><span class="line">                                        pReturn = (<span class="keyword">void</span>*)Mem_Manage_Align_Up(\</span><br><span class="line">                                                (<span class="keyword">size_t</span>)Mem_Manage_Mem_To_Addr(pNow_Node)+ MEM_MANAGE_MINUM_NODE_SIZE, align_size);</span><br><span class="line">                                        use_align_size = (<span class="keyword">uint8_t</span>*)pReturn - (<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pNow_Node);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (use_align_size &lt;= pNow_Node-&gt;mem_size) &#123;</span><br><span class="line">                                        new_size = pNow_Node-&gt;mem_size - use_align_size;<span class="comment">//计算去除对齐消耗的内存剩下的内存大小</span></span><br><span class="line">                                        <span class="keyword">if</span> (new_size &gt;= want_size) &#123;<span class="comment">//满足条件，可以进行分配</span></span><br><span class="line">                                                Mem_Node* pNew_Node = Mem_Manage_Addr_To_Mem(pReturn);</span><br><span class="line">                                                pNow_Node-&gt;mem_size -= new_size + MEM_MANAGE_MEM_STRUCT_SIZE;<span class="comment">//分裂节点</span></span><br><span class="line">                                                pRoot-&gt;remain_size -= new_size + MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                                                pNew_Node-&gt;mem_size = new_size;<span class="comment">//新节点本来也不在空闲链表中，不用从空闲链表中排出</span></span><br><span class="line">                                                pNew_Node-&gt;next_node = (Mem_Node*)MEM_NO_ERR;</span><br><span class="line">                                                pNow_Node = pNew_Node;</span><br><span class="line">                                                <span class="keyword">break</span>;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//内存直接就是对齐的</span></span><br><span class="line">                                pPriv_Node-&gt;next_node = pNow_Node-&gt;next_node;<span class="comment">//排出空闲链表</span></span><br><span class="line">                                pNow_Node-&gt;next_node = (Mem_Node*)MEM_NO_ERR;</span><br><span class="line">                                pRoot-&gt;remain_size -= pNow_Node-&gt;mem_size;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pPriv_Node = pNow_Node;</span><br><span class="line">                pNow_Node = pNow_Node-&gt;next_node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pNow_Node-&gt;next_node == <span class="literal">NULL</span>)&#123;<span class="comment">//分配失败</span></span><br><span class="line">                <span class="keyword">if</span>(pNow_Node!=pRoot-&gt;pEnd)&#123;</span><br><span class="line">                        pRoot-&gt;err_flag=MEM_OVER_WRITE;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pNow_Node-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNow_Node-&gt;mem_size &gt;= MEM_MANAGE_MINUM_NODE_SIZE + want_size) &#123;<span class="comment">//节点内存还有富余</span></span><br><span class="line">                Mem_Node* pNew_Node =(Mem_Node*)((<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pNow_Node) + want_size);<span class="comment">//计算将要移入空闲链表的节点地址</span></span><br><span class="line">                pNew_Node-&gt;mem_size = pNow_Node-&gt;mem_size - want_size - MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                pNew_Node-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">                pNow_Node-&gt;mem_size = want_size;</span><br><span class="line">                Mem_Insert_Node_To_FreeList(pRoot, pNew_Node);</span><br><span class="line">        &#125;</span><br><span class="line">        pNow_Node-&gt;mem_size |= MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//标记内存已分配</span></span><br><span class="line">        <span class="keyword">return</span> pReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数malloc作用相同</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Malloc</span><span class="params">(Mem_Root* pRoot, <span class="keyword">size_t</span> want_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Aligned_Alloc(pRoot, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT, want_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数realloc作用相同</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//src_addr:源地址指针</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者句柄错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Realloc</span><span class="params">(Mem_Root* pRoot, <span class="keyword">void</span>* src_addr, <span class="keyword">size_t</span> want_size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* pReturn = <span class="literal">NULL</span>;</span><br><span class="line">        Mem_Node* pNext_Node,*pPriv_Node;</span><br><span class="line">        Mem_Node* pSrc_Node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;err_flag!=MEM_NO_ERR)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;pStart==<span class="literal">NULL</span>||pRoot-&gt;pEnd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pRoot-&gt;err_flag=MEM_NO_INIT;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (src_addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Mem_Manage_Aligned_Alloc(pRoot, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT, want_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (want_size == <span class="number">0</span>) &#123;</span><br><span class="line">                Mem_Manage_Free(pRoot, src_addr);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((want_size&amp;MEM_MANAGE_ALLOCA_LABAL) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pSrc_Node = Mem_Manage_Addr_To_Mem(src_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pSrc_Node-&gt;mem_size&amp;MEM_MANAGE_ALLOCA_LABAL) == <span class="number">0</span>) &#123;<span class="comment">//源地址未被分配，调用错误</span></span><br><span class="line">                pRoot-&gt;err_flag=MEM_OVER_WRITE;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pSrc_Node-&gt;mem_size &amp;= ~MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//清除分配标记</span></span><br><span class="line">        <span class="keyword">if</span> (pSrc_Node-&gt;mem_size &gt;= want_size) &#123;<span class="comment">//块预留地址足够大</span></span><br><span class="line">                pSrc_Node-&gt;mem_size |= MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//恢复分配标记</span></span><br><span class="line">                pReturn = src_addr;</span><br><span class="line">                <span class="keyword">return</span> pReturn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始在空闲列表中寻找与本块相近的块</span></span><br><span class="line">        <span class="keyword">for</span> (pPriv_Node = pRoot-&gt;pStart; pPriv_Node-&gt;next_node &lt;pSrc_Node; pPriv_Node = pPriv_Node-&gt;next_node);</span><br><span class="line">        pNext_Node = pPriv_Node-&gt;next_node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pNext_Node != pRoot-&gt;pEnd &amp;&amp; \</span><br><span class="line">                ((<span class="keyword">uint8_t</span>*)src_addr + pSrc_Node-&gt;mem_size == (<span class="keyword">uint8_t</span>*)pNext_Node) &amp;&amp; \</span><br><span class="line">                (pSrc_Node-&gt;mem_size + pNext_Node-&gt;mem_size + MEM_MANAGE_MEM_STRUCT_SIZE &gt;= want_size)) &#123;</span><br><span class="line">                <span class="comment">//满足下一节点非end，内存连续，内存剩余足够</span></span><br><span class="line">                pReturn = src_addr;</span><br><span class="line">                pPriv_Node-&gt;next_node = pNext_Node-&gt;next_node;<span class="comment">//排出空闲列表</span></span><br><span class="line">                pRoot-&gt;remain_size -= pNext_Node-&gt;mem_size;</span><br><span class="line">                pSrc_Node-&gt;mem_size += MEM_MANAGE_MEM_STRUCT_SIZE + pNext_Node-&gt;mem_size;</span><br><span class="line">                want_size = Mem_Manage_Align_Up(want_size, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">                <span class="keyword">if</span> (pSrc_Node-&gt;mem_size &gt;= MEM_MANAGE_MINUM_NODE_SIZE+ want_size) &#123;<span class="comment">//去除分配的剩余空间足够开辟新块</span></span><br><span class="line">                        Mem_Node* pNew_Node = (Mem_Node*)((<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pSrc_Node) + want_size);</span><br><span class="line">                        pNew_Node-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">                        pNew_Node-&gt;mem_size = pSrc_Node-&gt;mem_size - want_size - MEM_MANAGE_MEM_STRUCT_SIZE;</span><br><span class="line">                        pSrc_Node-&gt;mem_size = want_size;</span><br><span class="line">                        Mem_Insert_Node_To_FreeList(pRoot, pNew_Node);</span><br><span class="line">                &#125;</span><br><span class="line">                pSrc_Node-&gt;mem_size |= MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//恢复分配标记</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">                pReturn = Mem_Manage_Aligned_Alloc(pRoot, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT, want_size);</span><br><span class="line">                <span class="keyword">if</span> (pReturn == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                        pSrc_Node-&gt;mem_size |= MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//恢复分配标记</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(pReturn, src_addr, pSrc_Node-&gt;mem_size);</span><br><span class="line">                pSrc_Node-&gt;mem_size |= MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//恢复分配标记</span></span><br><span class="line">                Mem_Manage_Free(pRoot, src_addr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数free作用一致</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//addr:释放内存的首地址</span></span><br><span class="line"><span class="comment">//return:无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Free</span><span class="params">(Mem_Root* pRoot,<span class="keyword">void</span>* addr)</span> </span>&#123;</span><br><span class="line">        Mem_Node* pFree_Node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;err_flag!=MEM_NO_ERR)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;pStart==<span class="literal">NULL</span>||pRoot-&gt;pEnd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pRoot-&gt;err_flag=MEM_NO_INIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pFree_Node = Mem_Manage_Addr_To_Mem(addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pFree_Node-&gt;mem_size&amp;MEM_MANAGE_ALLOCA_LABAL) == <span class="number">0</span>) &#123;<span class="comment">//释放错误，没有标记</span></span><br><span class="line">                pRoot-&gt;err_flag=MEM_OVER_WRITE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pFree_Node-&gt;next_node != <span class="literal">NULL</span>) &#123;<span class="comment">//释放错误</span></span><br><span class="line">                pRoot-&gt;err_flag=MEM_OVER_WRITE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pFree_Node-&gt;mem_size &amp;= ~MEM_MANAGE_ALLOCA_LABAL;<span class="comment">//清除分配标记</span></span><br><span class="line">        Mem_Insert_Node_To_FreeList(pRoot, pFree_Node);<span class="comment">//插入到空闲链表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取句柄管理的内存区总容量</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//return:内存区总容量（单位：byte）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Get_Total_Size</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pRoot-&gt;total_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取句柄管理的内存区剩余容量</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//return:内存区剩余容量（单位：byte）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Get_Remain_Size</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pRoot-&gt;remain_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取句柄管理的内存区错误标记</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//return:错误标记</span></span><br><span class="line"><span class="function">Mem_Err_Type <span class="title">Mem_Manage_Get_Errflag</span><span class="params">(<span class="keyword">const</span> Mem_Root* pRoot)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pRoot-&gt;err_flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存管理句柄初始化</span></span><br><span class="line"><span class="comment">//pRoot:句柄指针</span></span><br><span class="line"><span class="comment">//pRigon:内存区结构体指针</span></span><br><span class="line"><span class="comment">//return:        true 初始化成功;</span></span><br><span class="line"><span class="comment">//                        false 初始化失败</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mem_Manage_Init</span><span class="params">(Mem_Root* pRoot,<span class="keyword">const</span> Mem_Region* pRegion)</span> </span>&#123;</span><br><span class="line">        Mem_Node* align_addr;</span><br><span class="line">        <span class="keyword">size_t</span> align_size;</span><br><span class="line">        Mem_Node* pPriv_node=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        pRoot-&gt;total_size = <span class="number">0</span>;</span><br><span class="line">        pRoot-&gt;pEnd = <span class="literal">NULL</span>;</span><br><span class="line">        pRoot-&gt;pStart = <span class="literal">NULL</span>;</span><br><span class="line">        pRoot-&gt;err_flag = MEM_NO_INIT;</span><br><span class="line">        pRoot-&gt;remain_size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; pRegion-&gt;addr != <span class="literal">NULL</span>; pRegion++) &#123;</span><br><span class="line">                align_addr = (Mem_Node*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)pRegion-&gt;addr, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);<span class="comment">//计算内存块对齐后的地址</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">uint8_t</span>*)align_addr &gt; pRegion-&gt;mem_size+ (<span class="keyword">uint8_t</span>*)pRegion-&gt;addr)<span class="comment">//对齐消耗的内存超过内存区</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                align_size = pRegion-&gt;mem_size - ((<span class="keyword">uint8_t</span>*)align_addr - (<span class="keyword">uint8_t</span>*)pRegion-&gt;addr);<span class="comment">//计算对齐后剩下的内存大小</span></span><br><span class="line">                <span class="keyword">if</span> (align_size &lt; MEM_MANAGE_MINUM_MEM_SIZE+ MEM_MANAGE_MEM_STRUCT_SIZE)<span class="comment">//对齐剩下的内存太小</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                align_size -= MEM_MANAGE_MEM_STRUCT_SIZE;<span class="comment">//求除去掉表头后内存块的大小</span></span><br><span class="line">                align_addr-&gt;mem_size = align_size;</span><br><span class="line">                align_addr-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">if</span> (pRoot-&gt;pStart == <span class="literal">NULL</span>) &#123;<span class="comment">//如果是初始化</span></span><br><span class="line">                        pRoot-&gt;pStart = align_addr;<span class="comment">//将当前内存块地址记为start</span></span><br><span class="line">                        <span class="keyword">if</span> (align_size &gt;= MEM_MANAGE_MINUM_MEM_SIZE+ MEM_MANAGE_MEM_STRUCT_SIZE) &#123;<span class="comment">//若剩下的块足够大</span></span><br><span class="line">                                align_size -= MEM_MANAGE_MEM_STRUCT_SIZE;<span class="comment">//去掉下一个块的表头剩下的内存大小</span></span><br><span class="line">                                align_addr = (Mem_Node*)((<span class="keyword">uint8_t</span>*)pRoot-&gt;pStart + MEM_MANAGE_MEM_STRUCT_SIZE);<span class="comment">//下一个块的表头地址</span></span><br><span class="line">                                align_addr-&gt;mem_size = align_size;</span><br><span class="line">                                align_addr-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">                                pRoot-&gt;pStart-&gt;mem_size = <span class="number">0</span>;</span><br><span class="line">                                pRoot-&gt;pStart-&gt;next_node = align_addr;</span><br><span class="line">                                pRoot-&gt;total_size = align_addr-&gt;mem_size;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;<span class="comment">//内存太小了，将当前内存块地址记为start</span></span><br><span class="line">                                pRoot-&gt;total_size = <span class="number">0</span>;</span><br><span class="line">                                pRoot-&gt;pStart-&gt;mem_size = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (pPriv_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                                pRoot-&gt;err_flag = MEM_NO_INIT;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        pPriv_node-&gt;next_node = align_addr;<span class="comment">//更新上一节点的next_node</span></span><br><span class="line">                        pRoot-&gt;total_size += align_size;</span><br><span class="line">                &#125;</span><br><span class="line">                pPriv_node = align_addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pPriv_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                pRoot-&gt;err_flag = MEM_NO_INIT;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时，pPriv_node为最后一个块，接下来在块尾放置表尾end</span></span><br><span class="line">        <span class="comment">//求出放置end块的地址,end块仅是方便遍历使用，因此尽量小，分配为MEM_MANAGE_MEM_STRUCT_SIZE</span></span><br><span class="line">        align_addr = (Mem_Node*)Mem_Manage_Align_Down(\</span><br><span class="line">                (<span class="keyword">size_t</span>)Mem_Manage_Mem_To_Addr(pPriv_node) + pPriv_node-&gt;mem_size - MEM_MANAGE_MEM_STRUCT_SIZE, MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        align_size = (<span class="keyword">uint8_t</span>*)align_addr-(<span class="keyword">uint8_t</span>*)Mem_Manage_Mem_To_Addr(pPriv_node);<span class="comment">//求出分配出end块后，前一个块剩余大小</span></span><br><span class="line">        <span class="keyword">if</span> (align_size &gt;= MEM_MANAGE_MINUM_MEM_SIZE) &#123;<span class="comment">//若剩下的块足够大</span></span><br><span class="line">                pRoot-&gt;total_size -= pPriv_node-&gt;mem_size - align_size;<span class="comment">//去掉分配end块消耗的内存</span></span><br><span class="line">                pRoot-&gt;pEnd = align_addr;                        <span class="comment">//更新表尾的地址</span></span><br><span class="line">                pPriv_node-&gt;next_node = align_addr;</span><br><span class="line">                pPriv_node-&gt;mem_size = align_size;</span><br><span class="line">                align_addr-&gt;next_node = <span class="literal">NULL</span>;</span><br><span class="line">                align_addr-&gt;mem_size = <span class="number">0</span>;<span class="comment">//end块不参与内存分配，因此直接为0就可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//最后一个块太小了，直接作为end块</span></span><br><span class="line">                pRoot-&gt;pEnd = pPriv_node;</span><br><span class="line">                pRoot-&gt;total_size -= pPriv_node-&gt;mem_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;pStart==<span class="literal">NULL</span>||pRoot-&gt;pEnd==<span class="literal">NULL</span>)&#123;</span><br><span class="line">                pRoot-&gt;err_flag=MEM_NO_INIT;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Mem_Settle(pRoot);</span><br><span class="line">        pRoot-&gt;err_flag=MEM_NO_ERR;</span><br><span class="line">        pRoot-&gt;remain_size=pRoot-&gt;total_size;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内存池初始化</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//mem_size:内存池大小</span></span><br><span class="line"><span class="comment">//return:        true 初始化成功;</span></span><br><span class="line"><span class="comment">//                        false 初始化失败</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Mem_Manage_Pool_Init</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> mem_size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* paddr=(<span class="keyword">uint8_t</span>*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT)+MEM_MANAGE_MEM_ROOT_SIZE;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">size_t</span> align_size=(<span class="keyword">uint8_t</span>*)paddr-(<span class="keyword">uint8_t</span>*)mem_addr;</span><br><span class="line">        Mem_Region buf_region[]=&#123;</span><br><span class="line">                <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">                <span class="literal">NULL</span>,<span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(mem_size&lt;align_size)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mem_size-=align_size;</span><br><span class="line">        <span class="keyword">if</span>(mem_size&lt;<span class="number">2</span>*MEM_MANAGE_MEM_STRUCT_SIZE+MEM_MANAGE_MINUM_NODE_SIZE)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        buf_region[<span class="number">0</span>].addr=paddr;</span><br><span class="line">        buf_region[<span class="number">0</span>].mem_size=mem_size;</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Init(root_addr,buf_region);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数malloc作用相同</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Malloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> want_size)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Malloc(root_addr,want_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数realloc作用相同</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//src_addr:源地址指针</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Realloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">void</span>* src_addr,<span class="keyword">size_t</span> want_size)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Realloc(root_addr,src_addr,want_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数aligned_alloc作用一致</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//align_size:期望分配的内存几字节对齐（8、16、32...)</span></span><br><span class="line"><span class="comment">//want_size:期望分配内存大小</span></span><br><span class="line"><span class="comment">//return:        NULL 分配失败（内存不足或者句柄错误标记不为MEM_NO_ERR）；</span></span><br><span class="line"><span class="comment">//                        其他值 分配成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Mem_Manage_Pool_Aligned_Alloc</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">size_t</span> align_byte,<span class="keyword">size_t</span> want_size)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Aligned_Alloc(root_addr,align_byte,want_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//与C库函数free作用一致</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//free_addr:释放内存的首地址</span></span><br><span class="line"><span class="comment">//return:无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Pool_Free</span><span class="params">(<span class="keyword">void</span>* mem_addr,<span class="keyword">void</span>* free_addr)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        Mem_Manage_Free(root_addr,free_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内存池的状态</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//pState:状态信息结构体指针</span></span><br><span class="line"><span class="comment">//return:无返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mem_Manage_Pool_Get_State</span><span class="params">(<span class="keyword">void</span>* mem_addr,Mem_State* pState)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        Mem_Manage_Get_State(root_addr,pState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内存池总容量</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//return:内存区总容量（单位：byte）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Pool_Get_Total_Size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Get_Total_Size(root_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内存池剩余容量</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//return:内存区剩余容量（单位：byte）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">Mem_Manage_Pool_Get_Remain_Size</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Get_Remain_Size(root_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取内存池错误标记</span></span><br><span class="line"><span class="comment">//mem_addr:内存池首地址</span></span><br><span class="line"><span class="comment">//return:错误标记</span></span><br><span class="line"><span class="function">Mem_Err_Type <span class="title">Mem_Manage_Pool_Get_Errflag</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* mem_addr)</span></span>&#123;</span><br><span class="line">        Mem_Root* root_addr=(Mem_Root*)Mem_Manage_Align_Up((<span class="keyword">size_t</span>)mem_addr,MEM_MANAGE_ALIGNMENT_BYTE_DEFAULT);</span><br><span class="line">        <span class="keyword">return</span> Mem_Manage_Get_Errflag(root_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文档说明:<strong>内存管理设计文档.pdf</strong></p>
<h1 id="实现原理简介"><a href="#实现原理简介" class="headerlink" title="实现原理简介"></a>实现原理简介</h1><p>  实现STM32动态加载的问题主要有以下几个：</p>
<ul>
<li><p>问题1：被动态加载的APP程序中，程序的基地址是伴随着动态内存变化的，这样就会产生重定位问题，APP中定义数据的地址也会随着程序基地址的改变而改变，如何将这种改变正确的传入到APP程序中？<br><strong>解决方案：</strong>在我们编程时，编译输出的文件都有一种共同的文件格式：elf文件格式，elf文件格式有很多，其中有的elf文件中，携带了便于实现动态加载的相关信息，可以将重定位操作对代码的影响位置与影响方式以表格的形式表示，Windows，Linux也都是使用这种elf文件实现程序动态加载的。通过对这种特殊的elf文件进行解析，即可实现APP代码的相关数据的重定位。</p>
</li>
<li><p>问题2：如何生成这样特殊的elf文件呢？<br><strong>解决方案：</strong>本程序使用的MDK5的V6编译器，利用了armlink中的BPABI中basic_platform特性，实现了这种特殊的elf文件生成。</p>
</li>
<li><p>问题3：主体程序是通过什么方式调用APP程序呢？<br><strong>解决方案：</strong>主程序调用APP的程序有两种方法，第一种是直接通过APP的程序入口点进行调用，用于简单调用的情况，每个APP程序的程序入口点为APP程序中的dl_main函数，可以直接通过主体函数dl_get_entry获得APP程序入口点dl_main的函数指针，进而进行调用。第二种是通过函数名进行调用，使用dl_get_func，以函数名的方式在动态链接表中寻找对应的函数指针，进而进行调用。注意：当且仅当APP中定义的函数被DLL_EXPORT修饰时，此函数名才会出现在动态链接表中，才能被主题程序调用。</p>
</li>
<li><p>问题4：APP程序如何调用主体程序的部分函数？<br><strong>解决方案：</strong>在主体程序与APP程序间，约定一个固定地址的程序向量表，主体程序把相关函数指针填入到向量表中，APP程序通过查表获取主体程序的函数指针，进而进行调用。</p>
</li>
</ul>
<h1 id="程序源码相关文件介绍"><a href="#程序源码相关文件介绍" class="headerlink" title="程序源码相关文件介绍"></a>程序源码相关文件介绍</h1><p>  主体程序包含头文件dl_lib.h，.c文件全部加入到工程中即可使用。APP程序编写可以参照附件中的模板工程（源码有点多，有需要在介绍）</p>
<p><strong>ELF手册-中文版.pdf</strong></p>
<h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><h2 id="动态加载运行的程序性能与正常的有差别"><a href="#动态加载运行的程序性能与正常的有差别" class="headerlink" title="动态加载运行的程序性能与正常的有差别"></a>动态加载运行的程序性能与正常的有差别</h2><p>在F1和F4上可能会有一点儿差别，动态加载会稍慢点，我这里只有H7的板子，没做测试。</p>
<p>在H7里，由于有Icahe，两个速度基本一样，没啥影响</p>
<img src="/posts/1282388373/001625db79yw8g8bi8g4hl.png" class="" title="img">

<p>APP动态加载测试程序</p>
<img src="/posts/1282388373/001847u7y686ip010168yh.png" class="" title="img">

<p>Host静态加载测试程序</p>
<img src="/posts/1282388373/003402wzqovhrhu71egghv.png" class="" title="img">

<p>实际测试效果，静态运行的函数与动态加载的函数运行时间基本一致</p>
<p><strong>之前做国网产品的时候，国网提供的操作系统就是动态加载app，知道是rtt的lwp模块，但是一直没有弄清楚。请问动态加载bin文件可以吗？之前国网提供的操作系统就是通过ymodem下载bin，然后再动态启动</strong></p>
<p>首先，我理解的Bin文件是纯粹的供单片机使用的二进制代码文件，不能直接直接动态加载bin文件，这直接是原理性的限制。RT-Thread也不能直接直接加载通常意义上的Bin文件。在动态加载时，程序代码的存储的位置是需要在运行时确定的，因此在动态加载时，需要更改机器码中所有与地址有关代码，这个操作需要链接器辅助支持（开启链接器的相关选项、编写相应的sct文件，示例的APP工程中有），链接器把与地址有关的代码位置与修改方式，以重定位表的形式附加在elf文件中，单纯的Bin文件中没有这个信息，因此也就不太可能实现。除非这个动态加载是存储在RAM的固定位置的，可那样的话也就不是真正意义上的动态加载了。</p>
<p>知道原理后，想法就可以特别多了啊，博主实现的是用MUC处理ELF文件得到可执行程序，你也可以使用上位机实现，甚至服务器实现也可以，最终都是得到可以运行的机器码，之前没有动态加载的功能是无法解决重定向的问题，博主这边文章实现重定向功能，只需要理解修改就可以了。</p>
<p>无论是MCU还是上位机或者服务器实现处理ELF文件得到可执行APP程序,都需要考虑APP程序固化问题吧，一旦MCU断电再上电还需要重新动态加载APP程序吧</p>
<p><strong>ThreadX 的Module，是否可以参考下？</strong></p>
<p>其实像这个动态加载的实现，参考ThreadX的moudle意义不大。当时实现陷入死胡同的时候，确实想着参考一下ThreadX的moudle，结果因为之前没用过ThreadX，没找到相关的实现在哪里。。。其实这种动态加载的实现都差不多，都是通过加载具有重定位信息的elf文件实现的，而且有很多的实现，都是需要依赖相应的工具链，比如RT-Thread的实现。我写的这个是根据elf文件结构实现的，好处就是比较通用，基本上只要是带有动态段的elf都支持，不过除了MDK5，其他工具链的就要自己研究研究怎么生成带有动态段的elf了</p>
<p><strong>如果是单独加载函数，且函数只用到了入口参数和局部变量应该相当于跳转，比较容易；如果加载的代码需要用到其他函数或全局变量可能需要动态加载内容比较多</strong></p>
<p>理解正确。其实重定位部分开销不算很大，而且只需要加载一次，后面在使用就和flash运行程序一致了</p>
<p><strong>H7-TOOL的lua 语言就是这个特点。但是Lua 库需要的空间资源还是很大的。我的理解是用App 生成 elf文件，再通过一个上位机将 elf文件发送给 HOST，HOST解析这些函数。 是这样的吗？</strong></p>
<p>差不多是这个意思。主机通过elf文件，把文件里程序的机器码回复出来，然后执行。与lua相比，空间资源要小很多很多，运行速度也是lua无法比拟的，另外不需要学习额外的编程语言，缺点就是比较依赖于工具链和芯片架构。</p>
<p><strong>elf文件太大，能做成类似bin不</strong></p>
<p>这个暂时没办法做成bin实现，因为bin文件里缺少用于重定位的辅助信息，不过如果将这个辅助信息保留，在添加到bin文件中，这样的话文件体积就会小很多很多。这个需要开发一个小工具实现这种操作，我没太接触过上位机开发，假期可以考虑实现一个这样的小工具</p>
<p>我后面又看了下链接器的命令行选项，通过命令行–nodebug –no-commment 可以把elf文件压缩的很小，基本上只保留了必要的信息。不知道是否满足你的要求</p>
<p><strong>我们这之前用Keil的Overlay实现过不同Code占用相同RAM，楼主这个更彻底，即是ROPI也是RWPI，并且自己写了ELF Loader。学习一下，以后看要不要用在项目上。</strong></p>
<p><strong>threadx的module生成的bin文件体积小，文件的最前位置带了信息。像rtt的动态加载就是elf体积比较大，好处就是可以定好函数符号表方便调用</strong></p>
<p>通过命令行配置可以让elf文件变小很多，在gitee提交的工程中修复了这个问题</p>
<p>在dynamic_loader那个仓库提交的</p>
<p><strong>SVC_CM7_Keil.lib   请问 这个库是负责什么功能的，WZH大侠</strong><br>SVC_CM7_IAR.a &#x2F; SVC_CM7_GCC.a &#x2F; SVC_CM7_Keil.lib: 16 bits mono&#x2F;stereo and<br>multichannel input&#x2F;output buffers, library runs on any STM32 microcontroller featuring a<br>core with Cortex&amp;#174;-M7 instruction set.</p>
<p>这个库是ST公司的一个智能音量控制的库，可以智能调节音频信号的增益，-80dB到36dB的范围</p>
<p><strong>动态加载的工程是独立编译么？</strong></p>
<p>被用来加载的elf文件与下载到单片机的工程是分开编译的，论坛里的app_elf_generate的工程用来生成被加载的elf文件，host_elf_loader则是用于解码加载elf文件的程序代码</p>
<p><strong>有必要测试一下函数查找, 加载和释放的耗时.</strong></p>
<p>这个不太好测，因为这个耗时是根据动态加载的elf不同而不同，主要的耗时操作如下。<br>dl_load_lib：读文件、分配内存空间、将elf文件的加载域复制到内存、地址重定位、分配函数字符串的空间。<br>其中地址重定位、分配函数字符串的空间与elf文件中的动态符号表数量有关，代码中和全局变量相关的代码越多，需要重定位的地方越多，导出的函数越多，句柄中的函数串越多。<br>dl_get_func:这个函数就是查表，根据字符串寻找到elf文件中的函数指针<br>dl_get_entry:这个函数返回句柄中的entry_addr，没有额外操作<br>dl_destroy_lib:释放掉加载elf文件的内存，释放掉字符串函数表的内存，与导出的函数数量正相关<br>在一般的使用中，这几个函数可以很快的执行完</p>
<p><strong>楼主，请问一下：dl_load_shared_object函数中加载elf文件时，分配的是栈上的空间，那么函数退出后，这段空间不就没有了嘛，怎么还能后续再次执行动态库中的代码逻辑呢？</strong></p>
<img src="/posts/1282388373/175053ap3eefw3lqp9jx9e.png" class="" title="img">

<p>这是分配在堆上呀，函数退出依旧会保持的内存区</p>
<p>抱歉，从linux过来的，看到alloc函数就下意识的认为是在栈上开辟的空间。我追到底层看了下，虽然不太理解，但是看到malloc ralloc 和alloc都是差不多的汇编实现，感谢楼主的回复。</p>
<p><strong>楼主你应该有发现用你这种方法(按你的工程进行编译)是有bug的.比如重定位时多个字符串的地址是同一个地址</strong></p>
<ul>
<li><p>源码和反汇编以及readelf</p>
<img src="/posts/1282388373/183010btgfz2uo6ztyop4t.jpg" class="" title="源码.jpg"></li>
</ul>
<img src="/posts/1282388373/183018e75wm1iw0115wvg0.jpg" class="" title="汇编代码.jpg">

<p>A:</p>
<p>这没问题，第一个Relocation为代码中引用全局变量的地址，这个肯定是不同的。<br>第二个是符号值，这个符号值其实是代表的这个全局变量在整个elf文件中的偏移地址，代码中多次引用同一个全局变量就会出现这种情况。</p>
<p>Q: </p>
<p> str &#x3D; “test string\r\n”; 这句代码通过重定位后,str获取的地址是”hello world\r\n”的地址, 你认真看下,里面有三对movw movt需要重定位, offset 0006 000e 这一对是获取str的地址,其他两对是本来分别是要获取”hello world\r\n” 和 “test string\r\n” 的地址, 但是后面两对都是获取”hello world\r\n”字符串的地址.</p>
<p>A:</p>
<p>这汇编确实有点问题，你用的编译器版本是什么呀，我一样的代码，和你的反汇编完全不一样。<br>file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;wzh&#x2F;Desktop&#x2F;%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-21%20093251.png<br>file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;wzh&#x2F;Desktop&#x2F;%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-21%20093439.png<br>file:&#x2F;&#x2F;&#x2F;C:&#x2F;Users&#x2F;wzh&#x2F;Desktop&#x2F;%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202022-04-21%20093453.png</p>
<p>建议检查一下，重新编译生成一下试试</p>
<img src="/posts/1282388373/094039hzee8t2qe8pmjf8g.png" class="" title="img">

<img src="/posts/1282388373/094046nn39n41khihanss1.png" class="" title="img">

<img src="/posts/1282388373/094048nexybbeepsg5ygeb.png" class="" title="img">





<p>场景使用：</p>
<ol>
<li>我们目前在MCU上跑dlmodule，可能更多是抱着学习，了解原理的心态，一般来说，动态模块会使用在RAM大于4MB的平台中。</li>
<li>动态模块可以对未来不可预知的一些功能的扩展</li>
<li>可以做到类似于安卓app，把一些特殊功能的应用交给第三方的模块独立完成</li>
<li>调试使用，比如调试某个具体功能时，如果每次都修改整个项目工程的源码，然后编译，下载，如果整体烧写flash效率比较低，此时就可以使用动态模块调试</li>
</ol>
<p><strong>一定要用keil编译吗？ gcc不行？</strong></p>
<p>程序分为两部分，一部分是用于加载程序的动态加载器，这部分可以用任何平台编译。<br>另一部分是被动态加载的程序，这部分使用Keil编译的，因为本文中的生成用于动态加载的程序利用了Keil的链接器的部分特性。如果gcc有这部分特性的话，当然可以用gcc编译，只不过需要自己研究一下相关的编译器与链接器手册。</p>
<p>其他：可以用GCC-ARM-NONE-EABI 编译器试一下，需要自己写.ld文件，.ld文件也可以借助STM32CUBE IDE 配置生成，然后再根据楼主.sct文件改改就好了</p>
<p><strong>版主你好，你发的教程里动态加载的实现，使用RAM空间较小的MCU能实现吗，比如stm32l431 64kRAM。是不是app代码不能写的太大，因为程序是加载到RAM中运行的？</strong></p>
<p>没错，是在ram中运行的。单个app的代码写的太大确实会装载不下，像这种情况可以把一个大的app拆成多个小的来加载。</p>
<p><strong>使用GCC编译 dl_vector.c 会有stdin、stdout、strerr initializer element is not constant 的error，这个问题有人遇到过吗</strong></p>
<p>A: 这几个变量和编译器有关，我这个只适用于arm clang编译器</p>
<p>楼主，您好。看你的文章大受启发，已经移植成功RTT的rt_err_t dlmodule_load_relocated_object(struct rt_dlmodule* module, void *module_ptr)<br>我请教一个问题，像这种Relocation type for arm的符号如何找到对应的汇编指令以及解析方式，我看您实现了R_ARM_THM_MOVW_ABS_NC 以及R_ARM_THM_MOVT_ABS，有相关资料去了解吗<br>谢谢~期待你的回复</p>
<p>这个我当时是在arm官网关于动态加载的文章中找到的，那篇文章链接现在失效了，可以在官网里再找找看。原文链接如下：<a target="_blank" rel="noopener" href="https://developer.arm.com/documentation/ihi0044/h/?lang=en#dynamic-linking">https://developer.arm.com/documentation/ihi0044/h/?lang=en#dynamic-linking</a></p>
<p>我已经在mdk环境和gcc环境测试都OK了，不过在你的工程上我只保留了uart、led、sd 这三个外设，你提供的资料帮助很大，非常感谢</p>
<p>函数表这些我都剪掉了，测试的时候自定义简单的就好了，后面有需要在慢慢添加</p>
<p>楼主，现在我工程里面可以动态调用函数了，不过我是裸机环境，子程序中调用的printf、clock等函数，现有的实现方式不行，按您的做法现在是会卡死，裸机环境下的实现您有研究过吗？由于不能使用SVC指令，我的理解应该要自定义管理中断服务程序、中断向量表等</p>
<p>我想的一种简单点的方式是主程序挂载回调函数的方式，提供给子程序调用，实现体还是在主程序中，我还未验证是否可行，即使可行，子程序代码可移植性没那么好</p>
<p>有什么建议提供给我参考吗，感谢</p>
<p>A: </p>
<p>我帖子里的工程好像有点问题，最好还是用gitee上的工程，另外我能想到的比较简单的方法就是约定一个固定的地址，把app要调用的函数指针以数组的形式存在这个地址里，app通过固定地址加偏移量，获取函数指针进行访问。</p>
<p><strong>能否使用全局的参数？比如主程序的一些结构体成员</strong></p>
<p>可以，可以将全局变量用指针传递进去</p>
<p><strong>请问，这个动态加载，可以支持RTOS吗？ 例如使用freeRTOS？</strong></p>
<p>支持，我用的RTX5</p>
<p>Q:非常感谢！我要深入的研究一下！现在不适用OS，简直已经不能用了。看来这个也可以移动到ThreadX下了。Thread-X下的MODULE主要是不能作为库使用。 我主要是需要动态加载很多的库！</p>
<p>Q:</p>
<p>这里还是有个迷惑的地方:<br>操作系统每个任务都是有自己的栈空间的，用来进行局部变量。<br>动态加载的函数，使用哪里的栈呢？ 因为OS任务切换的时候，都是维护自己的任务栈。 这里有点迷糊！</p>
<p>A:</p>
<p>arm单片机入栈出栈都是使用专用的PUSH,POP指令的，具体PUSH，POP的栈空间地址，是由MSP与PSP指针决定的。换言之，哪块调用了动态加载的代码，就使用哪里的栈空间。</p>
<h2 id="谢谢分享，你的elf-loader跟这个文章是类似的吗"><a href="#谢谢分享，你的elf-loader跟这个文章是类似的吗" class="headerlink" title="谢谢分享，你的elf loader跟这个文章是类似的吗"></a>谢谢分享，你的elf loader跟这个文章是类似的吗</h2><p><a target="_blank" rel="noopener" href="https://ourembeddeds.github.io/blog/2020/08/16/elf-loader/">https://ourembeddeds.github.io/blog/2020/08/16/elf-loader/</a></p>
<p>对，我的实现方法和这篇文章大体思路是一样的，但在具体操作上略有不同。我没做符号表的支持，也就是在编译时不链接一些函数，而是在动态加载时在链接。因为MDK5的编译器在编译base_platform属性的elf文件时，在编译期时就需要确定所有函数的定义，要不然无法链接。同时不使用这种符号表导入的方式可以大幅减少加载的的过程。</p>
<h2 id="ELF-Load-Dynamic-load-and-execute-for-your-mcu"><a href="#ELF-Load-Dynamic-load-and-execute-for-your-mcu" class="headerlink" title="ELF Load: Dynamic load and execute for your mcu."></a>ELF Load: Dynamic load and execute for your mcu.</h2><p>But wait! This is not totally the old-fashionist experience… My binaries must be embedded in the firmware in order to work! You also shouldn’t expect to be able to listen to your old 5’’ 1&#x2F;4 drive (or better, your dataset) but the fresh experience of binary loaded is lost for ever and never… or not?</p>
<h3 id="Loading-binaries-the-simplest-way"><a href="#Loading-binaries-the-simplest-way" class="headerlink" title="Loading binaries, the simplest way"></a>Loading binaries, the simplest way</h3><p>In an old PC, when you type a command, the operating system searchs a file with the command name and extension COM (or EXE in newer versions) and tries to load it… At this moment, several things happen:</p>
<ol>
<li>The system calculates memory usage of the executable and reserves this amount of memory in the system</li>
<li>The OS reads the file and copies the pertinent areas in the reserved memory.</li>
<li>Depending on architecture, some adjustments to loaded data may be needed. In the case of 8086 and <code>*.com</code> files, the architecture of the memory management unit enables load without any adjustments in this phase.</li>
<li>An execution environment is created (reserving memory if required) and configures some registers of the processor to point to this environment before the next phase</li>
<li>Finally, the OS jumps to the entry point of binary and delegates the execution to the recently loaded code</li>
</ol>
<p>As mentioned in the point 3, normally in a PC processor the architecture enables execution with minimun or unexisting binary modifications (segmentation in 8086 and MMU in modern x86 systems).</p>
<p>You can see next, the 8086 memory layout at COM executable load:</p>
<img src="/posts/1282388373/8086-executable-load.png" class="" title="8086-executable-load">

<p>In this example, the binary is limited to 64K of memory and the processor reserves one of the segments for the program usage (in the execution, the program can load more code or request more memory to OS, but the binary is limited to one 64K segment). In modern systems with a memory management unit (MMU), you can map any virtual direction to any real direction (well, not exactly… in 4K blocks of granularity, but you do understand, right?) and can select the memory layout of your executable freely.</p>
<p><img src="https://ourembeddeds.github.io/img/articles/elf-loader/VM-executable-load.png" alt="VM-executable-load"></p>
<p>Usually, the process to load executable in MMU systems is more complex, involves copy of a portion of the file dynamically at request using a virtual memory trick called page-fault. In short, you only need to configure the memory of your process with required pages and mark as no-present this pages; at the moment is necessary to access these pages, the hardware triggers an interrupt thath is caught by the OS who proceeds to load these pages for you.. cool don’t you think?.</p>
<p>But when you try to replicate this behavior in your embedded system… the magic is gone and you will quickly see the problem: You need to use fixed address for your binary load:</p>
<p><img src="https://ourembeddeds.github.io/img/articles/elf-loader/mcu-executable-load.png" alt="mcu-executable-load"></p>
<p>This schema works more or less properly for a single executable, but if you need nested executable load or multithread load, this approach is quickly wasted.</p>
<p>In many architectures (highlighting ARM, MIPS and RISC-V) the jumps normally refer to the current program counter (PC) to jump. In this architectures, the code is easy loadable in any position of memory (respecting some rules of aligns) but the data is more complex because it needs one or two indirections to refer a proper memory area independently of the load position.</p>
<h3 id="Fixing-the-world-one-word-at-time"><a href="#Fixing-the-world-one-word-at-time" class="headerlink" title="Fixing the world one word at time"></a>Fixing the world one word at time</h3><p>If your processor lacks MMU, to load programs at arbitrary addresses, you can look for several approaches:</p>
<ul>
<li>Make the code suitable to detect the current address and adjust their references in accordance to it: This is called “position independent code” or PIC (similar approach with very subtle differences is called “position independent executable” or PIE) and implies one or two levels of indirection in any code. But don’t celebrate yet, the PIC code has various challenges to solve:<ul>
<li>Jump of code independent of position: This normally is made using special processor features like PC relative jumps. This is easy when the compiler knows the relative position of code in compile time, but becomes difficult when the address of the code is dinamically calculated, like in jump tables.</li>
<li>Access data in arbitrary loadable position: Normally, the PIC code uses indirect access through a relocation table called global offset table (GOT) modified by the loader before code startup.</li>
<li>Mix of previous points: Normally, when your code jumps to a calculated position, you need a GOT entry reserved for this calculus and need to adjust this entry like other data access. Due to optimization, the compiler may prefer other approach, using an stub of code adjustable at startup for perform this dynamic jump. This technique is called procedure linkage table and consists in a little stub of code that performs a call to undefined pointer (normally an error function) and the loader adjusts this code in load time to point to the correct code block. This approach enables you to share code in libraries, although it requires a little more of work.</li>
</ul>
</li>
<li>Leave any memory reference as undefined and mark in a table the needed to modify this portion of code in order for the program to work.</li>
</ul>
<p>The first approach needs less work in the loader area but the performance at runtime is worse than the fixed memory address code. In contrast, the second approach needs more loader work but the performance of the code is nearly the same as the fixed address code…</p>
<p>In the end, the PIC code is the only suitable way to share code across multiple libraries for single binaries. For example, with the PIC code you can have a one library for string formatting (aka printf) and share the code with many programs. Additionally, the PIC code can reside in flash without any modifications, only a PLT and GOT is required in RAM, and change from program to program (this require OS help on context switch).</p>
<h6 id="Global-offset-table-schema"><a href="#Global-offset-table-schema" class="headerlink" title="Global offset table schema"></a>Global offset table schema</h6><p><img src="https://ourembeddeds.github.io/img/articles/elf-loader/got-operation.png" alt="got-operation"></p>
<h6 id="Relocation-schema"><a href="#Relocation-schema" class="headerlink" title="Relocation schema"></a>Relocation schema</h6><figure class="highlight as"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern int f1(int, int, char);</span></span><br><span class="line"><span class="comment">// void func1() &#123;</span></span><br><span class="line"><span class="comment">//   f1(0, 0xAA55AA55, 32);</span></span><br><span class="line">  movs    r2, #32</span><br><span class="line">  movs    r0, #0</span><br><span class="line">  ldr     r1, [pc, #4]    // &lt;func1+0xc&gt;</span><br><span class="line">  ldr     r3, [pc, #8]    // &lt;func1+0x10&gt;</span><br><span class="line">  bx      r3</span><br><span class="line">  nop <span class="comment">// Align instruction</span></span><br><span class="line">  .word   <span class="number">0xaa55aa55</span></span><br><span class="line">  .word   <span class="number">0x00000000</span> <span class="comment">// &lt;f1&gt; replace with addr of symbol</span></span><br></pre></td></tr></table></figure>

<h3 id="Put-ya-guns-on"><a href="#Put-ya-guns-on" class="headerlink" title="Put ya guns on!"></a>Put ya guns on!</h3><p>Our preferred approach in embedded systems is to load the code and relocate individual references instead of GOT usage due to the performance degradation of adding two indirections (one for GOT pointer and one for GOT entry) in every memory access.</p>
<p>In MMU systems, the ELF load process is really straightforward:</p>
<ul>
<li>Map the file from disk to memory (with help from MMU and OS swap service) and resolve memory map to satisfy the ELF layout.</li>
<li>Scan a relocation table and resolve undefined symbols (normally from dynamic libraries in the system).</li>
<li>Make a process environment and adjust the process register to point to it (normally an in-memory structure representing the process state).</li>
<li>Let the OS load the new processor state with the correct environment. Normally, this is limited to putting the process state in a ready queue in the OS structures and letting the scheduler do the switch process when available.</li>
</ul>
<p>Without MMU, the process require some precautions:</p>
<ol>
<li>You cannot load the entire ELF from secondary storage because this action consumes more memory than expected (the ELF may contains debugging sections, some unneeded information like symbol tables and other non required data at runtime).</li>
<li>The memory is non-virtualized, all process share the same memory space and can potentially access (in a harmful way) the memory from other process… You need to take precautions, some MCU have a protection memory system (like MPU on ARM or PMP on RISC-V) to mitigate this issue.</li>
<li>You need to reserve only loadable sections like <code>.text</code>, <code>.data</code>, <code>.rodata</code>, <code>.bss</code>, and <code>.stack</code>, other sections are only used at the load time like relocation symbols and elf header.</li>
<li>You need to travel trough all symbols and relocate every entry in the binary… this may take some time but the execution time has little impact compared with the PIC code.</li>
</ol>
<p>You can see our implementation of the load-relocate schema in <a target="_blank" rel="noopener" href="https://github.com/martinribelotta/elfloader">this link</a>.</p>
<p>Due to the simple nature of the loader, it cannot handle all type of relocations and sections. Ideally, you can extend the code to cover your necessities, but the actual implementation works fine with some precautions at the moment of guest binary compilation:</p>
<ul>
<li>You cannot use “COMMON” sections, all of non initialized data must be in BSS. The gcc flag to force this is <code>-fno-common</code>.</li>
<li>You need to link the final ELF as a relocatable executable. This prevents the linker from resolving undefined symbols, instead it embeds the information needed to resolve the symbols in the binary. The gcc or ld flag to force this linking behavior is <code>-r</code>.</li>
<li>You need to force the compiler to produce only “word relocation” types. This is the simplest relocation form and is easier to handle in load time. In ARM architecture, this forces all relocations to be of type <code>R_ARM_ABS32</code>. To enable this, gcc for ARM provides the flag: <code>-mlong-call</code>. In old compilers this is not strictly true and the flag will not produce correct results, many relocations will be of type <code>R_ARM_THB_CALL</code> or <code>R_ARM_THB_JMP</code>. Don’t panic, the actual loader can handle this type of relocations, but the load phase will be sensibly slower due to major processing work.</li>
<li>By default, all compilers provide a startup library that is executed before main, and initializes some data and code for you, but this is undesirable in this situation. You need to disable the inclusion of these codes and provide a self written version to <code>_start</code> or other function of your election. This behavior can be enabled in gcc using the <code>-nostartfiles</code> flag.</li>
</ul>
<p>Additionally, you can provide a linker script with your preferred memory layout, but the suggested minimum linker script layout looks like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(_start)</span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">	.text <span class="number">0x00000000</span> :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.text* .text.*)</span><br><span class="line">	&#125;</span><br><span class="line">	.rodata :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.rodata* .rodata.*)</span><br><span class="line">	&#125;</span><br><span class="line">	.data :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.data* .data.*)</span><br><span class="line">	&#125;</span><br><span class="line">	.bss :</span><br><span class="line">	&#123;</span><br><span class="line">		*(.bss .bss.* .sbss .sbss.* COMMON)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>This places all sections in contiguous memory. If your architecture requires some align, you need to add “<code>. = ALIGN(n);</code>” statements between sections.</p>
<p>At this point, the loader API is really simple:</p>
<h4 id="Initialize-it"><a href="#Initialize-it" class="headerlink" title="Initialize it."></a>Initialize it.</h4><p>You need to define an environment variable for the new binary with:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">   <span class="keyword">const</span> ELFSymbol_t *exported;</span><br><span class="line">   <span class="keyword">size_t</span> exported_size;</span><br><span class="line">&#125; ELFEnv_t;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> ELFEnv_t elfEnv = &#123;</span><br><span class="line">   symbolTable,</span><br><span class="line">   <span class="keyword">sizeof</span>(symbolTable) / <span class="keyword">sizeof</span>(ELFSymbol_t)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This contain a reference to an array of resolvable symbols and the number of the elements inside the array. The entries of this array contain the name and the pointer to be resolved:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">/*!&lt; Name of symbol */</span></span><br><span class="line">  <span class="keyword">void</span> *ptr; <span class="comment">/*!&lt; Pointer of symbol in memory */</span></span><br><span class="line">&#125; ELFSymbol_t;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> ELFSymbol_t symbolTable[] = &#123;</span><br><span class="line">   &#123; <span class="string">&quot;printf&quot;</span>, (<span class="keyword">void</span>*) <span class="built_in">printf</span> &#125;,</span><br><span class="line">   &#123; <span class="string">&quot;scanf&quot;</span>, (<span class="keyword">void</span>*) <span class="built_in">scanf</span> &#125;,</span><br><span class="line">   &#123; <span class="string">&quot;strstr&quot;</span>, (<span class="keyword">void</span>*) <span class="built_in">strstr</span> &#125;,</span><br><span class="line">   &#123; <span class="string">&quot;fctrl&quot;</span>, (<span class="keyword">void</span>*) fctrl &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Additionally, you need to create an object of type <code>loader_env_t</code> and set the symbol table inside this struct.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ELFExec_t *exec;</span><br><span class="line"><span class="keyword">loader_env_t</span> loader_env;</span><br><span class="line">loader_env.env = env;</span><br></pre></td></tr></table></figure>

<p>In the next phase, you need to call <code>load_elf</code> with the PATH of the binary, the environment and a reference to the pointer of <code>ELFExec_t</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_elf(<span class="string">&quot;/flash/bin/test1.elf&quot;</span>, loader_env, &amp;exec);</span><br></pre></td></tr></table></figure>

<p>If the operation ends successfully, the return status is <code>0</code>. In case of an error, it will return negative number indicating the specific error.</p>
<p>In this point, you have the binary loaded and allocated in the memory, and you can jump into start entry point or request the address of specific symbols:</p>
<p>In the first case, you need to call the function like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = jumpTo(exec);</span><br><span class="line"><span class="keyword">if</span> (ret...</span><br></pre></td></tr></table></figure>

<p>If the program ends successfully, the function returns 0, otherwise it will return a negative number depending to the error.</p>
<p>If you need to request an specific function pointer you can use</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *symbolPtr = get_func(<span class="string">&quot;myFunction&quot;</span>, exec);</span><br></pre></td></tr></table></figure>

<p>This returns a pointer to the function start or <code>NULL</code> if the object is not found.</p>
<p>If you need an arbitrary pointer to other symbol (variable, constant or whatever) you can use:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *symbolPtr = get_obj(<span class="string">&quot;myVar&quot;</span>, exec);</span><br></pre></td></tr></table></figure>

<p>After all, you can free all allocated memory for the binary and the metadata of the ELF file with:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unload_elf(exec);</span><br></pre></td></tr></table></figure>

<h3 id="System-interface"><a href="#System-interface" class="headerlink" title="System interface"></a>System interface</h3><p>In order to be flexible in the implementation, the library leaves undefined some API of low level access for port to any system.</p>
<p>The low level layer need the following macros defined:</p>
<ul>
<li><code>LOADER_USER_DATA</code>: Structure or datatype to contain the platform dependent data for file access. For example, this needs at least, a file object (integer file descriptor, FILE* struct, or whatever) and an environment pointer to <code>ELFEnv_t</code>.</li>
<li><code>LOADER_OPEN_FOR_RD(userdata, path)</code>: open file in path and modify userdata in order to save the file descriptor, or file pointer.</li>
<li><code>LOADER_FD_VALID(userdata)</code>: Check if the opened file data is a valid file and can be read from.</li>
<li><code>LOADER_READ(userdata, buffer, size)</code>: Read <code>size</code> bytes from file descriptor in <code>userdata</code> and put it in <code>buffer</code> array.</li>
<li><code>LOADER_WRITE(userdata, buffer, size)</code>: Write <code>size</code> bytes to file descriptor in <code>userdata</code> from <code>buffer</code> pointer. This macro is not used internally, it is only defined in symmetry with the macro above.</li>
<li><code>LOADER_CLOSE(userdata)</code>: Close the file descriptor in <code>userdata</code>.</li>
<li><code>LOADER_SEEK_FROM_START(userdata, off)</code>: Move read pointer <code>off</code> bytes from the start of file pointed by descriptor in <code>userdata</code>.</li>
<li><code>LOADER_TELL(userdata)</code>: Return current position of file descriptor in <code>userdata</code>.</li>
<li><code>LOADER_ALIGN_ALLOC(size, align, perm)</code>: Return <code>size</code> bytes aligned as <code>align</code> bytes with <code>perm</code> permission access. If you do not provides differentiate access of memory region, the returned region can be write, read and execute. By default, the macro call a function <code>void *do_alloc(size_t size, size_t align, ELFSecPerm_t perm);</code>.</li>
<li><code>LOADER_FREE(ptr)</code>: Deallocate memory from pointer <code>ptr</code></li>
<li><code>LOADER_STREQ(s1, s2)</code>: Compare two strings s1, and s2. The result of equal strings must be <strong><code>!= 0</code></strong> and when the strings differ, the result of this macro must be <strong><code>0</code></strong>. The simplest implementation is: <code>(strcmp((s1), (s2)) == 0)</code></li>
<li><code>LOADER_JUMP_TO(entry)</code>: Perform a jump to application entry point. <code>entry</code> is the address of the first instruction of the code. You can simply cast the value to a function pointer with selected fingerprint or do a more complex operation like environment creation, start a new RTOS thread or whatever is required for your architecture.</li>
<li><code>DBG(...)</code>: Print (in printf like format) debug messages. Can be empty if you do not need debug messages.</li>
<li><code>ERR(...)</code>: Print (in printf like format) error messages. Can be empty if you do not need error messages.</li>
<li><code>MSG(msg)</code>: Print (in printf like format) information messages. Can be empty if you do not need information messages.</li>
<li><code>#define LOADER_GETUNDEFSYMADDR(userdata, name)</code>: Resolve symbol name <code>name</code> and return its address. The most simple way to do this is to perform a search in specific structure under <code>userdata</code> with a symbol table. If the process fail, the data returned must be <code>0xffffffff</code> AKA <code>((uint32_t) -1)</code></li>
</ul>
<p>The golden implementation uses ARM semihosting IO for file access, but you can port this to any API like fatfs or similar.</p>
<h1 id="contiki里面也实现了动态加载"><a href="#contiki里面也实现了动态加载" class="headerlink" title="contiki里面也实现了动态加载"></a>contiki里面也实现了动态加载</h1><p><a target="_blank" rel="noopener" href="https://github.com/contiki-os/contiki/blob/master/core/loader/elfloader.c">https://github.com/contiki-os/contiki/blob/master/core/loader/elfloader.c</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/contiki-os/contiki/wiki/The-dynamic-loader">https://github.com/contiki-os/contiki/wiki/The-dynamic-loader</a></p>
<hr>
<h1 id="相关链接-侵删"><a href="#相关链接-侵删" class="headerlink" title="相关链接(侵删)"></a>相关链接(侵删)</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.armbbs.cn/forum.php?mod=viewthread&tid=109952&extra=&page=1">STM32H7 论坛首发，STM32实现动态加载模组（似于Windows的dll），使用MDK编译动态库类 </a></li>
</ol>
<hr>
<center><font color=red>=================我是分割线=================</font></center>


<p><strong>欢迎到公众号来唠嗑:</strong></p>
<img src="https://pic4.zhimg.com/80/v2-eedc5dc7d30beedf4c2f1812df8e61a7_720w.jpg">

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zml3589110.github.io">ZhaoYichen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zml3589110.github.io/posts/1282388373.html">https://zml3589110.github.io/posts/1282388373.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zml3589110.github.io" target="_blank">赵逸尘个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C</a><a class="post-meta__tags" href="/tags/STM32/">STM32</a><a class="post-meta__tags" href="/tags/APP/">APP</a><a class="post-meta__tags" href="/tags/ELF/">ELF</a><a class="post-meta__tags" href="/tags/DLL/">DLL</a><a class="post-meta__tags" href="/tags/AXF/">AXF</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/2632262355.html"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">基于MQTT微信小程序</div></div></a></div><div class="next-post pull-right"><a href="/posts/3022745837.html"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ESP8266 如何使用 GPIO13 &amp; GPIO15 进行 UART0 通信？</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/944314574.html" title="STM32通过SPI驱动ST7789(使用DMA)"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-30</div><div class="title">STM32通过SPI驱动ST7789(使用DMA)</div></div></a></div><div><a href="/posts/423287766.html" title="STM32实现SPI跟DMA功能"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-30</div><div class="title">STM32实现SPI跟DMA功能</div></div></a></div><div><a href="/posts/1164397684.html" title="合并hex文件"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-02</div><div class="title">合并hex文件</div></div></a></div><div><a href="/posts/2741096271.html" title="STM32F错误收集"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-22</div><div class="title">STM32F错误收集</div></div></a></div><div><a href="/posts/2588001421.html" title="LVGL输入设备对接"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-20</div><div class="title">LVGL输入设备对接</div></div></a></div><div><a href="/posts/4122746189.html" title="LVGL启动过程"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-18</div><div class="title">LVGL启动过程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZhaoYichen</div><div class="author-info__description">直到这一刻微笑着说话为止，我至少留下了一公升眼泪</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">371</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">529</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">216</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zml3589110"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/zml3589110" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zhaominglong_life@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是动态加载？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">程序功能介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%BD%BF%E7%94%A8%E5%B9%B3%E5%8F%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.</span> <span class="toc-text">程序使用平台介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">内存管理算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-number">5.</span> <span class="toc-text">实现原理简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%BA%90%E7%A0%81%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">6.</span> <span class="toc-text">程序源码相关文件介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%AF%B4%E6%98%8E"><span class="toc-number">7.</span> <span class="toc-text">其他说明</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD%E4%B8%8E%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%9C%89%E5%B7%AE%E5%88%AB"><span class="toc-number">7.1.</span> <span class="toc-text">动态加载运行的程序性能与正常的有差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%A2%E8%B0%A2%E5%88%86%E4%BA%AB%EF%BC%8C%E4%BD%A0%E7%9A%84elf-loader%E8%B7%9F%E8%BF%99%E4%B8%AA%E6%96%87%E7%AB%A0%E6%98%AF%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%90%97"><span class="toc-number">7.2.</span> <span class="toc-text">谢谢分享，你的elf loader跟这个文章是类似的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF-Load-Dynamic-load-and-execute-for-your-mcu"><span class="toc-number">7.3.</span> <span class="toc-text">ELF Load: Dynamic load and execute for your mcu.</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loading-binaries-the-simplest-way"><span class="toc-number">7.3.1.</span> <span class="toc-text">Loading binaries, the simplest way</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fixing-the-world-one-word-at-time"><span class="toc-number">7.3.2.</span> <span class="toc-text">Fixing the world one word at time</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Global-offset-table-schema"><span class="toc-number">7.3.2.0.0.1.</span> <span class="toc-text">Global offset table schema</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Relocation-schema"><span class="toc-number">7.3.2.0.0.2.</span> <span class="toc-text">Relocation schema</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Put-ya-guns-on"><span class="toc-number">7.3.3.</span> <span class="toc-text">Put ya guns on!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Initialize-it"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">Initialize it.</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-interface"><span class="toc-number">7.3.4.</span> <span class="toc-text">System interface</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#contiki%E9%87%8C%E9%9D%A2%E4%B9%9F%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD"><span class="toc-number">8.</span> <span class="toc-text">contiki里面也实现了动态加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5-%E4%BE%B5%E5%88%A0"><span class="toc-number">9.</span> <span class="toc-text">相关链接(侵删)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/3233973243.html" title="全志F1C200S F1C100S 介绍"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全志F1C200S F1C100S 介绍"/></a><div class="content"><a class="title" href="/posts/3233973243.html" title="全志F1C200S F1C100S 介绍">全志F1C200S F1C100S 介绍</a><time datetime="2025-09-15T09:52:20.000Z" title="发表于 2025-09-15 17:52:20">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3416408887.html" title="F1C200S使用keil5开发问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="F1C200S使用keil5开发问题"/></a><div class="content"><a class="title" href="/posts/3416408887.html" title="F1C200S使用keil5开发问题">F1C200S使用keil5开发问题</a><time datetime="2025-09-15T07:04:20.000Z" title="发表于 2025-09-15 15:04:20">2025-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3511617639.html" title="Web Serial网页串口"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web Serial网页串口"/></a><div class="content"><a class="title" href="/posts/3511617639.html" title="Web Serial网页串口">Web Serial网页串口</a><time datetime="2025-09-10T13:03:20.000Z" title="发表于 2025-09-10 21:03:20">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/968082855.html" title="全志F1C100s使用记录"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="全志F1C100s使用记录"/></a><div class="content"><a class="title" href="/posts/968082855.html" title="全志F1C100s使用记录">全志F1C100s使用记录</a><time datetime="2025-09-10T11:59:20.000Z" title="发表于 2025-09-10 19:59:20">2025-09-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2546212267.html" title="ESP8266内置网页配置"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ESP8266内置网页配置"/></a><div class="content"><a class="title" href="/posts/2546212267.html" title="ESP8266内置网页配置">ESP8266内置网页配置</a><time datetime="2025-09-10T08:09:20.000Z" title="发表于 2025-09-10 16:09:20">2025-09-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ZhaoYichen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a href="icp连接"><img class="icp-icon" src="icp图片"><span>备案号：xxxxxx</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>